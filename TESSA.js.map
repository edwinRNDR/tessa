{"version":3,"file":"TESSA.js","mappings":"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,QAAO6tC,EAAI,QACrF7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QACrF7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QACrF7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAErF7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QACrF7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QACrF7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QACrF7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAErF7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QACrF7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QACrF7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QACrF7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAErF7tC,KAAK,QAAO6tC,EAAI,QAAO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7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAC5G7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAE5G7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAC5G7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAC5G7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAC5G7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAC5G7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAE5G7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAC5G7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAAO7tC,KAAK,QAAO6tC,EAAI,QAC5G7tC,KAAK,QAAO6tC,EAAI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AAA,EsZv6CC,GAAI,cAAO,oB,EAAW,kB,WtZ+CL,c,EA+yCZ,EAAa,IAAwB,KAuErC,EAvEN,EAuEM,4CAAb,C,QAAK,EAAQ,kB,EAvEA,EAAa,EsZ/tCuyyC,EtZ+tC/wyC,KAuErC,EsZtyCozyC,EtZsyCpzyC,4CAAb,C,MAAa,kBsZr6C4D,cAAIA,GtZs6CzE,EAAY,cAAI,E,CAAhB,EAAY,cACT,E,GAAA,C,CsZt6CF,OAFD,IAAA4xC,GAAA,I,gCAGK,G,IlZbT,EAAW,EAFT,GERY,IAAd,KFQE,E,EERF,C,IAAK,EAAS,U,IFUd,EAAW,EAFM,GERH,IAAd,KFQiB,E,EERjB,C,IAAK,EAAS,U,MgZwBoC,4BlZlDqC,GkZkDrC,clZlDqC,GkZkDrC,eAAe5wC,EAAM,SAAN,clZlDsB,GkZkDtB,clZlDsB,IAqC/D,EAAK,cAAI,E,OEXjC,EFQiB,GAGO,EAAK,cACtB,E,OEZP,EFQE,G,QAIK,EkZaK,iBAAO,qBAAaA,EAAM,SAAO,oB,EAAa,mBACzC,kBAAO,qBlZfI,EAAM,SA8EuB,oBkZ9DxC,IlZXC,cAyEuC,qBkZ9DjBA,EAAM,SAAO,oB,EAAa,kB,KlZjBlE,EAAW,EAON,GEjBS,IAAd,KFiBK,E,EEjBL,C,IAAK,EAAS,U,IFUd,EAAW,EAOS,GEjBN,IAAd,KFiBoB,E,EEjBpB,C,IAAK,EAAS,U,MgZ4B+B,4BlZtD0C,GkZsD1C,clZtD0C,GkZsD1C,eAAeA,EAAM,SAAN,clZtD2B,GkZsD3B,clZtD2B,IAqC/D,EAAK,cAAI,E,OEXjC,EFiBoB,GANI,EAAK,cACtB,E,OEZP,EFiBK,G,EALE,C,QkZc2DA,EAAM,SAG/D,OALL,IAAA4wC,GAAA,I,iCAOK,G,IlZrBT,EAAW,EAUE,GEpBC,IAAd,KFoBa,E,EEpBb,C,IAAK,EAAS,U,IFUd,EAAW,EAUiB,GEpBd,IAAd,KFoB4B,E,EEpB5B,C,IAAK,EAAS,U,MgZgCoC,4BlZ1DqC,GkZ0DrC,clZ1DqC,GkZ0DrC,gBAAe5wC,EAAM,SAAN,clZ1DsB,GkZ0DtB,clZ1DsB,IAqC/D,EAAK,cAAI,E,OEXjC,EFoB4B,GATJ,EAAK,c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AAd,KFgB8D,E,EEhB9D,C,IAAK,EAAS,U,IFUd,EAAW,EAMkE,GEhB/D,IAAd,KFgB6E,E,EEhB7E,C,IAAK,EAAS,U,MiZ2B+B,4BnZrD0C,GmZqD1C,cnZrD0C,GmZqD1C,eAAeA,EAAM,SAAN,cnZrD2B,GmZqD3B,cnZrD2B,IAqC/D,EAAK,cAAI,E,OEXjC,EFgB6E,GALrD,EAAK,cACtB,E,OEZP,EFgB8D,G,EAJvD,C,QmZa2DA,EAAM,SAG/D,OALL,IAAA6wC,GAAA,I,iCAOK,G,InZpBT,EAAW,EAS4D,GEnBzD,IAAd,KFmBuE,E,EEnBvE,C,IAAK,EAAS,U,IFUd,EAAW,EAS2E,GEnBxE,IAAd,KFmBsF,E,EEnBtF,C,IAAK,EAAS,U,MiZ+BsC,4BnZzDmC,GmZyDnC,cnZzDmC,GmZyDnC,gBAAe7wC,EAAM,SAAN,cnZzDoB,GmZyDpB,cnZzDoB,IAqC/D,EAAK,cAAI,E,OEXjC,EFmBsF,GAR9D,EAAK,cACtB,E,OEZP,EFmBuE,G,QAPhE,EmZoBK,iBAAO,qBAAaA,EAAM,SAAO,oB,EAAa,mBACzC,kBAAO,qBnZTW,EAAM,SAiEgB,oBmZvDxC,InZPH,cA8D2C,qBmZvDjBA,EAAM,SAAO,oB,EAAa,kB,KnZxBlE,EAAW,EAoBf,GE9BkB,IAAd,KF8BJ,E,EE9BI,C,IAAK,EAAS,U,IFUd,EAAW,EAoBA,GE9BG,IAAd,KF8BW,E,EE9BX,C,IAAK,EAAS,U,MiZmC+B,4BnZ7D0C,GmZ6D1C,cnZ7D0C,GmZ6D1C,gBAAeA,EAAM,SAAN,cnZ7D2B,GmZ6D3B,cnZ7D2B,IAqC/D,EAAK,cAAI,E,OEXjC,EF8BW,GAnBa,EAAK,cACtB,E,OEZP,EF8BJ,G,EAlBW,C,QmZqB2DA,EAAM,SAG/D,OALL,IAAA6wC,GAAA,I,sCAOJ,GAEI,OAAO,IAAAA,GAAkB,cAAQl/B,E,yD5Q5Fy+C,kC6QsBr/C,O,EAAH,qC,6CAAA,M7QhFkE,uB,8DA0DsuD,uC6QgChyD,O,EAAH,0C,kDAAA,M7Q1F6D,uB,wC6QoGxF,oB,0CAAA,sB,6CASS,GACD,gBAAS,2BAAc5a,IACvB,gBAAS,oBACT,gBAAWwV,E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","sources":["webpack://birthcard-tessa/webpack/universalModuleDefinition","webpack://birthcard-tessa/../../../../src/main/kotlin/Main.kt","webpack://birthcard-tessa/../../../../src/main/kotlin/svg/Composition.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/common/src/generated/_Collections.kt","webpack://birthcard-tessa/../../../../src/main/kotlin/svg/Path.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/libraries/stdlib/js/src/org.w3c/org.w3c.dom.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/util/Preconditions.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/Collections.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/text/Strings.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/util/Standard.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/text/regex/RegexExtensions.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/text/stringJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/MutableCollections.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/js/math.polyfills.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/globalThis.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/math.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/ArrayBuffer.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/js.arrays/fill.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/js.arrays/sort.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/coroutines/CoroutineContext.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/common/src/generated/_Arrays.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/Sets.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collectionJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/common/src/generated/_Ranges.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/common/src/generated/_Sequences.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/common/src/generated/_Strings.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/common/src/kotlin/ExceptionsH.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/builtins/Char.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/dynamic.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/builtins/Enum.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/builtins/Library.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/BitMask.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/arrays.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/noPackageHacks.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/bitUtils.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/runtimeForStdLib.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/charSequenceJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/CharCode.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/collectionsHacks.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/compareTo.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/coreRuntime.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/hacks.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/kotlinHacks.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/kotlinJsHacks.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/long.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/longjs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/metadataUtils.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/numberConversion.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/UShort.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/rangeTo.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/reflectRuntime.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/typeCheckUtils.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/unlinked.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/src/generated/_ArraysJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/src/generated/_CollectionsJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/src/generated/_DigitChars.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/src/kotlin/coroutines_13/CoroutineImpl.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/src/kotlin/coroutines_13/IntrinsicsJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/src/kotlin/exceptions.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/src/kotlin/numbers_js-ir.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/src/kotlin/text/numberConversions_js-ir.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/core/builtins/src/kotlin/Annotations.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/core/builtins/src/kotlin/Unit.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/core/builtins/src/kotlin/annotation/Annotations.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/runtime/primitiveCompanionObjects.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/NumbersJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/annotationsJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/HashMap.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/Maps.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/AbstractMutableCollection.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/AbstractMutableList.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/AbstractMutableMap.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/AbstractMutableSet.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/ArrayFunctions.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/ArrayList.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/ArraySorting.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/InternalHashMap.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/HashMapEntry.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/HashMapEntryDefault.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/HashSet.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/LinkedHashMap.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/LinkedHashSet.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/console.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/coroutines/cancellation/CancellationException.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/coroutines/js/internal/EmptyContinuation.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/internalAnnotations.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/math.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/random/PlatformRandom.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/random/Random.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/random/XorWowRandom.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/reflect/KClassImpl.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/reflect/KTypeImpl.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/reflect/KTypeParameterImpl.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/reflect/primitives.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/reflect/reflection.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/regexp.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/sequenceJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/text/StringBuilderJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/text/charJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/src/generated/_WhitespaceChars.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/text/numberConversions.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/text/regex.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/src/generated/_ComparisonsJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/text/stringsCode.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/throwableExtensions.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/time/DurationUnitJs.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/annotations/OptIn.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/annotations/WasExperimental.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/AbstractIterator.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/AbstractList.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/AbstractMap.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/AbstractSet.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/ArrayDeque.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/IndexedValue.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/Iterables.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/Iterators.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/PrimitiveIterators.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/SequenceBuilder.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/Sequences.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/SlidingWindow.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/comparisons/Comparisons.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/coroutines/Continuation.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/coroutines/CoroutineContextImpl.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/coroutines/intrinsics/Intrinsics.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/enums/EnumEntries.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/internal/Annotations.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/internal/progressionUtil.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/io/encoding/Base64.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/ranges/PrimitiveRanges.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/ranges/ProgressionIterators.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/ranges/Progressions.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/ranges/Ranges.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/reflect/KTypeProjection.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/reflect/KVariance.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/text/Appendable.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/text/Char.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/text/Indent.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/text/StringNumberConversions.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/text/regex/MatchResult.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/time/Duration.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/text/StringBuilder.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/time/DurationUnit.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/util/Lazy.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/util/Result.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/util/Tuples.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/UByte.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/UByteArray.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/UInt.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/UIntArray.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/UIntRange.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/UProgressionUtil.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/ULong.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/UnsignedUtils.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/ULongArray.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/ULongRange.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/UShortArray.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/enums/EnumEntriesSerializationProxy.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/contracts/ContractBuilder.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/common/src/kotlin/JsAnnotationsH.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/core/builtins/src/kotlin/internal/InternalAnnotations.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/runtime/jsIntrinsics.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/core/builtins/native/kotlin/Number.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/util/HashCode.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/reflect/AssociatedObjects.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/annotations/ExperimentalStdlibApi.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/annotations/Inference.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/annotations/Multiplatform.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/AbstractCollection.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/experimental/inferenceMarker.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/io/encoding/Base64Js.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/io/encoding/ExperimentalEncodingApi.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/time/ExperimentalTime.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/unsigned/src/kotlin/annotations/Unsigned.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/collections/InternalMap.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/common/src/kotlin/MathH.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/js-ir/src/kotlin/reflection_js-ir.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/collections/MapWithDefault.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/common/src/generated/_Sets.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/coroutines/ContinuationInterceptor.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/jsMainSources/libraries/stdlib/js/src/kotlin/reflect/JsClass.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/commonMain/kotlin/io/github/oshai/kotlinlogging/KLogger.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/commonMain/kotlin/io/github/oshai/kotlinlogging/KLoggingEventBuilder.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/commonMain/kotlin/io/github/oshai/kotlinlogging/Level.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/commonMain/kotlin/io/github/oshai/kotlinlogging/internal/MessageInvoker.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/directMain/kotlin/io/github/oshai/kotlinlogging/Formatter.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/directMain/kotlin/io/github/oshai/kotlinlogging/KLoggingEvent.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/directMain/kotlin/io/github/oshai/kotlinlogging/internal/KLoggerDirect.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/jsMain/kotlin/io/github/oshai/kotlinlogging/ConsoleOutputAppender.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/jsMain/kotlin/io/github/oshai/kotlinlogging/KotlinLoggingConfiguration.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/commonMain/kotlin/io/github/oshai/kotlinlogging/KotlinLogging.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/directMain/kotlin/io/github/oshai/kotlinlogging/Appender.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/directMain/kotlin/io/github/oshai/kotlinlogging/KotlinLoggingLevel.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/directMain/kotlin/io/github/oshai/kotlinlogging/internal/KLoggerFactory.kt","webpack://birthcard-tessa/../../../../../../../../runner/work/kotlin-logging/kotlin-logging/src/jsMain/kotlin/io/github/oshai/kotlinlogging/internal/KLoggerNameResolver.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptor.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/PluginHelperInterfaces.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/Annotations.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/PolymorphicSerializer.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/descriptors/ContextAware.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/AbstractPolymorphicSerializer.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/SerializationExceptions.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/builtins/BuiltinSerializers.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptors.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/descriptors/SerialKinds.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/encoding/Decoding.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/BuiltInSerializers.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/CollectionDescriptors.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/CollectionSerializers.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/Enums.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/InlineClassDescriptor.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/NothingSerialDescriptor.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/NullableSerializer.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/ObjectSerializer.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/Platform.common.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/PluginGeneratedSerialDescriptor.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/PrimitiveArraysSerializers.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/Primitives.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/Tuples.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/ValueClasses.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/modules/SerializersModule.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/jsMain/src/kotlinx/serialization/SerializersJs.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/jsMain/src/kotlinx/serialization/internal/Platform.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/encoding/Encoding.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/common/src/generated/_UArrays.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/common/src/generated/_Maps.kt","webpack://birthcard-tessa/../../../../../../../../opt/buildAgent/work/b2fef8360e1bcf3d/core/commonMain/src/kotlinx/serialization/internal/PluginExceptions.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-animatable/src/commonMain/kotlin/org/openrndr/animatable/Animatable.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-animatable/src/commonMain/kotlin/org/openrndr/animatable/PropertyAnimationKey.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-animatable/src/commonMain/kotlin/org/openrndr/animatable/easing/Easer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-animatable/src/jsMain/kotlin/org/openrndr/animatable/Clock.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorInterfaces.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorATV.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorHSLa.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorHSVa.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorLABa.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorLCHABa.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorLCHUVa.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorLSHABa.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorLSHUVa.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorLUVa.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorRGBa.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorXSLa.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorXSVa.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-color/src/commonMain/kotlin/org/openrndr/color/ColorXYZ.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Functions.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/StyleParameters.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/ShadeStyle.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/StyleBufferBindings.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/StyleImageBindings.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/Batches.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/ColorBuffer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/ComputeStyle.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/Cubemap.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/DepthBuffer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/DrawContext.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/DrawStyle.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/Drawer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/DrawerConfiguration.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/Filter.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/FontMap.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/ImageBinding.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/IndexBuffer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/RenderTarget.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/Session.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/ShadeStyleManager.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/ShaderStorageBuffer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/UniformBlock.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/VertexBuffer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/VertexElementType.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/VertexFormat.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/font/BufferAccess.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/CircleDrawer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/Driver.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/Expansion.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/ExpansionDrawer.kt","webpack://birthcard-tessa/../../../../compileSync/js/main/developmentExecutable/kotlin/src/kotlin/util/FloorDivMod.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/FontImageMapDrawer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/ImageDrawer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/MeshLineDrawer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/PerformanceLineDrawer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/PointDrawer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/QualityLineDrawer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/QualityPolygonDrawer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/RectangleDrawer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/VertexBufferDrawer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/draw/FontMap.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/draw/ShadeStyleGLSL.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/draw/VertexBuffer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/internal/Driver.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/Shader.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/AtomicCounterBuffer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/draw/ComputeShader.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/draw/DrawContext.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/draw/useStyleBlock.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/commonMain/kotlin/org/openrndr/internal/FontMapManager.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/draw/ArrayTexture.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/draw/BufferTextureShadow.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/draw/BufferWriter.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/draw/ColorBuffer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/draw/IndexBuffer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-draw/src/jsMain/kotlin/org/openrndr/draw/ShaderWatcher.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-event/src/jsMain/kotlin/org/openrndr/events/Event.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Curve2.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Vec.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Bezier2.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Box.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Box2.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Box3.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Box4.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Interval.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Line2.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Matrix3.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Matrix4.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Operators.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Path2.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Polar2.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Region2.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Ring2.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Vec2.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Vec3.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/Vec4.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/utils/Combinatorics.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/utils/DoubleAccumulator.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/utils/Equations.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/utils/Intersections.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/utils/Scalars.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/utils/SweepQueue.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/utils/graphs/DirectedGraph.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/utils/regions/Arc.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/utils/regions/Clip.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/utils/regions/Split.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-kartifex/src/commonMain/kotlin/utils/Hashes.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/ActiveRegion.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/ArrayUtils.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/CachedVertex.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/Dict.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/DictNode.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/GLConstants.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/GLU.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/GLUHalfEdge.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/GLUTessellatorImpl.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/GLUface.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/GLUmesh.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/GLUvertex.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/Normal.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/Primitive.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/PriorityQ.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/PriorityQHeap.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/PriorityQSort.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/Render.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/Sweep.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/TessState.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/Tessellator.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/GLUtessellatorCallbackAdapter.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/Geom.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/Mesh.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/TessMono.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-ktessellation/src/commonMain/kotlin/GLUTessellator.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/EuclideanVector.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Equations.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Scalars.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/IntVector2.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/IntVector3.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/IntVector4.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Mapping.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Matrix33.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Matrix44.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Matrix55.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Polar.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Quaternion.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Spherical.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Vector2.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Vector3.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Vector4.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/transforms/TransformBuilder.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/transforms/Transforms.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-math/src/commonMain/kotlin/org/openrndr/math/Bezier.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-platform/src/commonMain/kotlin/platform/Platform.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-platform/src/jsMain/kotlin/platform/Platform.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/MovableScalable.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/Circle.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/IntRectangle.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/LineSegment.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/Path3D.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/Rectangle.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/Segment.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/Segment3D.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/Shape.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/ShapeArtifex.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/ShapeBuilder.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/ShapeContour.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/ShapeInfo.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/ShapeTools.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/Triangle.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/Triangulator.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/internal/BezierCubicSamplerT.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-shape/src/commonMain/kotlin/org/openrndr/shape/internal/BezierQuadraticSamplerT.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-utils/src/commonMain/kotlin/collections/PriorityQueue.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-utils/src/jsMain/kotlin/ResettableDelegate.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-utils/src/jsMain/kotlin/buffer/MPPBuffer.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-utils/src/commonMain/kotlin/collections/Stack.kt","webpack://birthcard-tessa/../../../../../openrndr/openrndr-utils/src/commonMain/kotlin/utils/ResettableDelegate.kt","webpack://birthcard-tessa/../../../../../orx/orx-color/src/commonMain/kotlin/phrases/Phrases.kt","webpack://birthcard-tessa/../../../../../orx/orx-color/src/commonMain/kotlin/spaces/ColorOKLABa.kt","webpack://birthcard-tessa/../../../../../orx/orx-color/src/commonMain/kotlin/spaces/ColorOKLCHa.kt","webpack://birthcard-tessa/../../../../../orx/orx-composition/src/commonMain/kotlin/Composition.kt","webpack://birthcard-tessa/../../../../../orx/orx-composition/src/commonMain/kotlin/CompositionStyleSheet.kt","webpack://birthcard-tessa/../../../../../orx/orx-shader-phrases/src/commonMain/kotlin/ShaderPreprocessor.kt","webpack://birthcard-tessa/../../../../../orx/orx-shader-phrases/src/jsMain/kotlin/ShaderPhraseBook.kt","webpack://birthcard-tessa/../../../../../orx/orx-shapes/src/commonMain/kotlin/bezierpatches/BezierPatch.kt","webpack://birthcard-tessa/../../../../../orx/orx-shapes/src/commonMain/kotlin/bezierpatches/BezierPatch3D.kt","webpack://birthcard-tessa/../../../../../orx/orx-shapes/src/commonMain/kotlin/bezierpatches/BezierPatchDrawer.kt","webpack://birthcard-tessa/../../../../../orx/orx-shapes/src/commonMain/kotlin/phrases/BezierPhraseBook.kt","webpack://birthcard-tessa/../../../../../orx/orx-shapes/src/commonMain/kotlin/rectify/RectifiedContour.kt","webpack://birthcard-tessa/../../../../../orx/orx-shapes/src/commonMain/kotlin/utilities/SplitAt.kt","webpack://birthcard-tessa/../../../../../orx/orx-shapes/src/commonMain/kotlin/utilities/WeldAscending.kt","webpack://birthcard-tessa/webpack/bootstrap","webpack://birthcard-tessa/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"birthcard-tessa\"] = factory();\n\telse\n\t\troot[\"birthcard-tessa\"] = factory();\n})(this, () => {\nreturn ","import kotlinx.browser.document\nimport kotlinx.browser.window\nimport org.openrndr.animatable.Animatable\nimport org.openrndr.animatable.easing.Easing\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.color.rgb\nimport org.openrndr.math.transforms.buildTransform\nimport org.openrndr.extra.shapes.rectify.rectified\nimport org.w3c.dom.svg.SVGElement\nimport org.w3c.dom.svg.SVGSVGElement\n\nfun main() {\n    val text = loadSVG(\"tessa.svg\")\n    val shapes = text.findShapes()\n    val rectified = shapes.map { it.shape.contours.map { c -> c.rectified() } }\n\n    val svg = document.getElementById(\"inner-svg\") as SVGElement\n    val outerSVG = document.getElementById(\"kotlin-svg\") as SVGSVGElement\n    fun patchSVG() {\n        if (window.innerWidth < window.window.innerHeight) {\n            outerSVG.setAttribute(\"preserveAspectRatio\", \"xMidYMid slice\")\n        } else {\n            if (outerSVG.attributes.getNamedItem(\"preserveAspectRatio\") != null) {\n                outerSVG.attributes.removeNamedItem(\"preserveAspectRatio\")\n            }\n        }\n    }\n    patchSVG()\n    window.addEventListener(\"resize\", {\n        patchSVG()\n    }, false)\n\n    class LetterAnimation : Animatable() {\n        var length = 0.05\n    }\n\n    val letterAnimations = List(5 * 10) { LetterAnimation() }\n\n    class Orchestrator : Animatable() {\n        var latch = 0.0\n        var mode = 0\n\n        fun update(timeInMs: Double) {\n            updateAnimation()\n            for (animation in letterAnimations) {\n                animation.updateAnimation()\n            }\n            if (!this.hasAnimations()) {\n                when (mode % 3) {\n                    0 -> {\n                        for ((index, anim) in letterAnimations.withIndex()) {\n                            anim.cancel()\n                            anim.apply {\n                                delay(index * 50L)\n                                ::length.animate(1.0, 1000, Easing.CubicInOut)\n                                ::length.complete()\n                                delay(2000)\n                                ::length.animate(0.05, 1000, Easing.CubicInOut)\n                            }\n                        }\n                    }\n                    1 -> {\n                        for (row in 0 until 10 step 2) {\n                            val anim = letterAnimations[row * 5 + row / 2]\n                            anim.cancel()\n                            anim.apply {\n                                delay(row * 250L)\n                                ::length.animate(1.0, 1500, Easing.CubicInOut)\n                                ::length.complete()\n                                delay(2000)\n                                ::length.animate(0.05, 1500, Easing.CubicInOut)\n                            }\n                        }\n                    }\n                    2 -> {\n                        for (row in 0 until 10 step 2) {\n                            for (shape in 0 until 5) {\n                                val anim = letterAnimations[row * 5 + shape]\n                                anim.cancel()\n                                anim.apply {\n                                    delay((9-row) * 250L)\n                                    ::length.animate(1.0, 1000, Easing.CubicInOut)\n                                    ::length.complete()\n                                    delay(2000)\n                                    ::length.animate(0.05, 1000, Easing.CubicInOut)\n                                }\n                            }\n                        }\n                    }\n                }\n                mode++\n                ::latch.animate(1.0, 5000)\n            }\n        }\n    }\n\n    val orchestrator = Orchestrator()\n\n    fun generate(millis: Double) {\n        val seconds = millis / 1000.0\n        svg.innerHTML = \"\"\n        orchestrator.update(millis)\n        buildComposition(svg) {\n            fill = null\n            stroke = rgb(\"dda9e1\")\n            strokeWeight = 2.0\n\n            for (i in 0 until 9) {\n                val b = buildTransform {\n                    translate(210.0, i * 75.0 + 30.0)\n                    scale(0.975)\n                }\n                for ((shapeIndex, shape) in rectified.withIndex()) {\n                    val animation = letterAnimations[i * 5 + shapeIndex]\n                    val skip = false\n                    if (!skip) {\n                        for (contour in shape) {\n                            val cutStart = seconds * 0.1 + i * 0.1 + shapeIndex * 0.2\n                            val cutEnd = seconds * 0.1 + animation.length + i * 0.1 + shapeIndex * 0.2\n                            strokeWeight = 3.0\n                            stroke =rgb (\"dda9e1\").mix(ColorRGBa.WHITE, i/15.0).opacify(0.95)\n                            fill = null\n                            contour(contour.sub(cutStart, cutEnd).transform(b).toSVG())\n                        }\n                    }\n                }\n            }\n        }\n        window.requestAnimationFrame { generate(it) }\n    }\n    generate(0.0)\n}","import kotlinx.browser.document\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.math.Vector2\nimport org.openrndr.shape.Shape\nimport org.openrndr.shape.ShapeContour\nimport org.w3c.css.masking.SVGClipPathElement\nimport org.w3c.dom.Element\nimport org.w3c.dom.get\nimport org.w3c.dom.svg.*\n\nval svgns = \"http://www.w3.org/2000/svg\"\n\npublic external abstract class SVGAnimateElement : Element {\n    fun beginElement()\n    fun beginElementAt(at: Double)\n}\n\npublic external abstract class SVGAnimateTransformElement : Element {\n    fun beginElement()\n    fun beginElementAt(at: Double)\n}\n\nfun ColorRGBa.toWeb(): String {\n    return \"rgba(${(r * 255).toInt()},${(g * 255).toInt()},${(b * 255).toInt()}, $a)\"\n}\n\nfun ShapeContour.toSVG():String {\n\n    val sb= StringBuilder()\n    if (this.empty) {\n        return \"\"\n    } else {\n\n        val first = segments.first().start\n        sb.append(\"M ${first.x} ${first.y}\")\n        segments.forEach {\n            when(it.control.size) {\n                0 -> sb.append(\"L ${it.end.x} ${it.end.y}\")\n                1 -> sb.append(\"Q ${it.control[0].x} ${it.control[0].y} ${it.end.x} ${it.end.y}\")\n                2 -> sb.append(\"C ${it.control[0].x} ${it.control[0].y} ${it.control[1].x} ${it.control[1].y} ${it.end.x} ${it.end.y}\")\n            }\n        }\n        if (closed) {\n            sb.append(\"Z\")\n        }\n        return sb.toString()\n    }\n\n}\n\n\n//\n//\n//class ContourBuilder {\n//    var path = \"\"\n//    var cursor = Vector2(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY)\n//    fun moveTo(v: Vector2) {\n//        path += \"M${v.x} ${v.y}\"\n//    }\n//\n//    fun lineTo(v: Vector2) {\n//        path += \"L${v.x} ${v.y}\"\n//    }\n//\n//    fun curveTo(c0: Vector2, c1: Vector2, v: Vector2) {\n//        path += \"C${c0.x} ${c0.y} ${c1.x} ${c1.y} ${v.x} ${v.y}\"\n//    }\n//\n//    fun curveTo(c: Vector2, v: Vector2) {\n//        path += \"Q${c.x} ${c.y} ${v.x} ${v.y}\"\n//    }\n//\n//    fun close() {\n//        path += \"Z\"\n//    }\n//\n//    private fun Boolean.toInt():Int {\n//        if (this) return 1 else return 0\n//    }\n//\n//    fun arcTo(rx: Double, ry:Double, rotation:Double, largeArc:Boolean, sweepFlag:Boolean, x:Double, y:Double) {\n//        path += \"A $rx $ry $rotation ${largeArc.toInt()} ${sweepFlag.toInt()} $x $y\"\n//    }\n//\n//\n//    fun build(): String {\n//        return path\n//    }\n//}\n\nsealed class Paint\n\nclass CompositionDrawer(val svg: SVGElement) {\n    var cursor = svg\n    var fill: Any? = ColorRGBa(1.0, 0.0, 0.0, 1.0)\n    var stroke: Any? = ColorRGBa(0.0, 0.0, 0.0, 1.0)\n    var strokeWeight = 1.0\n    private var uid = 0\n\n    private var defs: SVGDefsElement? = null\n        get() {\n            if (field == null) {\n                val newDefs = document.createElementNS(svgns, \"defs\") as SVGDefsElement\n                svg.appendChild(newDefs)\n                field = newDefs\n            }\n            return field\n        }\n\n    private fun setDrawAttributes(element: SVGElement) {\n        when (val f = fill) {\n            is ColorRGBa -> element.setAttribute(\"fill\", f.toWeb())\n//            is ColorOKLABa -> element.setAttribute(\"fill\", f.toRGBa().toWeb())\n//            is ColorOKLCHa -> element.setAttribute(\"fill\", f.toRGBa().toWeb())\n            is SVGGradientElement -> element.setAttribute(\"fill\", \"url('#${f.id}')\")\n            null -> element.setAttribute(\"fill\", \"none\")\n        }\n\n        when (val f = stroke) {\n            is ColorRGBa -> element.setAttribute(\"stroke\", f.toWeb())\n//            is ColorOKLABa -> element.setAttribute(\"stroke\", f.toRGBa().toWeb())\n//            is ColorOKLCHa -> element.setAttribute(\"stroke\", f.toRGBa().toWeb())\n            is SVGGradientElement -> element.setAttribute(\"stroke\", \"url('#${f.id}')\")\n            null -> element.setAttribute(\"stroke\", \"none\")\n        }\n\n        element.setAttribute(\"stroke-width\", strokeWeight.toString())\n        if (clip != null) {\n            element.setAttribute(\"clip-path\", \"url(#${clip?.id})\")\n        }\n    }\n\n    private var cursorStack = mutableListOf(cursor)\n    private var clipStack = mutableListOf<SVGClipPathElement?>(null)\n    private var clip: SVGClipPathElement? = null\n\n    class GradientBuilder(val gradient: SVGGradientElement) {\n//        fun stop(offset: Int, color: ColorOKLCHa) {\n//            stop(offset, color.toOKLABa())\n//        }\n//\n//        fun stop(offset: Int, color: ColorOKLABa) {\n//            stop(offset, color.toRGBa())\n//        }\n\n        fun stop(offset: Int, color: ColorRGBa) {\n            val stop = document.createElementNS(svgns, \"stop\") as SVGStopElement\n            stop.setAttribute(\"offset\", \"$offset%\")\n            stop.setAttribute(\"stop-color\", color.toWeb())\n            gradient.appendChild(stop)\n        }\n    }\n\n    fun defineLinearGradient(\n        x1: String, y1: String, x2: String, y2: String,\n        id: String = \"lg$uid\",\n        f: GradientBuilder.() -> Unit\n    ): SVGLinearGradientElement {\n        val grad = document.createElementNS(svgns, \"linearGradient\") as SVGLinearGradientElement\n\n        grad.setAttribute(\"x1\", x1)\n        grad.setAttribute(\"x2\", x2)\n        grad.setAttribute(\"y1\", y1)\n        grad.setAttribute(\"y2\", y2)\n        grad.id = id\n        uid++\n        val builder = GradientBuilder(grad)\n        builder.f()\n        defs?.appendChild(grad)\n        return grad\n    }\n\n    fun defineRadialGradient(\n        id: String = \"lg$uid\",\n        f: GradientBuilder.() -> Unit\n    ): SVGRadialGradientElement {\n        val grad = document.createElementNS(svgns, \"radialGradient\") as SVGRadialGradientElement\n\n        grad.id = id\n        uid++\n        val builder = GradientBuilder(grad)\n        builder.f()\n        defs?.appendChild(grad)\n        return grad\n    }\n\n\n    fun defineClipPath(id: String = \"clip$uid\", f: () -> Unit): SVGClipPathElement {\n        val clipPath = document.createElementNS(svgns, \"clipPath\") as SVGClipPathElement\n        clipPath.id = id\n        uid++\n        cursorStack.add(cursor)\n        cursor = clipPath\n        f()\n        cursor = cursorStack.removeLast()\n        defs?.appendChild(clipPath)\n        return clipPath\n    }\n\n    fun SVGClipPathElement.clip(f: () -> Unit) {\n        clipStack.add(clip)\n        clip = this\n        f()\n        clip = clipStack.removeLast()\n    }\n\n    fun SVGElement.animateRotation(\n        delay: Double,\n        duration: Double,\n        startDegrees: Double,\n        endDegrees: Double,\n        pivot: Vector2\n    ): SVGAnimateElement? {\n        val animate = document.createElementNS(svgns, \"animateTransform\") as SVGAnimateTransformElement\n        animate.setAttribute(\"attributeName\", \"transform\")\n        animate.setAttribute(\"attributeType\", \"XML\")\n        animate.setAttribute(\"type\", \"rotate\")\n        animate.setAttribute(\"from\", \"$startDegrees ${pivot.x} ${pivot.y}\")\n        animate.setAttribute(\"to\", \"$endDegrees ${pivot.x} ${pivot.y}\")\n        animate.setAttribute(\"dur\", \"${duration}s\")\n        animate.setAttribute(\"begin\", \"indefinite\")\n        console.log(animate)\n\n        animate.setAttribute(\"data-delay\", delay.toString())\n        this.appendChild(animate)\n        //return animate\n        return null\n    }\n\n    fun SVGElement.animate(\n        attribute: String, delay: Double, duration: Double,\n        values: List<Double>, keyTimes: List<Double>,\n        keySplines: List<List<Double>> = emptyList<List<Double>>(),\n\n        begin: String = \"indefinite\"\n    ): SVGAnimateElement {\n        val animate = document.createElementNS(svgns, \"animate\") as SVGAnimateElement\n        animate.setAttribute(\"attributeName\", attribute)\n\n//        val delayedValues = if (delay > 0.0) values.take(1) + values else values\n//        val delayedKeyTimes = if (delay > 0.0) listOf(0.0) + keyTimes.map {\n//            ((it * duration) + delay) / (delay + duration)\n//        } else keyTimes\n\n        animate.setAttribute(\"values\", values.joinToString(\";\"))\n        animate.setAttribute(\"keyTimes\", keyTimes.joinToString(\";\"))\n        animate.setAttribute(\"begin\", begin)\n        animate.setAttribute(\"dur\", \"${duration + delay}s\")\n        animate.setAttribute(\"fill\", \"freeze\")\n        animate.setAttribute(\"data-delay\", delay.toString())\n\n        if (keySplines.isNotEmpty()) {\n            animate.setAttribute(\"calcMode\", \"spline\")\n            animate.setAttribute(\"keySplines\", keySplines.joinToString(\";\") { it.joinToString(\" \") })\n        }\n        this.appendChild(animate)\n        return animate\n    }\n\n    fun text(text: String, anchor: String = \"middle\", position:Vector2, class_:String? = null ): SVGTextElement {\n        val textElement = document.createElementNS(svgns, \"text\") as SVGTextElement\n        textElement.setAttribute(\"x\", position.x.toString())\n        textElement.setAttribute(\"y\", position.y.toString())\n        textElement.setAttribute(\"text-anchor\", anchor)\n        class_?.let {\n            textElement.setAttribute(\"class\", it)\n\n        }\n        setDrawAttributes(textElement)\n        textElement.textContent = text\n        cursor.appendChild(textElement)\n        return textElement\n\n    }\n\n    fun group(clipPath: SVGClipPathElement? = null, f: () -> Unit) : SVGElement {\n        val group = document.createElementNS(svgns, \"g\") as SVGElement\n\n\n        cursorStack.add(cursor)\n        cursor = group\n        if (clipPath != null) {\n            group.setAttribute(\"clip-path\", \"url(#${clipPath.id})\")\n        }\n        f()\n        cursor = cursorStack.removeLast()\n        cursor.appendChild(group)\n        return group\n\n    }\n\n    fun circle(x: Double, y: Double, radius: Double): SVGCircleElement {\n        val circle = document.createElementNS(svgns, \"circle\") as SVGCircleElement\n        circle.setAttribute(\"cx\", x.toString())\n        circle.setAttribute(\"cy\", y.toString())\n        circle.setAttribute(\"r\", radius.toString())\n        setDrawAttributes(circle)\n        cursor.appendChild(circle)\n        return circle\n    }\n\n    fun rectangle(x: Double, y: Double, width: Double, height: Double): SVGRectElement {\n        val rect = document.createElementNS(svgns, \"rect\") as SVGRectElement\n        rect.setAttribute(\"x\", x.toString())\n        rect.setAttribute(\"y\", y.toString())\n        rect.setAttribute(\"width\", width.toString())\n        rect.setAttribute(\"height\", height.toString())\n        setDrawAttributes(rect)\n        cursor.appendChild(rect)\n        return rect\n    }\n\n    fun contour(path: String): SVGPathElement {\n        val pathElement = document.createElementNS(svgns, \"path\") as SVGPathElement\n        pathElement.setAttribute(\"d\", path)\n        setDrawAttributes(pathElement)\n        cursor.appendChild(pathElement)\n        return pathElement\n    }\n\n    fun shape(shape: Shape): SVGPathElement {\n        val pathElement = document.createElementNS(svgns, \"path\") as SVGPathElement\n        pathElement.setAttribute(\"d\",\n            shape.contours.joinToString(\" \") { it.toSVG() })\n        setDrawAttributes(pathElement)\n        cursor.appendChild(pathElement)\n        return pathElement\n    }\n}\n\nfun buildComposition(svg: SVGElement, f: CompositionDrawer.() -> Unit) {\n    val drawer = CompositionDrawer(svg)\n    drawer.f()\n}\n\n//fun buildContour(f: ContourBuilder.() -> Unit): String {\n//    val builder = ContourBuilder()\n//    builder.f()\n//    return builder.build()\n//}\n\nfun SVGElement.beginAnimation() {\n    val animations = this.getElementsByTagNameNS(svgns, \"animate\")\n    for (i in 0 until animations.length) {\n        val delay = animations.get(i)?.getAttribute(\"data-delay\")?.toDoubleOrNull() ?: 0.0\n\n        (animations.get(i) as SVGAnimateElement).beginElementAt(delay)\n    }\n\n    val transformAnimations = this.getElementsByTagNameNS(svgns, \"animateTransform\")\n    for (i in 0 until transformAnimations.length) {\n        val delay = transformAnimations.get(i)?.getAttribute(\"data-delay\")?.toDoubleOrNull() ?: 0.0\n        (transformAnimations.get(i) as SVGAnimateTransformElement).beginElementAt(delay)\n    }\n}",null,"import kotlinx.browser.document\nimport org.openrndr.extra.composition.Composition\nimport org.openrndr.extra.composition.CompositionNode\nimport org.openrndr.extra.composition.GroupNode\nimport org.openrndr.extra.composition.ShapeNode\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.YPolarity\nimport org.openrndr.shape.Segment\nimport org.openrndr.shape.Shape\nimport org.openrndr.shape.ShapeContour\nimport org.openrndr.shape.contour\n\nimport org.w3c.dom.get\nimport org.w3c.dom.svg.SVGElement\nimport org.w3c.dom.svg.SVGPathElement\nimport org.w3c.dom.svg.SVGSVGElement\nimport org.w3c.xhr.XMLHttpRequest\n\nfun loadSVG(url: String): Composition {\n    val svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\") as SVGSVGElement\n    var resultComposition: Composition? = null\n    val xhr = XMLHttpRequest()\n    xhr.open(\"GET\", url, false)\n    xhr.overrideMimeType(\"image/svg+xml\");\n    xhr.addEventListener(\"load\", {\n        xhr.responseXML?.documentElement?.attributes?.let {\n            for (i in 0 until it.length) {\n                val name = it[i]?.name ?: error(\"no name\")\n                val value = it[i]?.value ?: error(\"no value\")\n                svg.setAttribute(name, value)\n            }\n\n        }\n        svg.innerHTML = xhr.responseXML?.documentElement?.innerHTML ?: error(\"no svg data\")\n        val root = GroupNode()\n        val composition = Composition(root)\n        svg.toComposition(root)\n\n        resultComposition = composition\n    }, false)\n    xhr.send()\n    svg.remove()\n    return resultComposition ?: error(\"no composition\")\n}\n\nfun SVGElement.toComposition(node: CompositionNode) {\n    when (this.tagName) {\n        \"svg\", \"g\" -> {\n            val cg = GroupNode()\n            for (child in 0 until children.length) {\n                (children[child] as SVGElement).toComposition(cg)\n            }\n            (node as GroupNode).children.add(cg)\n        }\n        \"path\" -> {\n            val path = (this as SVGPathElement).getAttribute(\"d\") ?: error(\"no path\")\n            val shape = SVGPath.fromSVGPathString(path).shape()\n            val cs = ShapeNode(shape)\n            (node as GroupNode).children.add(cs)\n        }\n        else -> error(\"unsupported node\")\n    }\n}\n\ninternal fun Double.toBoolean() = this.toInt() == 1\ninternal class Command(val op: String, vararg val operands: Double) {\n    fun vector(i0: Int, i1: Int): Vector2 {\n        val x = if (i0 == -1) 0.0 else operands[i0]\n        val y = if (i1 == -1) 0.0 else operands[i1]\n        return Vector2(x, y)\n    }\n\n    fun vectors(): List<Vector2> = (0 until operands.size / 2).map { Vector2(operands[it * 2], operands[it * 2 + 1]) }\n}\n\ninternal class SVGPath {\n    val commands = mutableListOf<Command>()\n\n    companion object {\n        fun fromSVGPathString(svgPath: String): SVGPath {\n            val path = SVGPath()\n            val rawCommands = svgPath.split(\"(?=[MmZzLlHhVvCcSsQqTtAa])\".toRegex()).dropLastWhile { it.isEmpty() }\n            val numbers = Regex(\"[-+]?[0-9]*[.]?[0-9]+(?:[eE][-+]?[0-9]+)?\")\n            val arcOpReg = Regex(\"[aA]\")\n\n            for (rawCommand in rawCommands) {\n                if (rawCommand.isNotEmpty()) {\n                    // Special case for arcTo command where the \"numbers\" RegExp breaks\n                    if (arcOpReg.matches(rawCommand[0].toString())) {\n                        parseArcCommand(rawCommand.substring(1)).forEach {\n                            val operands = it.map { operand -> operand.toDouble() }\n                            path.commands.add(Command(rawCommand[0].toString(), *(operands.toDoubleArray())))\n                        }\n                    } else {\n                        val numberMatches = numbers.findAll(rawCommand)\n                        val operands = mutableListOf<Double>()\n                        for (i in numberMatches) {\n                            operands.add(i.value.toDouble())\n                        }\n                        path.commands.add(Command(rawCommand[0].toString(), *(operands.toDoubleArray())))\n                    }\n                }\n            }\n            return path\n        }\n    }\n\n    private fun compounds(): List<SVGPath> {\n        val compounds = mutableListOf<SVGPath>()\n        val compoundIndices = mutableListOf<Int>()\n\n        commands.forEachIndexed { index, it ->\n            if (it.op == \"M\" || it.op == \"m\") {\n                compoundIndices.add(index)\n            }\n        }\n\n        compoundIndices.forEachIndexed { index, _ ->\n            val cs = compoundIndices[index]\n            val ce = if (index + 1 < compoundIndices.size) (compoundIndices[index + 1]) else commands.size\n\n            val path = SVGPath()\n            path.commands.addAll(commands.subList(cs, ce))\n\n\n            compounds.add(path)\n        }\n        return compounds\n    }\n\n    fun shape(): Shape {\n        var cursor = Vector2(0.0, 0.0)\n        var anchor = cursor.copy()\n        var relativeControl = Vector2(0.0, 0.0)\n\n        val contours = compounds().map { compound ->\n            val segments = mutableListOf<Segment>()\n            var closed = false\n            compound.commands.forEach { command ->\n                when (command.op) {\n                    \"a\", \"A\" -> {\n                        command.operands.let {\n                            val rx = it[0]\n                            val ry = it[1]\n                            val xAxisRot = it[2]\n                            val largeArcFlag = it[3].toBoolean()\n                            val sweepFlag = it[4].toBoolean()\n\n                            var end = Vector2(it[5], it[6])\n\n                            if (command.op == \"a\") end += cursor\n\n                            val c = contour {\n                                moveTo(cursor)\n                                arcTo(rx, ry, xAxisRot, largeArcFlag, sweepFlag, end)\n                            }.segments\n\n                            segments += c\n                            cursor = end\n                        }\n                    }\n                    \"M\" -> {\n                        cursor = command.vector(0, 1)\n                        anchor = cursor\n\n                        val allPoints = command.vectors()\n\n                        for (i in 1 until allPoints.size) {\n                            val point = allPoints[i]\n                            segments += Segment(cursor, point)\n                            cursor = point\n                        }\n                    }\n                    \"m\" -> {\n                        val allPoints = command.vectors()\n                        cursor += command.vector(0, 1)\n                        anchor = cursor\n\n                        for (i in 1 until allPoints.size) {\n                            val point = allPoints[i]\n                            segments += Segment(cursor, cursor + point)\n                            cursor += point\n                        }\n                    }\n                    \"L\" -> {\n                        val allPoints = command.vectors()\n\n                        for (point in allPoints) {\n                            segments += Segment(cursor, point)\n                            cursor = point\n                        }\n                    }\n                    \"l\" -> {\n                        val allPoints = command.vectors()\n\n                        for (point in allPoints) {\n                            val target = cursor + point\n                            segments += Segment(cursor, target)\n                            cursor = target\n                        }\n                    }\n                    \"h\" -> {\n                        for (operand in command.operands) {\n                            val startCursor = cursor\n                            val target = startCursor + Vector2(operand, 0.0)\n                            segments += Segment(cursor, target)\n                            cursor = target\n                        }\n                    }\n                    \"H\" -> {\n                        for (operand in command.operands) {\n                            val target = Vector2(operand, cursor.y)\n                            segments += Segment(cursor, target)\n                            cursor = target\n                        }\n                    }\n                    \"v\" -> {\n                        for (operand in command.operands) {\n                            val target = cursor + Vector2(0.0, operand)\n                            segments += Segment(cursor, target)\n                            cursor = target\n                        }\n                    }\n                    \"V\" -> {\n                        for (operand in command.operands) {\n                            val target = Vector2(cursor.x, operand)\n                            segments += Segment(cursor, target)\n                            cursor = target\n                        }\n                    }\n                    \"C\" -> {\n                        val allPoints = command.vectors()\n                        allPoints.windowed(3, 3).forEach { points ->\n                            segments += Segment(cursor, points[0], points[1], points[2])\n                            cursor = points[2]\n                            relativeControl = points[1] - points[2]\n                        }\n                    }\n                    \"c\" -> {\n                        val allPoints = command.vectors()\n                        allPoints.windowed(3, 3).forEach { points ->\n                            segments += Segment(cursor, cursor + points[0], cursor + points[1], cursor.plus(points[2]))\n                            relativeControl = (cursor + points[1]) - (cursor + points[2])\n                            cursor += points[2]\n                        }\n                    }\n                    \"Q\" -> {\n                        val allPoints = command.vectors()\n                        if ((allPoints.size) % 2 != 0) {\n                            error(\"invalid number of operands for Q-op (operands=${allPoints.size})\")\n                        }\n                        for (c in 0 until allPoints.size / 2) {\n                            val points = allPoints.subList(c * 2, c * 2 + 2)\n                            segments += Segment(cursor, points[0], points[1])\n                            cursor = points[1]\n                            relativeControl = points[0] - points[1]\n                        }\n                    }\n                    \"q\" -> {\n                        val allPoints = command.vectors()\n                        if ((allPoints.size) % 2 != 0) {\n                            error(\"invalid number of operands for q-op (operands=${allPoints.size})\")\n                        }\n                        for (c in 0 until allPoints.size / 2) {\n                            val points = allPoints.subList(c * 2, c * 2 + 2)\n                            val target = cursor + points[1]\n                            segments += Segment(cursor, cursor + points[0], target)\n                            relativeControl = (cursor + points[0]) - (cursor + points[1])\n                            cursor = target\n                        }\n                    }\n                    \"s\" -> {\n                        val reflected = relativeControl * -1.0\n                        val cp0 = cursor + reflected\n                        val cp1 = cursor + command.vector(0, 1)\n                        val target = cursor + command.vector(2, 3)\n                        segments += Segment(cursor, cp0, cp1, target)\n                        cursor = target\n                        relativeControl = cp1 - target\n                    }\n                    \"S\" -> {\n                        val reflected = relativeControl * -1.0\n                        val cp0 = cursor + reflected\n                        val cp1 = command.vector(0, 1)\n                        val target = command.vector(2, 3)\n                        segments += Segment(cursor, cp0, cp1, target)\n                        cursor = target\n                        relativeControl = cp1 - target\n                    }\n                    \"Z\", \"z\" -> {\n                        if ((cursor - anchor).length >= 0.001) {\n                            segments += Segment(cursor, anchor)\n                        }\n                        closed = true\n                    }\n                    else -> {\n                        error(\"unsupported op: ${command.op}, is this a TinySVG 1.x document?\")\n                    }\n                }\n            }\n            ShapeContour(segments, closed, YPolarity.CW_NEGATIVE_Y)\n        }\n        return Shape(contours)\n    }\n\n}\n\ninternal fun parseArcCommand(p: String): List<List<String>> {\n    val sepReg = Regex(\",|\\\\s\")\n    val boolReg = Regex(\"[01]\")\n\n    var cursor = 0\n    var group = \"\"\n    val groups = mutableListOf<String>()\n    val commands = mutableListOf<List<String>>()\n\n    while (cursor <= p.lastIndex) {\n        val token = p[cursor].toString()\n        if (sepReg.matches(token)) {\n            if (group.isNotEmpty()) {\n                groups.add(group)\n            }\n            group = \"\"\n        } else {\n            group += token\n\n            if ((boolReg.matches(token) && (groups.size in 3..5)) || cursor == p.lastIndex) {\n                if (group.isNotEmpty()) {\n                    groups.add(group)\n                }\n\n                group = \"\"\n            }\n        }\n\n        if (groups.size == 7) {\n            commands.add(groups.toList())\n            groups.clear()\n            group = \"\"\n        }\n\n        cursor++\n    }\n\n    return commands\n}",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"package org.openrndr.animatable\n\nimport org.openrndr.animatable.easing.Easer\nimport org.openrndr.animatable.easing.Easing\nimport org.openrndr.events.Event\nimport org.openrndr.math.LinearType\nimport kotlin.jvm.JvmName\nimport kotlin.jvm.JvmOverloads\nimport kotlin.reflect.KMutableProperty\nimport kotlin.reflect.KMutableProperty0\n\n/*\nCopyright (c) 2012, Edwin Jakobs\nCopyright (c) 2013, Edwin Jakobs\nCopyright (c) 2020, Edwin Jakobs\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nprivate val globalAnimator by lazy { Animatable() }\n\nenum class AnimationState {\n    Queued,\n    Playing,\n    Stopped\n}\n\n@Suppress(\"unused\", \"MemberVisibilityCanBePrivate\")\nopen class Animatable {\n\n    /**\n     * create an animation group\n     * @param builder the animation group builder function\n     */\n    @JvmName(\"animateUnitProperty\")\n    fun KMutableProperty0<Unit>.animationGroup(builder: (Animatable.() -> Unit)): PropertyAnimationKey<Unit> {\n        pushTime()\n        val before = propertyAnimationKeys.map { it }\n        this@Animatable.builder()\n        val added = propertyAnimationKeys subtract before.toSet()\n\n        val groupDurationInNs = added.maxByOrNull { it.endInNs }?.let {\n            it.endInNs - createAtTimeInNs\n        } ?: 0L\n        val uak = UnitAnimationKey(this, Unit, groupDurationInNs, createAtTimeInNs)\n        uak.cancelled.listen {\n            for (key in added) {\n                key.cancelled.trigger(AnimationEvent())\n            }\n            this@Animatable.propertyAnimationKeys.removeAll(added)\n        }\n        propertyAnimationKeys.add(uak)\n        popTime()\n        return uak\n    }\n\n    /**\n     * animate [Double] property\n     * @param targetValue the target animation value\n     * @param durationInMs animation duration in milliseconds\n     * @param easing the easing to use during the animation, default is [Easing.None]\n     * @param predelayInMs time to wait in milliseconds before the animation starts\n     */\n    @JvmName(\"animateProp\")\n    fun KMutableProperty0<Double>.animate(targetValue: Double, durationInMs: Long, easing: Easing = Easing.None, predelayInMs: Long = 0): PropertyAnimationKey<Double> {\n        return animate(this, targetValue, durationInMs, easing, predelayInMs)\n    }\n\n    /**\n     * animate [LinearType] property\n     * @param targetValue the target animation value\n     * @param durationInMs animation duration in milliseconds\n     * @param easing the easing to use during the animation, default is [Easing.None]\n     * @param predelayInMs time to wait in milliseconds before the animation starts\n     */\n    @JvmName(\"animatePropLinearType\")\n    fun <T : LinearType<T>> KMutableProperty0<T>.animate(targetValue: T, durationInMs: Long, easing: Easing = Easing.None, predelayInMs: Long = 0): PropertyAnimationKey<T> {\n        return animate(this, targetValue, durationInMs, easing, predelayInMs)\n    }\n\n    internal fun MutableList<PropertyAnimationKey<*>>.cancel(property: KMutableProperty<*>) {\n        val toCancel = filter { it.property == property }\n        for (key in toCancel) {\n            key.cancelled.trigger(AnimationEvent())\n        }\n        removeAll(toCancel)\n    }\n\n    /**\n     * cancel all animation groups on [Unit] property\n     */\n    @JvmName(\"cancelUnitProperty\")\n    fun KMutableProperty0<Unit>.cancel() = propertyAnimationKeys.cancel(this)\n\n    /**\n     * cancel all animations on [Double] property\n     */\n    @JvmName(\"cancelDoubleProperty\")\n    fun KMutableProperty0<Double>.cancel() = propertyAnimationKeys.cancel(this)\n\n    /**\n     * cancel all animations on [LinearType] property\n     */\n    @JvmName(\"cancelLinearTypeProperty\")\n    fun <T : LinearType<T>> KMutableProperty0<T>.cancel() = propertyAnimationKeys.cancel(this)\n\n\n    @JvmName(\"completeUnitProperty\")\n    fun KMutableProperty0<Unit>.complete() {\n        propertyAnimationKeys.findLast { it.property == this }?.let {\n            createAtTimeInNs = it.startInNs + it.durationInNs\n        }\n    }\n\n    @JvmName(\"completeDoubleProperty\")\n    fun KMutableProperty0<Double>.complete() {\n        propertyAnimationKeys.findLast { it.property == this }?.let {\n            createAtTimeInNs = it.startInNs + it.durationInNs\n        }\n    }\n\n    @JvmName(\"completeLinearTypeProperty\")\n    fun <T : LinearType<T>> KMutableProperty0<T>.complete() {\n        propertyAnimationKeys.findLast { it.property == this }?.let {\n            createAtTimeInNs = it.startInNs + it.durationInNs\n        }\n    }\n\n    /**\n     * the last queued or active animation group for [Unit] property, or null if no animations are available\n     */\n    @Suppress(\"UNCHECKED_CAST\")\n    val KMutableProperty0<Unit>.last: PropertyAnimationKey<Unit>?\n        @JvmName(\"lastUnitProperty\")\n        get() = propertyAnimationKeys.findLast { it.property == this } as PropertyAnimationKey<Unit>?\n\n    /**\n     * the last queued or active animation for [LinearType] property, or null if no animations are available\n     */\n    @Suppress(\"UNCHECKED_CAST\")\n    val <T : LinearType<T>> KMutableProperty0<T>.last: PropertyAnimationKey<T>?\n        @JvmName(\"lastLinearTypeProperty\")\n        get() = propertyAnimationKeys.findLast { it.property == this } as PropertyAnimationKey<T>?\n\n    /**\n     * the last queued or active animation for [Double] property, or null if no animations are available\n     */\n    @Suppress(\"UNCHECKED_CAST\")\n    val KMutableProperty0<Double>.last: PropertyAnimationKey<Double>?\n        @JvmName(\"lastDoubleProperty\")\n        get() = propertyAnimationKeys.findLast { it.property == this } as PropertyAnimationKey<Double>?\n\n    /**\n     * check if [Unit] property has queued or active animation groups\n     */\n    val KMutableProperty0<Unit>.hasAnimations\n        @JvmName(\"hasAnimationsUnitProperty\")\n        get() = propertyAnimationKeys.find { it.property == this } != null\n\n    /**\n     * check if [Double] property has queued or active animation groups\n     */\n    val KMutableProperty0<Double>.hasAnimations\n        @JvmName(\"hasAnimationsDoubleProperty\")\n        get() = propertyAnimationKeys.find { it.property == this } != null\n\n    /**\n     * check if [LinearType] property has queued or active animation groups\n     */\n    val <T : LinearType<T>>  KMutableProperty0<T>.hasAnimations\n        @JvmName(\"hasAnimationsLinearTypeProperty\")\n        get() = propertyAnimationKeys.find { it.property == this } != null\n\n    internal fun <T> List<PropertyAnimationKey<*>>.durationInMs(property: KMutableProperty0<T>) =\n            filter { it.property == property }.maxByOrNull { it.endInNs }?.let {\n                (it.endInNs - lastTimeInNs) / 1000L\n            } ?: 0L\n\n    /**\n     * remaining duration of queued and activate animation groups for [Unit] property\n     */\n    val KMutableProperty0<Unit>.durationInMs: Long\n        @JvmName(\"durationInMsUnit\")\n        get() = propertyAnimationKeys.durationInMs(this)\n\n    /**\n     * remaining duration of queued and active animations for [Double] property\n     */\n    val KMutableProperty0<Double>.durationInMs: Long\n        @JvmName(\"durationInMsDouble\")\n        get() = propertyAnimationKeys.durationInMs(this)\n\n    /**\n     * remaining duration of queued and active animations for [LinearType] property\n     */\n    val <T : LinearType<T>> KMutableProperty0<T>.durationInMs: Long\n        @JvmName(\"durationInMsLinearTypeProperty\")\n        get() = propertyAnimationKeys.durationInMs(this)\n\n    /**\n     * the time at which created animations will start\n     */\n    var createAtTimeInNs: Long = clock.timeNanos\n        private set\n\n    internal var lastTimeInNs = createAtTimeInNs\n\n    private var propertyAnimationKeys: MutableList<PropertyAnimationKey<*>> = mutableListOf()\n\n    private var stage: String? = null\n\n    private var timeStack: ArrayDeque<Long>? = null\n\n    private var animatable: Any? = null\n\n\n    constructor() {\n        // animationKeys!!.ensureCapacity(10)\n        animatable = this\n    }\n\n    constructor(createAtTime: Long) {\n        this.createAtTimeInNs = createAtTime\n        //animationKeys!!.ensureCapacity(10)\n        animatable = this\n    }\n\n    fun pushTime() {\n        if (timeStack == null) {\n            timeStack = ArrayDeque()\n        }\n        timeStack!!.addLast(createAtTimeInNs)\n    }\n\n    fun popTime() {\n        createAtTimeInNs = timeStack!!.removeLastOrNull() ?: error(\"stack underflow\")\n    }\n\n    /**\n     * Wait for a given time before cueing the next animation.\n     * @param delayInMs the delay in milliseconds\n     * @return `this` for easy animation chaining\n     */\n    fun delay(delayInMs: Long, delayInNs: Long = 0) {\n        createAtTimeInNs += delayInMs * 1_000 + delayInNs\n    }\n\n    /**\n     * Wait until the given timeMillis\n     * @param timeInMs the timeMillis in milliseconds\n     * @return `this` for easy animation chaining\n     */\n    fun waitUntil(timeInMs: Long, timeInNs: Long = 0) {\n        createAtTimeInNs = timeInMs * 1_000 + timeInNs\n    }\n\n    /**\n     * Queries if animations are cued.\n     * @return `true` iff animations are cued.\n     */\n    fun hasAnimations(): Boolean {\n        return propertyAnimationKeys.size != 0\n    }\n\n    /**\n     * Cancels all animations.\n     * @return `this` for easy animation chaining\n     */\n    fun cancel() {\n        propertyAnimationKeys.clear()\n        createAtTimeInNs = lastTimeInNs\n    }\n\n    private fun getFieldValue(variable: KMutableProperty0<Any>): Double {\n        when (val g = variable.get()) {\n            is Double -> return g.toDouble()\n        }\n        return 0.0\n    }\n\n    private fun blend(easing: Easer, dt: Double, from: Double, delta: Double): Double {\n        return easing.ease(dt, from, delta, 1.0)\n    }\n\n    /**\n     * Updates the animation state with a user supplied time\n     * @param timeInNs the time to use for updating the animation state\n     */\n    @JvmOverloads\n    fun updateAnimation(timeInNs: Long = clock.timeNanos) {\n        lastTimeInNs = timeInNs\n        createAtTimeInNs = lastTimeInNs\n        updatePropertyAnimations(timeInNs)\n    }\n\n    private fun updatePropertyAnimations(timeInNs: Long = clock.timeNanos) {\n        val toRemove = mutableListOf<PropertyAnimationKey<*>>()\n        val triggers = mutableListOf<Event<AnimationEvent>>()\n\n        for (key in propertyAnimationKeys.map { it }) {\n            if (key.startInNs <= timeInNs) { // && key.start + key.duration >= time) {\n                if (key.animationState == AnimationState.Queued) {\n                    key.play()\n                }\n\n                if (key.animationState == AnimationState.Playing) {\n                    var dt = (timeInNs - key.startInNs).toDouble()\n\n                    if (key.durationInNs > 0) {\n                        dt /= key.durationInNs\n                    } else {\n                        dt = 1.0\n                    }\n\n                    if (dt < 0)\n                        dt = 0.0\n                    if (dt >= 1) {\n                        dt = 1.0\n                        key.stop()\n                    }\n                    key.applyToProperty(dt)\n                }\n                if (key.animationState == AnimationState.Stopped) {\n                    triggers.add(key.completed)\n                    toRemove.add(key)\n                }\n            }\n        }\n        for (event in triggers) {\n            event.trigger(AnimationEvent())\n        }\n\n        for (key in toRemove) {\n            propertyAnimationKeys.remove(key)\n        }\n\n        lastTimeInNs = timeInNs\n\n        if (lastTimeInNs > createAtTimeInNs) {\n            createAtTimeInNs = lastTimeInNs\n        }\n    }\n\n    /**\n     * Returns the number of playing plus queued animations\n     * @return number of playing plus queued animations\n     */\n    fun animationCount(): Int {\n        return propertyAnimationKeys.size\n    }\n\n    companion object {\n        internal var clock: Clock = DefaultClock()\n\n        /**\n         * Globally sets the clock object to use. The default is a `DefaultClock` instance\n         * @param clock a `a Clock instance`\n         */\n        fun clock(clock: Clock) {\n            Animatable.clock = clock\n        }\n\n        /**\n         * Returns the global clock object\n         * @return this\n         */\n        fun clock(): Clock {\n            return clock\n        }\n\n        fun array(variable: String, index: Int): String {\n            return \"$variable[$index]\"\n        }\n    }\n\n    fun <T : LinearType<T>> animate(variable: KMutableProperty0<T>, target: T, durationMillis: Long,\n                                    easing: Easing = Easing.None, predelayInMs: Long = 0): PropertyAnimationKey<T> {\n        val key = LinearTypeAnimationKey(variable, target, durationMillis * 1000, createAtTimeInNs + predelayInMs * 1000, easing)\n        propertyAnimationKeys.add(key)\n        return key\n    }\n\n    fun animate(variable: KMutableProperty0<Double>, target: Double, durationMillis: Long,\n                easing: Easing = Easing.None, predelayInMs: Long = 0): PropertyAnimationKey<Double> {\n        val key = DoubleAnimationKey(variable, target, durationMillis * 1000, createAtTimeInNs + predelayInMs * 1000, easing)\n        propertyAnimationKeys.add(key)\n        return key\n    }\n}\n","package org.openrndr.animatable\n\nimport org.openrndr.animatable.easing.Easing\nimport org.openrndr.events.Event\nimport org.openrndr.math.LinearType\nimport kotlin.reflect.KMutableProperty0\n\nclass AnimationEvent()\n\nabstract class PropertyAnimationKey<T>(\n        open val property: KMutableProperty0<T>,\n        open val targetValue: T,\n        val durationInNs: Long,\n        val startInNs: Long,\n        val easing: Easing\n) {\n    /**\n     * animation cancelled event\n     */\n    val cancelled = Event<AnimationEvent>()\n\n    /**\n     * animation completed event\n     */\n    val completed = Event<AnimationEvent>()\n\n    internal open var startValue: T? = null\n\n    /**\n     * end time in nanoseconds of the animation\n     */\n    val endInNs get() = (startInNs + durationInNs)\n\n    var animationState = AnimationState.Queued\n        private set\n\n    internal fun play() {\n        if (animationState != AnimationState.Playing) {\n            this.startValue = property.get()\n            animationState = AnimationState.Playing\n        }\n    }\n\n    internal fun stop() {\n        animationState = AnimationState.Stopped\n    }\n\n    internal abstract fun applyToProperty(t: Double)\n}\n\ninternal class LinearTypeAnimationKey<T : LinearType<T>>(\n        override val property: KMutableProperty0<T>,\n        override val targetValue: T,\n        durationInNs: Long,\n        startInNs: Long,\n        easing: Easing\n) : PropertyAnimationKey<T>(property, targetValue, durationInNs, startInNs, easing) {\n    override var startValue: T? = null\n\n    override fun applyToProperty(t: Double) {\n        val et = easing.easer.ease(t, 0.0, 1.0, 1.0)\n        property.set(startValue!! * (1.0 - et) + targetValue * et)\n    }\n}\n\ninternal class DoubleAnimationKey(\n        override val property: KMutableProperty0<Double>,\n        override val targetValue: Double,\n        duration: Long,\n        start: Long,\n        easing: Easing\n) : PropertyAnimationKey<Double>(property, targetValue, duration, start, easing) {\n    override var startValue: Double? = null\n\n    override fun applyToProperty(t: Double) {\n        val et = easing.easer.ease(t, 0.0, 1.0, 1.0)\n        property.set(startValue!! * (1.0 - et) + targetValue * et)\n    }\n}\n\ninternal class UnitAnimationKey(\n        override val property: KMutableProperty0<Unit>,\n        override val targetValue: Unit,\n        duration: Long,\n        start: Long,\n) : PropertyAnimationKey<Unit>(property, targetValue, duration, start, Easing.None) {\n    override var startValue: Unit? = null\n\n    override fun applyToProperty(t: Double) {\n\n    }\n}","package org.openrndr.animatable.easing\n\nimport kotlin.math.*\n\ninterface Easer {\n    fun velocity(t: Double, b: Double, c: Double, d: Double): Double\n    fun ease(t: Double, b: Double, c: Double, d: Double): Double\n}\n\nenum class Easing(val easer: Easer) {\n    None(Linear()),\n    SineIn(SineIn()),\n    SineOut(SineOut()),\n    SineInOut(SineInOut()),\n    CubicIn(CubicIn()),\n    CubicOut(CubicOut()),\n    CubicInOut(CubicInOut()),\n    QuadIn(QuadIn()),\n    QuadOut(QuadOut()),\n    QuadInOut(QuadInOut()),\n    QuartIn(QuartIn()),\n    QuartOut(QuartOut()),\n    QuartInOut(QuartInOut())\n}\n\nclass Linear : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double = c / d\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double = b + c * (t / d)\n}\n\n@Suppress(\"unused\")\nclass BackIn : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double {\n        return c * t * (8.10474 * t - 3.40316 * d) / (d * d * d)\n    }\n\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double {\n        val s = 1.70158\n        val td = t / d\n        return c * (td) * td * ((s + 1) * td - s) + b\n    }\n}\n\n@Suppress(\"unused\")\nclass ExpoIn : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double {\n        return if (t == 0.0) {\n            0.0\n        } else {\n            c * ln(32.0) * 2.0.pow(10 * t / d - 9) / d\n        }\n    }\n\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double =\n        if (t == 0.0) b else c * 2.0.pow(10 * (t / d - 1)) + b\n}\n\nclass SineOut : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double = PI * c * cos(PI * t) / (2 * d) / (2 * d)\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double = c * sin(t / d * (PI / 2)) + b\n}\n\nclass SineIn : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double =\n        -PI * c * sin(PI * t / (2 * d)) / (2 * d)\n\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double = -c * cos(t / d * (PI / 2)) + c + b\n}\n\nclass SineInOut : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double = PI * c * sin(PI * t) / d / (2 * d)\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double = -c / 2 * (cos(PI * t / d) - 1) + b\n}\n\nclass CubicIn : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double = 3.0 * c * t * t / (d * d * d)\n\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double {\n        val td = t / d\n        return c * td * td * td + b\n    }\n}\n\nclass CubicOut : Easer {\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double {\n        val td = t / d - 1.0\n        return c * (td * td * td + 1) + b\n    }\n\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double {\n        return 3.0 * c * (d - t) * (d - t) / (d * d * d)\n    }\n}\n\nclass CubicInOut : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double {\n        return if (t / (d / 2) < 1) {\n            12.0 * c * t * t / (d * d * d)\n        } else {\n            12 * c * (d - t) * (d - t) / (d * d * d)\n        }\n    }\n\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double {\n        val td = t / (d / 2)\n        val td2 = td - 2.0\n        return if (td < 1) c / 2 * td * td * td + b else c / 2 * (td2 * td2 * td2 + 2) + b\n    }\n}\n\nclass QuadIn : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double = 2.0 * c * t / (d * d)\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double = c * (t / d) * (t / d) + b\n}\n\nclass QuadOut : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double {\n        return -2.0 * c * (d - t) / (d * d)\n    }\n\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double {\n        return -c * (t / d) * (t / d - 2) + b\n    }\n}\n\nclass QuadInOut : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double {\n        return if (t / (d / 2) < 1) {\n            4.0 * c * t / (d * d)\n        } else {\n            4.0 * c * (d - t) / (d * d)\n        }\n    }\n\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double {\n        val td = t / (d / 2)\n        return if (td < 1) {\n            c / 2 * td * td + b\n        } else {\n            -c / 2 * ((td - 1) * (td - 3) - 1) + b\n        }\n    }\n}\n\nclass QuartIn : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double {\n        return 4.0 * c * (t * t * t) / (d * d * d * d)\n    }\n\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double {\n        val n = t / d\n        return c * n * n * n * n + b\n    }\n}\n\nclass QuartOut : Easer {\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double {\n        val td = t / d - 1\n        return -c * (td * td * td * td - 1) + b\n    }\n\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double {\n        return (4.0 * c * (d - t) * (d - t) * (d - t)) / (d * d * d * d)\n    }\n}\n\nclass QuartInOut : Easer {\n    override fun velocity(t: Double, b: Double, c: Double, d: Double): Double {\n        return if (t / (d / 2) < 1) {\n            32.0 * c * t * t * t / (d * d * d * d)\n        } else {\n            32.0 * c * (d - t) * (d - t) * (d - t) / (d * d * d * d)\n        }\n    }\n\n    override fun ease(t: Double, b: Double, c: Double, d: Double): Double {\n        val td = t / (d / 2)\n        val td2 = td - 2.0\n\n        return if (td < 1) c / 2 * td * td * td * td + b else -c / 2 * (td2 * td2 * td2 * td2 - 2) + b\n    }\n}","package org.openrndr.animatable\n\nimport kotlinx.browser.window\n\nactual class DefaultClock : Clock {\n    override val timeNanos: Long get() = (window.performance.now() * 1000).toLong()\n    override val time: Long get() = timeNanos / 1000\n}","package org.openrndr.color\n\nimport org.openrndr.math.CastableToVector4\nimport org.openrndr.math.LinearType\nimport org.openrndr.math.mixAngle\n\ninterface ConvertibleToColorRGBa {\n    /** Convert into [ColorRGBa]. */\n    fun toRGBa(): ColorRGBa\n}\n\ninterface ShadableColor<T> {\n    /** Multiply the shade by a factor. */\n    fun shade(factor: Double): T\n}\n\ninterface LuminosityColor<T> {\n    fun withLuminosity(luminosity: Double): T\n\n    val luminosity: Double\n    fun shadeLuminosity(factor: Double) = withLuminosity(factor * luminosity)\n\n    fun mixLuminosity(luminosity: Double, factor: Double) =\n        withLuminosity(this.luminosity * (1.0 - factor) + luminosity * factor)\n}\n\n\ninterface HueShiftableColor<T> {\n    /**\n     * Shift the hue of a color by the given amount of degrees.\n     * @param shiftInDegrees the hue shift in degrees\n     */\n    fun shiftHue(shiftInDegrees: Double): T = withHue(hue + shiftInDegrees)\n\n    fun withHue(hue: Double): T\n\n    val hue: Double\n\n    fun mixHue(hue: Double, factor: Double): T = withHue(mixAngle(this.hue, hue, factor))\n}\n\ninterface ChromaColor<T> {\n    fun withChroma(chroma: Double): T\n\n    val chroma: Double\n\n    fun shiftChroma(shift: Double) = withChroma(chroma + shift)\n\n    fun modulateChroma(factor: Double) = withChroma(chroma * factor)\n\n    fun mixChroma(target: Double, factor: Double) = withChroma(chroma * (1.0 - factor) + target * factor)\n}\n\n\ninterface SaturatableColor<T> {\n    /** Multiply the saturation by a factor. */\n    fun saturate(factor: Double): T = withSaturation(saturation * factor)\n\n    fun withSaturation(saturation: Double): T\n\n    val saturation: Double\n\n    fun mixSaturation(saturation: Double, factor: Double): T =\n        withSaturation(this.saturation * (1.0 - factor) + saturation * factor)\n}\n\ninterface OpacifiableColor<T> {\n    /** The opacity of the given color model. */\n    val alpha: Double\n\n    /**\n     * Returns a copy of the color with the opacity ([alpha]) multiplied by a factor.\n     * @param factor a scaling factor used for the opacity\n     */\n    fun opacify(factor: Double): T\n}\n\ninterface ReferenceWhitePoint {\n    /** The reference white point against which the color is calculated. */\n    val ref: ColorXYZa\n}\n\ninterface ColorModel<T : ColorModel<T>> : OpacifiableColor<T>, ConvertibleToColorRGBa, CastableToVector4\n\n/**\n * Allows performing select algebraic operations on colors of this kind.\n */\ninterface AlgebraicColor<T : AlgebraicColor<T>> : LinearType<T> {\n    override operator fun div(scale: Double): T = times(1.0 / scale)\n    fun mix(other: T, factor: Double): T =\n        ((this * (1.0 - factor)) as AlgebraicColor<T>) + (other as AlgebraicColor<T> * factor)\n}","@file:Suppress(\"DEPRECATION\")\n\npackage org.openrndr.color\n\nimport kotlin.math.pow\n\n@Deprecated(\"Used solely by the also-deprecated ColorATVa.\")\ndata class Hue(\n    val name: Int,\n    val lambda: Double,\n    val angle: Double,\n    val xbl: Double,\n    val ybl: Double,\n    val zbl: Double,\n    val xl: Double,\n    val yl: Double,\n    val sl: Double\n)\n\nval hues = listOf(\n    Hue(10, 570.83, 59.00, 0.7757450, 0.9465720, 0.0020320, 0.4498700, 0.5489500, 1.7243490),\n    Hue(11, 572.64, 55.3, 0.8051300, 0.9338040, 0.0019100, 0.4624800, 0.5364100, 1.7408450),\n    Hue(12, 574.38, 51.7, 0.8327820, 0.9203950, 0.0018080, 0.4745100, 0.5244400, 1.7549860),\n    Hue(13, 576.06, 48.2, 0.8588410, 0.9064820, 0.0017640, 0.4860100, 0.5129800, 1.7670880),\n    Hue(14, 577.5, 44.8, 0.8804880, 0.8937410, 0.0017240, 0.4957800, 0.5032500, 1.7759530),\n    Hue(15, 579.31, 41.5, 0.9066520, 0.8767490, 0.0016720, 0.5079000, 0.4905200, 1.7850740),\n    Hue(16, 580.95, 38.2, 0.9291240, 0.8603680, 0.0016120, 0.5187400, 0.4803500, 1.7911040),\n    Hue(20, 582.65, 34.9, 0.9509090, 0.8423910, 0.0015310, 0.5298000, 0.4693400, 1.7948310),\n    Hue(21, 584.46, 31.5, 0.9724540, 0.8247790, 0.0014310, 0.5413700, 0.4578300, 1.7986650),\n    Hue(22, 586.43, 28.00, 0.9937530, 0.7997580, 0.0013080, 0.5536700, 0.4455900, 1.7948220),\n    Hue(23, 588.59, 24.4, 1.0143500, 0.7740900, 0.0011700, 0.5668000, 0.4325300, 1.7896100),\n    Hue(24, 591.06, 20.6, 1.0344020, 0.7740140, 0.0010670, 0.5812800, 0.4181100, 1.7794840),\n    Hue(25, 594.00, 16.6, 1.0524660, 0.7074960, 0.0010210, 0.5976600, 0.4017600, 1.7609840),\n    Hue(26, 597.74, 12.3, 1.0625440, 0.6600010, 0.0008980, 0.6165300, 0.3830000, 1.7234440),\n    Hue(30, 602.72, 7.7, 1.0561250, 0.5960700, 0.0006960, 0.6389600, 0.3606100, 1.6528920),\n    Hue(31, 610.14, 2.8, 1.0010270, 0.5012450, 0.0003350, 0.6661900, 0.3335800, 1.5026080),\n    Hue(32, 625.00, -2.5, 0.7514000, 0.3210000, 0.0001000, 0.7006100, 0.2993000, 1.0725000),\n    Hue(33, -492.79, -8.4, 0.7266030, 0.3040930, 0.1059410, 0.6392500, 0.2675300, 1.1366380),\n    Hue(34, -495.28, -19.8, 0.6896200, 0.2788860, 0.2637800, 0.5396200, 0.2263100, 1.2322860),\n    Hue(35, -498.45, -31.6, 0.6595230, 0.2583730, 0.3922240, 0.5034000, 0.1972100, 1.3101220),\n    Hue(40, -502.69, 43.2, 0.6338150, 0.2408510, 0.5019440, 0.4604100, 0.1749500, 1.3766100),\n    Hue(41, -509.12, 54.6, 0.6098100, 0.2244900, 0.6043920, 0.4238600, 0.1560300, 1.4386920),\n    Hue(42, -520.4, 65.8, 0.5854920, 0.2079150, 0.7081750, 0.3899100, 0.1384600, 1.5015830),\n    Hue(43, -536.31, 76.8, 0.5588650, 0.1897670, 0.8218150, 0.3558600, 0.1208300, 1.5704470),\n    Hue(44, -548.11, 86.8, 0.5298110, 0.1699650, 0.9458070, 0.3219500, 0.1032800, 1.6455840),\n    Hue(45, -555.96, 95.8, 0.4963640, 0.1471680, 1.0885510, 0.2865700, 0.0849600, 1.7320850),\n    Hue(46, -564.18, -108.4, 0.4253460, 0.0987640, 1.3916430, 0.2220200, 0.0515500, 1.9157540),\n    Hue(50, 450.00, -117.2, 0.3362000, 0.0380000, 1.7721100, 0.1566400, 0.0177100, 2.1463100),\n    Hue(51, 468.71, -124.7, 0.2101740, 0.0861980, 1.3535670, 0.1273600, 0.0522700, 1.6499400),\n    Hue(52, 475.44, -131.8, 0.1377340, 0.1147700, 1.0209110, 0.1081300, 0.0902000, 1.2734150),\n    Hue(53, 479.00, -138.5, 0.1017870, 0.1350670, 0.8439550, 0.0941400, 0.1250600, 1.0808090),\n    Hue(54, 482.04, -145.1, 0.0790040, 0.1507090, 0.7278630, 0.0824900, 0.1574100, 0.9575770),\n    Hue(55, 484.29, -152.00, 0.0626580, 0.1646260, 0.6416920, 0.0720600, 0.1895800, 0.8689770),\n    Hue(56, 487.31, -163.4, 0.0446910, 0.1859490, 0.5410910, 0.0578700, 0.2410900, 0.7717320),\n    Hue(60, 490.4, -177.2, 0.0303720, 0.2116590, 0.4550770, 0.0435300, 0.3037800, 0.6971100),\n    Hue(61, 492.72, 171.6, 0.0216550, 0.2340220, 0.4001260, 0.0329100, 0.3569600, 0.6558040),\n    Hue(62, 495.28, 125.4, 0.0139890, 0.2618430, 0.3481360, 0.0224000, 0.4197100, 0.6239690),\n    Hue(63, 498.45, 148.4, 0.0072150, 0.3011370, 0.2876850, 0.0119600, 0.4995400, 0.5960370),\n    Hue(64, 502.69, 136.8, 0.0025860, 0.3664250, 0.2384020, 0.0042500, 0.6032100, 0.6074140),\n    Hue(65, 509.12, 125.4, 0.0072600, 0.4853460, 0.1673170, 0.0109900, 0.7354200, 0.6599240),\n    Hue(66, 520.4, 114.2, 0.0660100, 0.7172740, 0.0762330, 0.0805000, 0.8339100, 0.8595230),\n    Hue(70, 536.31, 103.2, 0.2422720, 0.9263250, 0.0270860, 0.2025900, 0.7747400, 1.1956840),\n    Hue(71, 548.11, 93.2, 0.4066630, 0.9905870, 0.0102840, 0.2880700, 0.7046000, 1.4100970),\n    Hue(72, 555.96, 84.2, 0.5276460, 0.9998620, 0.0053210, 0.3442200, 0.6523000, 1.5328300),\n    Hue(73, 560.74, 77.3, 0.6068730, 0.9932240, 0.0036950, 0.3783800, 0.6193000, 1.6037930),\n    Hue(74, 564.18, 71.6, 0.6645990, 0.9819810, 0.0028680, 0.4029000, 0.5953300, 1.6494490),\n    Hue(75, 566.78, 66.9, 0.7083580, 0.9702520, 0.0024700, 0.4214100, 0.5771600, 1.6810810),\n    Hue(76, 568.92, 62.8, 0.7441820, 0.9585920, 0.0022050, 0.4364700, 0.5622200, 1.7049810)\n)\n\nfun findHue(id: Int): Hue? = hues.find { it.name == id }\n\n/**\n * The little-known [Coloroid color space](https://en.wikipedia.org/wiki/Coloroid).\n * There is a color atlas of [hues], but their source has not been digitized.\n */\n@Deprecated(\"Largely unknown format with a practically unverifiable list of colors.\")\n@Suppress(\"MemberVisibilityCanBePrivate\", \"unused\")\ndata class ColorATVa(val id: Int, val t: Double, val v: Double, val alpha: Double = 1.0) {\n\n    companion object {\n        fun maxT(id: Int, v: Double): Double {\n            var left = 0.0\n            var right = 200.0\n            var bestGuess = left\n            while (true) {\n\n                if (right - left < 0.0001) {\n                    return bestGuess\n                }\n\n                val leftTry = ColorATVa(id, left, v, 1.0)\n                val rightTry = ColorATVa(id, right, v, 1.0)\n                val middle = (left + right) / 2\n                val middleTry = ColorATVa(id, middle, v, 1.0)\n\n                val leftValid = leftTry.toRGBa().let { it.minValue >= 0 && it.maxValue <= 1.0 }\n                val rightValid = rightTry.toRGBa().let { it.minValue >= 0 && it.maxValue <= 1.0 }\n                val middleValid = middleTry.toRGBa().let { it.minValue >= 0 && it.maxValue <= 1.0 }\n\n                if (leftValid && middleValid && !rightValid) {\n                    val newLeft = middle\n                    val newRight = right\n                    bestGuess = middle\n                    left = newLeft\n                    right = newRight\n                }\n\n                if (leftValid && !middleValid && !rightValid) {\n                    val newLeft = left\n                    val newRight = middle\n                    left = newLeft\n                    right = newRight\n                }\n\n                if (!leftValid && middleValid && rightValid) {\n                    val newLeft = left\n\n                    left = newLeft\n                    right = middle\n                }\n\n                if (leftValid == middleValid && middleValid == rightValid) {\n                    return bestGuess\n                }\n            }\n        }\n    }\n\n    fun toColorYxya(): ColorYxya {\n        val hue = findHue(id)\n        return hue?.let {\n            val sigmaW = 3.162955\n            val x0 = 0.312726\n            val yy = (v / 10.0).pow(2.0) / 100.0\n            val ybl = hue.ybl * 100.0\n\n            val x = (sigmaW * x0 * (v * v - t * ybl) + 100 * t * hue.sl * hue.xl) /\n                    (sigmaW * (v * v - t * ybl) + 100 * t * hue.sl)\n\n            val y = (v * v + 100 * t * hue.sl * hue.yl - t * ybl) /\n                    (sigmaW * (v * v - t * ybl) + 100 * t * hue.sl)\n\n            ColorYxya(yy, x, y)\n        } ?: ColorYxya(0.0, 0.0, 0.0, 0.0)\n    }\n\n    fun toRGBa(): ColorRGBa = toColorYxya().toXYZa().toRGBa()\n}","package org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Vector4\nimport org.openrndr.math.mixAngle\nimport kotlin.jvm.JvmOverloads\n\n/**\n * The [HSL color space](https://en.wikipedia.org/wiki/HSL_and_HSV).\n *\n * @see ColorHSVa\n *\n * @param h hue in degrees, where a full rotation is 360.0 degrees\n * @param s saturation as a percentage between 0.0 and 1.0\n * @param l lightness/luminance as a percentage between 0.0 and 1.0\n * @param alpha alpha as a percentage between 0.0 and 1.0\n */\n@Suppress(\"unused\", \"MemberVisibilityCanBePrivate\")\n@Serializable\ndata class ColorHSLa @JvmOverloads constructor (val h: Double, val s: Double, val l: Double, override val alpha: Double = 1.0) :\n        ColorModel<ColorHSLa>,\n        ShadableColor<ColorHSLa>,\n        HueShiftableColor<ColorHSLa>,\n        SaturatableColor<ColorHSLa>,\n        AlgebraicColor<ColorHSLa> {\n\n    companion object {\n        fun fromRGBa(rgb: ColorRGBa): ColorHSLa {\n            val srgb = rgb.toSRGB()\n            val min = srgb.minValue\n\n            val max: Double\n            val maxArg: ColorRGBa.Component\n\n            if (srgb.r >= srgb.b && srgb.r >= srgb.g) {\n                maxArg = ColorRGBa.Component.R\n                max = srgb.r\n            } else if (srgb.g >= srgb.b && srgb.g >= srgb.r) {\n                maxArg = ColorRGBa.Component.G\n                max = srgb.g\n            } else {\n                maxArg = ColorRGBa.Component.B\n                max = srgb.b\n            }\n\n            // In the case r == g == b\n            if (min == max) {\n                return ColorHSLa(0.0, 0.0, max, srgb.alpha)\n            }\n            val delta = max - min\n            val l = (max + min) / 2.0\n            val s = if (l > 0.5) delta / (2.0 - max - min) else delta / (max + min)\n            val h = 60.0 * when (maxArg) {\n                ColorRGBa.Component.R -> (srgb.g - srgb.b) / delta + if (srgb.g < srgb.b) 6 else 0\n                ColorRGBa.Component.G -> (srgb.b - srgb.r) / delta + 2.0\n                ColorRGBa.Component.B -> (srgb.r - srgb.g) / delta + 4.0\n            }\n            return ColorHSLa(h, s, l, srgb.alpha)\n        }\n    }\n\n    @Deprecated(\"Legacy alpha parameter name\", ReplaceWith(\"alpha\"))\n    val a = alpha\n\n    override fun opacify(factor: Double): ColorHSLa = copy(alpha = alpha * factor)\n\n    override fun withHue(hue: Double) = copy(h = hue)\n\n    override val hue: Double\n        get() = h\n\n    override fun withSaturation(saturation: Double): ColorHSLa = copy(s = saturation)\n    override val saturation: Double\n        get() = s\n\n    override fun shade(factor: Double) = copy(l = l * factor)\n\n    override fun mix(other: ColorHSLa, factor: Double) = mix(this, other, factor)\n\n    val unit get() = copy(h = ((h % 360) + 360) % 360)\n\n    override fun toRGBa(): ColorRGBa {\n        return if (s == 0.0) {\n            ColorRGBa(l, l, l, alpha, Linearity.SRGB)\n        } else {\n            val q = if (l < 0.5) l * (1 + s) else l + s - l * s\n            val p = 2 * l - q\n            val r = hue2rgb(p, q, h / 360.0 + 1.0 / 3)\n            val g = hue2rgb(p, q, h / 360.0)\n            val b = hue2rgb(p, q, h / 360.0 - 1.0 / 3)\n            ColorRGBa(r, g, b, alpha, Linearity.SRGB)\n        }\n    }\n\n    fun toHSVa(): ColorHSVa = toRGBa().toHSVa()\n    fun toXYZa(): ColorXYZa = toRGBa().toXYZa()\n    fun toLABa(ref: ColorXYZa = ColorXYZa.NEUTRAL) = toRGBa().toXYZa().toLABa(ref)\n    fun toLUVa(ref: ColorXYZa = ColorXYZa.NEUTRAL) = toRGBa().toXYZa().toLUVa(ref)\n    fun toLCHABa(ref: ColorXYZa = ColorXYZa.NEUTRAL) = toLABa(ref).toLCHABa()\n    fun toLCHUVa(ref: ColorXYZa = ColorXYZa.NEUTRAL) = toLUVa(ref).toLCHUVa()\n\n    /**\n     * convert to [ColorXSLa]\n     */\n    fun toXSLa() = ColorXSLa.fromHSLa(this)\n    override fun plus(right: ColorHSLa) = copy(\n        h = h + right.h,\n        s = s + right.s,\n        l = l + right.l,\n        alpha = alpha + right.alpha\n    )\n    override fun minus(right: ColorHSLa) = copy(\n        h = h - right.h,\n        s = s - right.s,\n        l = l - right.l,\n        alpha = alpha - right.alpha\n    )\n    override fun times(scale: Double) = copy(h = h * scale, s = s * scale, l = l * scale, alpha = alpha * scale)\n\n    override fun toVector4(): Vector4 = Vector4(h, s, l, alpha)\n}\n\ninternal fun hue2rgb(p: Double, q: Double, ut: Double): Double {\n    var t = ut\n    while (t < 0) t += 1.0\n    while (t > 1) t -= 1.0\n    if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t\n    if (t < 1.0 / 2.0) return q\n    return if (t < 2.0 / 3.0) p + (q - p) * (2.0 / 3.0 - t) * 6.0 else p\n}\n\nfun hsl(h: Double, s: Double, l: Double, a: Double = 1.0) = ColorHSLa(h, s, l, a)\n\n@Deprecated(\"Use hsl(h, s, l, a)\", ReplaceWith(\"hsl(h, s, l, a)\"), DeprecationLevel.WARNING)\nfun hsla(h: Double, s: Double, l: Double, a: Double) = ColorHSLa(h, s, l, a)\n\n/**\n * Weighted mix between two colors in the HSL color space.\n * @param left the left-hand ColorHSLa to mix\n * @param right the right-hand ColorHSLa to mix\n * @param x the weighting of colors, a value 0.0 is equivalent to [left],\n * 1.0 is equivalent to [right] and at 0.5 both colors contribute to the result equally\n * @return a mix of [left] and [right] weighted by [x]\n */\nfun mix(left: ColorHSLa, right: ColorHSLa, x: Double): ColorHSLa {\n    val sx = x.coerceIn(0.0, 1.0)\n    return ColorHSLa(\n            mixAngle(left.h, right.h, sx),\n            (1.0 - sx) * left.s + sx * right.s,\n            (1.0 - sx) * left.l + sx * right.l,\n        (1.0 - sx) * left.alpha + sx * right.alpha\n    )\n}\n","@file:Suppress(\"unused\")\n\npackage org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Vector4\nimport org.openrndr.math.mixAngle\nimport org.openrndr.math.mod\nimport kotlin.jvm.JvmOverloads\nimport kotlin.math.floor\n\n\n/**\n * The [HSV color space](https://en.wikipedia.org/wiki/HSL_and_HSV).\n *\n * @see ColorHSLa\n *\n * @param h hue in degrees, where a full rotation is 360.0 degrees\n * @param s saturation as a percentage between 0.0 and 1.0\n * @param v value/brightness as a percentage between 0.0 and 1.0\n * @param alpha alpha as a percentage between 0.0 and 1.0\n */\n@Suppress(\"unused\")\n@Serializable\ndata class ColorHSVa @JvmOverloads constructor (val h: Double, val s: Double, val v: Double, override val alpha: Double = 1.0) :\n        ColorModel<ColorHSVa>,\n        ShadableColor<ColorHSVa>,\n        HueShiftableColor<ColorHSVa>,\n        SaturatableColor<ColorHSVa>,\n        AlgebraicColor<ColorHSVa> {\n\n    companion object {\n        fun fromRGBa(rgb: ColorRGBa): ColorHSVa {\n            val srgb = rgb.toSRGB()\n            val min = srgb.minValue\n\n            val max: Double\n            val maxArg: ColorRGBa.Component\n\n            if (srgb.r >= srgb.b && srgb.r >= srgb.g) {\n                maxArg = ColorRGBa.Component.R\n                max = srgb.r\n            } else if (srgb.g >= srgb.b && srgb.g >= srgb.r) {\n                maxArg = ColorRGBa.Component.G\n                max = srgb.g\n            } else {\n                maxArg = ColorRGBa.Component.B\n                max = srgb.b\n            }\n\n            val v = max\n            // In the case r == g == b\n            if (min == max) {\n                return ColorHSVa(0.0, 0.0, v, srgb.alpha)\n            }\n            val delta = max - min\n            val s = delta / max\n            var h = 60 * when (maxArg) {\n                ColorRGBa.Component.R -> (srgb.g - srgb.b) / delta // between yellow & magenta\n                ColorRGBa.Component.G -> (srgb.b - srgb.r) / delta + 2.0 // between cyan & yellow\n                ColorRGBa.Component.B -> (srgb.r - srgb.g) / delta + 4.0 // between magenta & cyan\n            }\n            if (h < 0) {\n                h += 360.0\n            }\n            return ColorHSVa(h, s, v, srgb.alpha)\n        }\n    }\n\n    @Deprecated(\"Legacy alpha parameter name\", ReplaceWith(\"alpha\"))\n    val a = alpha\n\n    override fun opacify(factor: Double): ColorHSVa = copy(alpha = alpha * factor)\n    override fun withHue(hue: Double) = copy(h = hue)\n\n    override val hue: Double\n        get() = h\n\n    override fun withSaturation(saturation: Double): ColorHSVa = copy(s = saturation)\n\n    override val saturation: Double\n        get() = s\n\n    override fun shade(factor: Double): ColorHSVa = copy(v = v * factor)\n\n    override fun mix(other: ColorHSVa, factor: Double) = mix(this, other, factor)\n\n    /**\n     * a unit presentation of this ColorHSVa, essentially brings the hue back in [0, 360)\n     * @return a copy with the hue value in [0, 360)\n     */\n    val unit get() = copy(h = ((h % 360) + 360) % 360)\n\n    override fun toRGBa(): ColorRGBa {\n        val i: Int\n        val f: Double\n\n        val r: Double\n        val g: Double\n        val b: Double\n        val hsv = this\n\n        val sh = mod(hsv.h, 360.0) / 60            // sector 0 to 5\n        i = floor(sh).toInt()\n        f = sh - i            // factorial part of h\n        val p = hsv.v * (1 - hsv.s)\n        val q = hsv.v * (1 - hsv.s * f)\n        val t = hsv.v * (1 - hsv.s * (1 - f))\n        if (s > 0.00001) {\n            when (i) {\n                0 -> {\n                    r = hsv.v\n                    g = t\n                    b = p\n                }\n                1 -> {\n                    r = q\n                    g = hsv.v\n                    b = p\n                }\n                2 -> {\n                    r = p\n                    g = hsv.v\n                    b = t\n                }\n                3 -> {\n                    r = p\n                    g = q\n                    b = hsv.v\n                }\n                4 -> {\n                    r = t\n                    g = p\n                    b = hsv.v\n                }\n                else        // case 5:\n                -> {\n                    r = hsv.v\n                    g = p\n                    b = q\n                }\n            }\n        } else {\n            r = hsv.v\n            g = hsv.v\n            b = hsv.v\n        }\n        return ColorRGBa(r, g, b, hsv.alpha, Linearity.SRGB)\n\n    }\n\n    override fun plus(right: ColorHSVa) = copy(\n        h = h + right.h,\n        s = s + right.s,\n        v = v + right.v,\n        alpha = alpha + right.alpha\n    )\n    override fun minus(right: ColorHSVa) = copy(\n        h = h - right.h,\n        s = s - right.s,\n        v = v - right.v,\n        alpha = alpha - right.alpha\n    )\n    override fun times(scale: Double) = copy(h = h * scale, s = s * scale, v = v * scale, alpha = alpha * scale)\n\n    override fun toVector4(): Vector4 = Vector4(h, s, v, alpha)\n\n    fun toXSVa(): ColorXSVa {\n        return ColorXSVa.fromHSVa(this)\n    }\n}\n\nfun hsv(h: Double, s: Double, v: Double, a: Double = 1.0) = ColorHSVa(h, s, v, a)\n\n@Deprecated(\"Use hsv(h, s, v, a)\", ReplaceWith(\"hsv(h, s, v, a)\"), DeprecationLevel.WARNING)\nfun hsva(h: Double, s: Double, v: Double, a: Double) = ColorHSVa(h, s, v, a)\n\n/**\n * Weighted mix between two colors in the HSVa color space.\n * @param left the left-hand ColorHSVa to mix\n * @param right the right-hand ColorHSVa to mix\n * @param x the weighting of colors, a value 0.0 is equivalent to [left],\n * 1.0 is equivalent to [right] and at 0.5 both colors contribute to the result equally\n * @return a mix of [left] and [right] weighted by [x]\n */\nfun mix(left: ColorHSVa, right: ColorHSVa, x: Double): ColorHSVa {\n    val sx = x.coerceIn(0.0, 1.0)\n    return ColorHSVa(\n            mixAngle(left.h, right.h, sx),\n            (1.0 - sx) * left.s + sx * right.s,\n            (1.0 - sx) * left.v + sx * right.v,\n        (1.0 - sx) * left.alpha + sx * right.alpha\n    )\n}\n","package org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Vector4\nimport kotlin.jvm.JvmOverloads\nimport kotlin.math.pow\n\n/**\n * The [CIELAB color space](https://en.wikipedia.org/wiki/CIELAB_color_space),\n * more commonly known as Lab.\n *\n * @param l lightness, between 0.0 (black) and 100.0 (white)\n * @param a unbounded a* axis, relative to the green–red opponent colors,\n *          with negative values toward green and positive values toward red\n * @param b unbounded b* axis, relative to the blue–yellow opponent colors,\n *          with negative values toward blue and positive values toward yellow\n * @param alpha alpha as a percentage between 0.0 and 1.0\n * @param ref reference white against which the color values are calculated\n */\n@Serializable\ndata class ColorLABa @JvmOverloads constructor (\n    val l: Double,\n    val a: Double,\n    val b: Double,\n    override val alpha: Double = 1.0,\n    override val ref: ColorXYZa = ColorXYZa.NEUTRAL\n) :\n    ColorModel<ColorLABa>,\n    ReferenceWhitePoint,\n    ShadableColor<ColorLABa>,\n    LuminosityColor<ColorLABa>,\n    AlgebraicColor<ColorLABa> {\n\n    companion object {\n        // https://web.archive.org/web/20191228145700/http://eilv.cie.co.at/term/157\n        fun fromXYZa(xyz: ColorXYZa, ref: ColorXYZa): ColorLABa {\n            val x = xyz.x / ref.x\n            val y = xyz.y / ref.y\n            val z = xyz.z / ref.z\n\n            val l = 116 * f(y) - 16.0\n            val a = 500 * (f(x) - f(y))\n            val b = 200 * (f(y) - f(z))\n\n            return ColorLABa(l, a, b, xyz.alpha, ref)\n        }\n\n        fun fromRGBa(rgba: ColorRGBa, ref: ColorXYZa = ColorXYZa.NEUTRAL) =\n            fromXYZa(ColorXYZa.fromRGBa(rgba), ref)\n    }\n\n    fun toXYZa(): ColorXYZa {\n        var x: Double\n        var y: Double\n        var z: Double\n\n        val lab = this\n\n        val fy = (lab.l + 16.0) / 116.0\n        val fx = lab.a / 500.0 + fy\n        val fz = fy - lab.b / 200.0\n\n        x = if (fx * fx * fx > 0.008856) {\n            fx * fx * fx\n        } else {\n            (116 * fx - 16) / 903.3\n        }\n\n        y = if (lab.l > 903.3 * 0.008856) {\n            ((lab.l + 16) / 116.0).pow(3.0)\n        } else {\n            lab.l / 903.3\n        }\n\n        z = if (fz * fz * fz > 0.008856) {\n            fz * fz * fz\n        } else {\n            (116.0 * fz - 16.0) / 903.3\n        }\n\n        x *= ref.x\n        y *= ref.y\n        z *= ref.z\n        return ColorXYZa(x, y, z, alpha)\n    }\n\n    fun toLCHABa() = ColorLCHABa.fromLABa(this)\n    fun toLSHABa() = toLCHABa().toLSHABa()\n    fun toLUVa() = toXYZa().toLUVa(ref)\n    override fun toRGBa() = toXYZa().toRGBa()\n    fun toHSVa() = toXYZa().toRGBa().toHSVa()\n    fun toHSLa() = toXYZa().toRGBa().toHSLa()\n\n    override fun opacify(factor: Double) = copy(alpha = alpha * factor)\n    override fun shade(factor: Double) = copy(l = l * factor)\n\n    override fun plus(right: ColorLABa) =\n        copy(l = l + right.l, a = a + right.a, b = b + right.b, alpha = alpha + right.alpha)\n\n    override fun minus(right: ColorLABa) =\n        copy(l = l - right.l, a = a - right.a, b = b - right.b, alpha = alpha - right.alpha)\n\n    override fun times(scale: Double): ColorLABa =\n        copy(l = l * scale, a = a * scale, b = b * scale, alpha = alpha * scale)\n\n    override fun toVector4() = Vector4(l, a, b, alpha)\n    override fun withLuminosity(luminosity: Double): ColorLABa = copy(l = luminosity)\n\n    override val luminosity: Double\n        get() = l\n}\n\nprivate fun f(t: Double): Double {\n    return if (t > 0.008856) {\n        t.pow(1.0 / 3.0)\n    } else {\n        (903.3 * t + 16.0) / 116.0\n    }\n}\n","package org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.*\nimport kotlin.jvm.JvmOverloads\nimport kotlin.math.*\n\n/**\n * The [CIELChAB color space](https://en.wikipedia.org/wiki/CIELAB_color_space#Cylindrical_model)\n * is the cylindrical representation of the CIELAB color space.\n *\n * @param l luminance, in a range of 0.0 (darkest) to 100.0 (brightest)\n * @param c chroma\n * @param h hue in degrees, where a full rotation is 360.0 degrees\n * @param alpha alpha as a percentage between 0.0 and 1.0\n * @param ref reference white against which the color values are calculated\n *\n * @see ColorLABa\n */\n@Serializable\ndata class ColorLCHABa @JvmOverloads constructor (\n    val l: Double,\n    val c: Double,\n    val h: Double,\n    override val alpha: Double = 1.0,\n    override val ref: ColorXYZa = ColorXYZa.NEUTRAL\n) :\n    ColorModel<ColorLCHABa>,\n    ReferenceWhitePoint,\n    ShadableColor<ColorLCHABa>,\n    ChromaColor<ColorLCHABa>,\n    HueShiftableColor<ColorLCHABa>,\n    LuminosityColor<ColorLCHABa>,\n    AlgebraicColor<ColorLCHABa> {\n    companion object {\n        fun findMaxChroma(l: Double, h: Double, ref: ColorXYZa): Double {\n            var left = 0.0\n            var right = 2000.0\n            var bestGuess = left\n            while (true) {\n\n                if (right - left < 0.0001) {\n                    return bestGuess\n                }\n\n                val leftTry = ColorLCHABa(l, left, h, 1.0, ref)\n                val rightTry = ColorLCHABa(l, right, h, 1.0, ref)\n                val middle = (left + right) / 2\n                val middleTry = ColorLCHABa(l, middle, h, 1.0, ref)\n\n                val leftValid = leftTry.toRGBa().let { it.minValue >= 0 && it.maxValue <= 1.0 }\n                val rightValid = rightTry.toRGBa().let { it.minValue >= 0 && it.maxValue <= 1.0 }\n                val middleValid = middleTry.toRGBa().let { it.minValue >= 0 && it.maxValue <= 1.0 }\n\n                if (leftValid && middleValid && !rightValid) {\n                    val newLeft = middle\n                    val newRight = right\n                    bestGuess = middle\n                    left = newLeft\n                    right = newRight\n                }\n\n                if (leftValid && !middleValid && !rightValid) {\n                    val newLeft = left\n                    val newRight = middle\n                    left = newLeft\n                    right = newRight\n                }\n\n                if (leftValid == middleValid && middleValid == rightValid) {\n                    return bestGuess\n                }\n            }\n        }\n\n\n        fun fromLABa(laba: ColorLABa): ColorLCHABa {\n            val l = laba.l\n            val c = sqrt(laba.a * laba.a + laba.b * laba.b)\n            var h = atan2(laba.b, laba.a)\n\n            if (h < 0) {\n                h += PI * 2\n            }\n\n            h = h.asDegrees\n\n            return ColorLCHABa(l, c, h, laba.alpha, laba.ref)\n        }\n    }\n\n\n    fun toLABa(): ColorLABa {\n        val a = c * cos(h.asRadians)\n        val b = c * sin(h.asRadians)\n        return ColorLABa(l, a, b, alpha, ref)\n    }\n\n    fun toXYZa(): ColorXYZa = toLABa().toXYZa()\n\n    override fun toRGBa(): ColorRGBa = toLABa().toXYZa().toRGBa()\n\n    fun toLSHABa() = ColorLSHABa.fromLCHABa(this)\n\n    override fun opacify(factor: Double) = copy(alpha = alpha * factor)\n    override fun shade(factor: Double) = copy(l = l * factor)\n\n    override fun plus(right: ColorLCHABa) =\n        copy(l = l + right.l, c = c + right.c, h = h + right.h, alpha = alpha + right.alpha)\n\n    override fun minus(right: ColorLCHABa) =\n        copy(l = l - right.l, c = c - right.c, h = h - right.h, alpha = alpha - right.alpha)\n\n    override fun times(scale: Double) = copy(l = l * scale, c = c * scale, h = h * scale, alpha = alpha * scale)\n    override fun mix(other: ColorLCHABa, factor: Double) = mix(this, other, factor)\n\n    override fun toVector4(): Vector4 = Vector4(l, c, h, alpha)\n    override fun withChroma(chroma: Double): ColorLCHABa = copy(c = chroma)\n    override val chroma\n        get() = c\n    override fun withHue(hue: Double): ColorLCHABa = copy(h = hue)\n\n    override val hue: Double\n        get() = h\n    override fun withLuminosity(luminosity: Double): ColorLCHABa = copy(l = luminosity)\n    override val luminosity: Double\n        get() = l\n}\n/**\n * Weighted mix between two colors in the LChAB color space.\n * @param left the left-hand ColorLCHABa to mix\n * @param right the right-hand ColorLCHABa to mix\n * @param x the weighting of colors, a value 0.0 is equivalent to [left],\n * 1.0 is equivalent to [right] and at 0.5 both colors contribute to the result equally\n * @return a mix of [left] and [right] weighted by [x]\n */\nfun mix(left: ColorLCHABa, right: ColorLCHABa, x: Double): ColorLCHABa {\n    val sx = x.coerceIn(0.0, 1.0)\n    return ColorLCHABa(\n        (1.0 - sx) * left.l + sx * right.l,\n        (1.0 - sx) * left.c + sx * right.c,\n        mixAngle(left.h, right.h, sx),\n        (1.0 - sx) * left.alpha + sx * right.alpha\n    )\n}\n","package org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.*\nimport kotlin.jvm.JvmOverloads\nimport kotlin.math.*\n\n/**\n * The [CIELChUV color space](https://en.wikipedia.org/wiki/CIELUV#Cylindrical_representation_(CIELCh))\n * is the cylindrical representation of the CIELUV color space.\n *\n * @param l luminance, in a range of 0.0 (darkest) to 100.0 (brightest)\n * @param c chroma\n * @param h hue in degrees, where a full rotation is 360.0 degrees\n * @param alpha alpha as a percentage between 0.0 and 1.0\n * @param ref reference white against which the color values are calculated\n *\n * @see ColorLUVa\n */\n@Serializable\ndata class ColorLCHUVa @JvmOverloads constructor (\n    val l: Double,\n    val c: Double,\n    val h: Double,\n    override val alpha: Double = 1.0,\n    override val ref: ColorXYZa = ColorXYZa.NEUTRAL\n) :\n    ColorModel<ColorLCHUVa>,\n    ReferenceWhitePoint,\n    ShadableColor<ColorLCHUVa>,\n    ChromaColor<ColorLCHUVa>,\n    HueShiftableColor<ColorLCHUVa>,\n    LuminosityColor<ColorLCHUVa>,\n    AlgebraicColor<ColorLCHUVa> {\n\n    companion object {\n        fun fromLUVa(luva: ColorLUVa): ColorLCHUVa {\n            val l = luva.l\n            val c = sqrt(luva.u * luva.u + luva.v * luva.v)\n            var h = atan2(luva.v, luva.u)\n\n            if (h < 0) {\n                h += PI * 2\n            }\n            h = h.asDegrees\n            return ColorLCHUVa(l, c, h, luva.alpha, luva.ref)\n        }\n\n        fun findMaxChroma(l: Double, h: Double, ref: ColorXYZa): Double {\n            var left = 0.0\n            var right = 2000.0\n            var bestGuess = left\n            while (true) {\n\n                if (right - left < 0.0001) {\n                    return bestGuess\n                }\n\n                val leftTry = ColorLCHUVa(l, left, h, 1.0, ref)\n                val rightTry = ColorLCHUVa(l, right, h, 1.0, ref)\n                val middle = (left + right) / 2\n                val middleTry = ColorLCHUVa(l, middle, h, 1.0, ref)\n\n                val leftValid = leftTry.toRGBa().let { it.minValue >= 0 && it.maxValue <= 1.0 }\n                val rightValid = rightTry.toRGBa().let { it.minValue >= 0 && it.maxValue <= 1.0 }\n                val middleValid = middleTry.toRGBa().let { it.minValue >= 0 && it.maxValue <= 1.0 }\n\n                if (leftValid && middleValid && !rightValid) {\n                    val newLeft = middle\n                    val newRight = right\n                    bestGuess = middle\n                    left = newLeft\n                    right = newRight\n                }\n\n                if (leftValid && !middleValid && !rightValid) {\n                    val newLeft = left\n                    val newRight = middle\n                    left = newLeft\n                    right = newRight\n                }\n\n                if (leftValid == middleValid && middleValid == rightValid) {\n                    return bestGuess\n                }\n            }\n        }\n    }\n\n\n    fun toLUVa(): ColorLUVa {\n        val u = c * cos(h.asRadians)\n        val v = c * sin(h.asRadians)\n        return ColorLUVa(l, u, v, alpha, ref)\n    }\n\n    fun toLSHUVa() = ColorLSHUVa.fromLCHUVa(this)\n    override fun toRGBa() = toLUVa().toRGBa()\n\n    override fun opacify(factor: Double) = copy(alpha = alpha * factor)\n    override fun shade(factor: Double) = copy(l = l * factor)\n\n    override fun plus(right: ColorLCHUVa) =\n        copy(l = l + right.l, c = c + right.c, h = h + right.h, alpha = alpha + right.alpha)\n\n    override fun minus(right: ColorLCHUVa) =\n        copy(l = l - right.l, c = c - right.c, h = h - right.h, alpha = alpha - right.alpha)\n\n    override fun times(scale: Double) = copy(l = l * scale, c = c * scale, h = h * scale, alpha = alpha * scale)\n    override fun mix(other: ColorLCHUVa, factor: Double) = mix(this, other, factor)\n\n    override fun toVector4(): Vector4 = Vector4(l, c, h, alpha)\n    override fun withChroma(chroma: Double) = copy(c = chroma)\n\n    override val chroma: Double\n        get() = c\n    override fun withHue(hue: Double): ColorLCHUVa = copy(h = hue)\n\n    override val hue: Double\n        get() = h\n    override fun withLuminosity(luminosity: Double): ColorLCHUVa = copy(l = luminosity)\n    override val luminosity: Double\n        get() = l\n}\n\n/**\n * Weighted mix between two colors in the LChUV color space.\n *\n * @param x the weighting of colors, a value 0.0 is equivalent to [left],\n * 1.0 is equivalent to [right] and at 0.5 both colors contribute to the result equally\n * @return a mix of [left] and [right] weighted by [x]\n */\nfun mix(left: ColorLCHUVa, right: ColorLCHUVa, x: Double): ColorLCHUVa {\n    val sx = x.coerceIn(0.0, 1.0)\n    return ColorLCHUVa(\n        (1.0 - sx) * left.l + sx * right.l,\n        (1.0 - sx) * left.c + sx * right.c,\n        mixAngle(left.h, right.h, sx),\n        (1.0 - sx) * left.alpha + sx * right.alpha\n    )\n}\n","package org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Vector4\nimport org.openrndr.math.mixAngle\nimport kotlin.jvm.JvmOverloads\n\n/**\n * Based on [ColorLCHABa], but\n * instead tries to use a normalized chroma.\n *\n * @see ColorLCHABa\n */\n@Serializable\ndata class ColorLSHABa @JvmOverloads constructor(\n    val l: Double,\n    val s: Double,\n    val h: Double,\n    override val alpha: Double = 1.0,\n    override val ref: ColorXYZa = ColorXYZa.NEUTRAL\n) : ColorModel<ColorLSHABa>, ReferenceWhitePoint, HueShiftableColor<ColorLSHABa>, SaturatableColor<ColorLSHABa>,\n    LuminosityColor<ColorLSHABa>,\n    AlgebraicColor<ColorLSHABa> {\n    companion object {\n        fun fromLCHABa(lcha: ColorLCHABa): ColorLSHABa {\n            val maxC = ColorLCHABa.findMaxChroma(lcha.l, lcha.h, lcha.ref)\n            return ColorLSHABa(lcha.l, lcha.c / maxC, lcha.h, lcha.alpha, lcha.ref)\n        }\n    }\n\n    fun toLCHABa(): ColorLCHABa {\n        val maxC = ColorLCHABa.findMaxChroma(l, h, ref)\n        return ColorLCHABa(l, s * maxC, h, alpha, ref)\n    }\n\n    override fun toRGBa() = toLCHABa().toRGBa()\n\n    override fun opacify(factor: Double): ColorLSHABa = copy(alpha = alpha * factor)\n\n    override fun toVector4(): Vector4 = Vector4(l, s, h, alpha)\n    override fun withHue(hue: Double): ColorLSHABa = copy(h = hue)\n    override val hue: Double\n        get() = h\n\n    override fun withSaturation(saturation: Double): ColorLSHABa = copy(s = saturation)\n\n    override val saturation: Double\n        get() = s\n\n    override fun plus(right: ColorLSHABa): ColorLSHABa =\n        copy(l = l + right.l, s = s + right.s, h = h + right.h, alpha = alpha + right.alpha)\n\n    override fun minus(right: ColorLSHABa): ColorLSHABa =\n        copy(l = l - right.l, s = s - right.s, h = h - right.h, alpha = alpha - right.alpha)\n\n    override fun times(scale: Double): ColorLSHABa =\n        copy(l = l * scale, s = s * scale, h = h * scale, alpha = alpha * scale)\n\n    override fun mix(other: ColorLSHABa, factor: Double): ColorLSHABa {\n        val sx = factor.coerceIn(0.0, 1.0)\n        return ColorLSHABa(\n            (1.0 - sx) * l + sx * other.l,\n            (1.0 - sx) * s + sx * other.s,\n            mixAngle(h, other.h, sx),\n            (1.0 - sx) * alpha + sx * other.alpha\n        )\n    }\n\n    override fun withLuminosity(luminosity: Double): ColorLSHABa = copy(l = luminosity)\n\n    override val luminosity: Double\n        get() = l\n}","package org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Vector4\nimport org.openrndr.math.mixAngle\nimport kotlin.jvm.JvmOverloads\n\n/**\n * Based on [ColorLCHUVa], but\n * instead tries to use a normalized chroma.\n *\n * @see ColorLCHUVa\n */\n@Serializable\ndata class ColorLSHUVa @JvmOverloads constructor(\n    val l: Double,\n    val s: Double,\n    val h: Double,\n    override val alpha: Double = 1.0,\n    override val ref: ColorXYZa = ColorXYZa.NEUTRAL\n) : ColorModel<ColorLSHUVa>, ReferenceWhitePoint,\n    HueShiftableColor<ColorLSHUVa>,\n    SaturatableColor<ColorLSHUVa>,\n    LuminosityColor<ColorLSHUVa>,\n    AlgebraicColor<ColorLSHUVa> {\n    companion object {\n        fun fromLCHUVa(lcha: ColorLCHUVa): ColorLSHUVa {\n\n            val maxC = ColorLCHUVa.findMaxChroma(lcha.l, lcha.h, lcha.ref)\n            return ColorLSHUVa(lcha.l, lcha.c / maxC, lcha.h, lcha.alpha, lcha.ref)\n        }\n    }\n\n    fun toLCHUVa(): ColorLCHUVa {\n        val maxC = ColorLCHUVa.findMaxChroma(l, h, ref)\n        return ColorLCHUVa(l, s * maxC, h, alpha, ref)\n    }\n\n    override fun toRGBa() = toLCHUVa().toRGBa()\n\n    override fun opacify(factor: Double): ColorLSHUVa = copy(alpha = alpha * factor)\n\n    override fun toVector4(): Vector4 = Vector4(l, s, h, alpha)\n    override fun withHue(hue: Double): ColorLSHUVa = copy(h = hue)\n\n    override val hue: Double\n        get() = h\n    override fun withSaturation(saturation: Double): ColorLSHUVa = copy(s = saturation)\n\n    override val saturation\n        get() = s\n    override fun plus(right: ColorLSHUVa): ColorLSHUVa =\n        copy(l = l + right.l, s = s + right.s, h = h + right.h, alpha = alpha + right.alpha)\n\n    override fun minus(right: ColorLSHUVa): ColorLSHUVa =\n        copy(l = l - right.l, s = s - right.s, h = h - right.h, alpha = alpha - right.alpha)\n\n    override fun times(scale: Double): ColorLSHUVa =\n        copy(l = l * scale, s = s * scale, h = h * scale, alpha = alpha * scale)\n\n    override fun mix(other: ColorLSHUVa, factor: Double): ColorLSHUVa {\n        val sx = factor.coerceIn(0.0, 1.0)\n            return ColorLSHUVa(\n                (1.0 - sx) * l + sx * other.l,\n                (1.0 - sx) * s + sx * other.s,\n                mixAngle(h, other.h, sx),\n                (1.0 - sx) * alpha + sx * other.alpha\n            )\n        }\n\n    override fun withLuminosity(luminosity: Double): ColorLSHUVa = copy(l = luminosity)\n\n    override val luminosity: Double\n        get() = l\n}\n","package org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Vector4\nimport kotlin.jvm.JvmOverloads\nimport kotlin.math.pow\n\n/**\n * The [CIELUV color space](https://en.wikipedia.org/wiki/CIELUV)\n * @param l luminance, in a range of 0.0 (darkest) to 100.0 (brightest)\n * @param u unbounded chromaticity coordinate U\n * @param v unbounded chromaticity coordinate V\n * @param alpha alpha as a percentage between 0.0 and 1.0\n * @param ref reference white against which the color values are calculated\n */\n@Suppress(\"unused\", \"UNUSED_PARAMETER\")\n@Serializable\ndata class ColorLUVa @JvmOverloads constructor(\n    val l: Double,\n    val u: Double,\n    val v: Double,\n    override val alpha: Double = 1.0,\n    override val ref: ColorXYZa\n) :\n    ColorModel<ColorLUVa>,\n    ReferenceWhitePoint,\n    ShadableColor<ColorLUVa>,\n    LuminosityColor<ColorLUVa>,\n    AlgebraicColor<ColorLUVa> {\n\n    companion object {\n        fun fromXYZa(xyz: ColorXYZa, ref: ColorXYZa): ColorLUVa {\n            val y = if (ref.y != 0.0) xyz.y / ref.y else 0.0\n            val l = if (y <= (6.0 / 29.0).pow(3.0)) (29.0 / 3.0).pow(3.0) * y else\n                116.0 * y.pow(1.0 / 3.0) - 16.0\n\n\n            val div0 = (xyz.x + xyz.y * 15.0 + xyz.z * 3.0)\n\n            val up = if (div0 == 0.0) 0.0 else (xyz.x * 4.0) / div0\n            val vp = if (div0 == 0.0) 0.0 else (xyz.y * 9.0) / div0\n\n            val div1 =  (ref.x + ref.y * 15 + ref.z * 3.0)\n            val ur = if (div1 == 0.0) 0.0 else (ref.x * 4.0) / div1\n            val vr = if (div1 == 0.0) 0.0 else (ref.y * 9.0) / div1\n\n            val u = 13.0 * l * (up - ur)\n            val v = 13.0 * l * (vp - vr)\n\n            return ColorLUVa(l, u, v, xyz.alpha, ref)\n        }\n\n        fun fromRGBa(rgba: ColorRGBa, ref: ColorXYZa = ColorXYZa.NEUTRAL): ColorLUVa {\n            return fromXYZa(ColorXYZa.fromRGBa(rgba), ref)\n        }\n    }\n\n    fun toXYZa(): ColorXYZa {\n        val divr = (ref.x + ref.y * 15 + ref.z * 3.0)\n        val ur = if (divr == 0.0) 0.0 else (ref.x * 4.0) / divr\n        val vr = if (divr == 0.0) 0.0 else (ref.y * 9.0) / divr\n\n        val divp = 13 * l\n        val up = if (divp == 0.0) 0.0 else u / divp + ur\n        val vp = if (divp == 0.0) 0.0 else v / divp + vr\n\n        val y = if (l <= 8) ref.y * l * (3.0 / 29.0).pow(3.0) else ref.y * ((l + 16) / 116.0).pow(3.0)\n        val x = if (vp == 0.0) 0.0 else  y * ((9 * up) / (4 * vp))\n        val z = if (vp == 0.0) 0.0 else y * ((12 - 3 * up - 20 * vp) / (4 * vp))\n        return ColorXYZa(x, y, z, alpha)\n    }\n\n\n    override fun toRGBa() = toXYZa().toRGBa()\n    fun toRGBa(ref: ColorXYZa = this.ref): ColorRGBa = toXYZa().toRGBa()\n    fun toHSVa(ref: ColorXYZa = this.ref): ColorHSVa = toXYZa().toRGBa().toHSVa()\n    fun toHSLa(ref: ColorXYZa = this.ref): ColorHSLa = toXYZa().toRGBa().toHSLa()\n    fun toLABa(ref: ColorXYZa = this.ref): ColorLABa = toXYZa().toLABa(ref)\n\n    fun toLCHUVa(): ColorLCHUVa = ColorLCHUVa.fromLUVa(this)\n\n    override fun opacify(factor: Double) = copy(alpha = alpha * factor)\n    override fun shade(factor: Double) = copy(l = l * factor)\n\n    override fun plus(right: ColorLUVa) =\n        copy(l = l + right.l, u = u + right.u, v = v + right.v, alpha = alpha + right.alpha)\n\n    override fun minus(right: ColorLUVa) =\n        copy(l = l - right.l, u = u - right.u, v = v - right.v, alpha = alpha - right.alpha)\n\n    override fun times(scale: Double) = copy(l = l * scale, u = u * scale, v = v * scale, alpha = alpha * scale)\n\n    override fun toVector4() = Vector4(l, u, v, alpha)\n    override fun withLuminosity(luminosity: Double): ColorLUVa = copy(l = luminosity)\n\n    override val luminosity: Double\n        get() = l\n}","package org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Matrix55\nimport org.openrndr.math.Vector3\nimport org.openrndr.math.Vector4\nimport kotlin.jvm.JvmOverloads\nimport kotlin.math.pow\n\n\n@Serializable\nenum class Linearity(val certainty: Int) {\n    UNKNOWN(-1),\n    LINEAR(1),\n    SRGB(1),\n    ASSUMED_LINEAR(0),\n    ASSUMED_SRGB(0)\n    ;\n\n    fun leastCertain(other: Linearity): Linearity {\n        return if (this.certainty <= other.certainty) {\n            this\n        } else {\n            other\n        }\n    }\n\n    fun isEquivalent(other: Linearity): Boolean {\n        return if (this == UNKNOWN || other == UNKNOWN) {\n            false\n        } else if (this == other) {\n            true\n        } else {\n            if ((this == LINEAR || this == ASSUMED_LINEAR) && (other == LINEAR || other == ASSUMED_LINEAR)) {\n                true\n            } else (this == SRGB || this == ASSUMED_SRGB) && (other == SRGB || other == ASSUMED_SRGB)\n        }\n    }\n\n}\n\n/**\n * A generic RGB color space capable of representing\n * both the linear and the sRGB color spaces.\n *\n * @param r red as a percentage between 0.0 and 1.0\n * @param g green as a percentage between 0.0 and 1.0\n * @param b blue as a percentage between 0.0 and 1.0\n * @param alpha alpha as a percentage between 0.0 and 1.0\n * @see [rgb]\n * @see [rgba]\n */\n@Serializable\n@Suppress(\"EqualsOrHashCode\") // generated equals() is ok, only hashCode() needs to be overridden\ndata class ColorRGBa @JvmOverloads constructor(\n    val r: Double,\n    val g: Double,\n    val b: Double,\n    override val alpha: Double = 1.0,\n    val linearity: Linearity = Linearity.UNKNOWN\n) :\n    ColorModel<ColorRGBa>,\n    ShadableColor<ColorRGBa>,\n    AlgebraicColor<ColorRGBa> {\n\n    enum class Component {\n        R,\n        G,\n        B\n    }\n\n    companion object {\n        /**\n         * Calculates a color from hexadecimal value. For values with transparency\n         * use the [String] variant of this function.\n         */\n        fun fromHex(hex: Int): ColorRGBa {\n            val r = hex and (0xff0000) shr 16\n            val g = hex and (0x00ff00) shr 8\n            val b = hex and (0x0000ff)\n            return ColorRGBa(r / 255.0, g / 255.0, b / 255.0, 1.0, Linearity.SRGB)\n        }\n\n        /**\n         * Calculates a color from hexadecimal notation, like in CSS.\n         *\n         * Supports the following formats\n         * * `RGB`\n         * * `RGBA`\n         * * `RRGGBB`\n         * * `RRGGBBAA`\n         *\n         * where every character is a valid hex digit between `0..f` (case-insensitive).\n         * Supports leading \"#\" or \"0x\".\n         */\n        fun fromHex(hex: String): ColorRGBa {\n            val pos = when {\n                hex.startsWith(\"#\") -> 1\n                hex.startsWith(\"0x\") -> 2\n                else -> 0\n            }\n\n            fun fromHex1(str: String, pos: Int): Double {\n                return 17 * str[pos].digitToInt(16) / 255.0\n            }\n\n            fun fromHex2(str: String, pos: Int): Double {\n                return (16 * str[pos].digitToInt(16) + str[pos + 1].digitToInt(16)) / 255.0\n            }\n            return when (hex.length - pos) {\n                3 -> ColorRGBa(fromHex1(hex, pos), fromHex1(hex, pos + 1), fromHex1(hex, pos + 2), 1.0, Linearity.SRGB)\n                4 -> ColorRGBa(\n                    fromHex1(hex, pos),\n                    fromHex1(hex, pos + 1),\n                    fromHex1(hex, pos + 2),\n                    fromHex1(hex, pos + 3),\n                    Linearity.SRGB\n                )\n\n                6 -> ColorRGBa(fromHex2(hex, pos), fromHex2(hex, pos + 2), fromHex2(hex, pos + 4), 1.0, Linearity.SRGB)\n                8 -> ColorRGBa(\n                    fromHex2(hex, pos),\n                    fromHex2(hex, pos + 2),\n                    fromHex2(hex, pos + 4),\n                    fromHex2(hex, pos + 6),\n                    Linearity.SRGB\n                )\n\n                else -> throw IllegalArgumentException(\"Invalid hex length/format for '$hex'\")\n            }\n        }\n\n        /** @suppress */\n        val PINK = fromHex(0xffc0cb)\n\n        /** @suppress */\n        val BLACK = ColorRGBa(0.0, 0.0, 0.0, 1.0, Linearity.SRGB)\n\n        /** @suppress */\n        val WHITE = ColorRGBa(1.0, 1.0, 1.0, 1.0, Linearity.SRGB)\n\n        /** @suppress */\n        val RED = ColorRGBa(1.0, 0.0, 0.0, 1.0, Linearity.SRGB)\n\n        /** @suppress */\n        val BLUE = ColorRGBa(0.0, 0.0, 1.0, 1.0, Linearity.SRGB)\n\n        /** @suppress */\n        val GREEN = ColorRGBa(0.0, 1.0, 0.0, 1.0, Linearity.SRGB)\n\n        /** @suppress */\n        val YELLOW = ColorRGBa(1.0, 1.0, 0.0, 1.0, Linearity.SRGB)\n\n        /** @suppress */\n        val CYAN = ColorRGBa(0.0, 1.0, 1.0, 1.0, Linearity.SRGB)\n\n        /** @suppress */\n        val MAGENTA = ColorRGBa(1.0, 0.0, 1.0, 1.0, Linearity.SRGB)\n\n        /** @suppress */\n        val GRAY = ColorRGBa(0.5, 0.5, 0.5, 1.0, Linearity.SRGB)\n\n        /** @suppress */\n        val TRANSPARENT = ColorRGBa(0.0, 0.0, 0.0, 0.0, Linearity.SRGB)\n\n        /**\n         * Create a ColorRGBa object from a [Vector3]\n         * @param vector input vector, `[x, y, z]` is mapped to `[r, g, b]`\n         * @param alpha optional alpha value, default is 1.0\n         */\n        fun fromVector(vector: Vector3, alpha: Double = 1.0, linearity: Linearity = Linearity.SRGB): ColorRGBa {\n            return ColorRGBa(vector.x, vector.y, vector.z, alpha, linearity)\n        }\n\n\n        /**\n         * Create a ColorRGBa object from a [Vector4]\n         * @param vector input vector, `[x, y, z, w]` is mapped to `[r, g, b, a]`\n         */\n        fun fromVector(vector: Vector4, linearity: Linearity = Linearity.SRGB): ColorRGBa {\n            return ColorRGBa(vector.x, vector.y, vector.z, vector.w, linearity)\n        }\n    }\n\n    @Deprecated(\"Legacy alpha parameter name\", ReplaceWith(\"alpha\"))\n    val a = alpha\n\n    /**\n     * Creates a copy of color with adjusted opacity\n     * @param factor a scaling factor used for the opacity\n     * @return A [ColorRGBa] with scaled opacity\n     * @see shade\n     */\n    override fun opacify(factor: Double): ColorRGBa = ColorRGBa(r, g, b, alpha * factor, linearity)\n\n    /**\n     * Creates a copy of color with adjusted color\n     * @param factor a scaling factor used for the opacity\n     * @return A [ColorRGBa] with scaled colors\n     * @see opacify\n     */\n    override fun shade(factor: Double): ColorRGBa = ColorRGBa(r * factor, g * factor, b * factor, alpha, linearity)\n\n    /**\n     * Copy of the color with all of its fields clamped to `[0, 1]`\n     */\n\n    @Deprecated(\"Use clip() instead\", replaceWith = ReplaceWith(\"clip()\"))\n    val saturated: ColorRGBa\n        get() = clip()\n\n    /**\n     * Copy of the color with all of its fields clamped to `[0, 1]`\n     */\n    fun clip(): ColorRGBa = copy(\n        r = r.coerceIn(0.0..1.0),\n        g = g.coerceIn(0.0..1.0),\n        b = b.coerceIn(0.0..1.0),\n        alpha = alpha.coerceIn(0.0..1.0)\n    )\n\n\n    val alphaMultiplied: ColorRGBa\n        get() = ColorRGBa(r * alpha, g * alpha, b * alpha, alpha, linearity)\n\n    /**\n     * The minimum value over `r`, `g`, `b`\n     * @see maxValue\n     */\n    val minValue get() = r.coerceAtMost(g).coerceAtMost(b)\n\n    /**\n     * The maximum value over `r`, `g`, `b`\n     * @see minValue\n     */\n    val maxValue get() = r.coerceAtLeast(g).coerceAtLeast(b)\n\n    /**\n     * calculate luminance value\n     * luminance value is according to <a>https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef</a>\n     */\n    val luminance: Double\n        get() = when (linearity) {\n            Linearity.SRGB -> toLinear().luminance\n            else -> 0.2126 * r + 0.7152 * g + 0.0722 * b\n        }\n\n    /**\n     * calculate the contrast value between this color and the given color\n     * contrast value is accordingo to <a>// see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef</a>\n     */\n    fun getContrastRatio(other: ColorRGBa): Double {\n        val l1 = luminance\n        val l2 = other.luminance\n        return if (l1 > l2) (l1 + 0.05) / (l2 + 0.05) else (l2 + 0.05) / (l1 + 0.05)\n    }\n\n    fun toHSVa(): ColorHSVa = ColorHSVa.fromRGBa(this.toSRGB())\n    fun toHSLa(): ColorHSLa = ColorHSLa.fromRGBa(this.toSRGB())\n    fun toXSVa(): ColorXSVa = ColorHSVa.fromRGBa(this.toSRGB()).toXSVa()\n    fun toXSLa(): ColorXSLa = ColorHSLa.fromRGBa(this.toSRGB()).toXSLa()\n    fun toXYZa(): ColorXYZa = ColorXYZa.fromRGBa(this.toLinear())\n\n    @JvmOverloads\n    fun toLABa(ref: ColorXYZa = ColorXYZa.NEUTRAL): ColorLABa = ColorLABa.fromRGBa(this.toLinear(), ref)\n\n    @JvmOverloads\n    fun toLUVa(ref: ColorXYZa = ColorXYZa.NEUTRAL): ColorLUVa = ColorLUVa.fromRGBa(this.toLinear(), ref)\n\n    @JvmOverloads\n    fun toLCHABa(ref: ColorXYZa = ColorXYZa.NEUTRAL): ColorLCHABa = toXYZa().toLABa(ref).toLCHABa()\n\n    @JvmOverloads\n    fun toLCHUVa(ref: ColorXYZa = ColorXYZa.NEUTRAL): ColorLCHUVa = toLUVa(ref).toLCHUVa()\n\n    fun toLinear(): ColorRGBa {\n        fun t(x: Double): Double {\n            return if (x <= 0.04045) x / 12.92 else ((x + 0.055) / (1 + 0.055)).pow(2.4)\n        }\n        return when (linearity) {\n            Linearity.SRGB -> ColorRGBa(t(r), t(g), t(b), alpha, Linearity.LINEAR)\n            Linearity.UNKNOWN, Linearity.ASSUMED_SRGB -> ColorRGBa(t(r), t(g), t(b), alpha, Linearity.ASSUMED_LINEAR)\n            Linearity.ASSUMED_LINEAR, Linearity.LINEAR -> this\n        }\n    }\n\n    /**\n     * Convert to SRGB\n     * @see toLinear\n     */\n    fun toSRGB(): ColorRGBa {\n        fun t(x: Double): Double {\n            return if (x <= 0.0031308) 12.92 * x else (1 + 0.055) * x.pow(1.0 / 2.4) - 0.055\n        }\n        return when (linearity) {\n            Linearity.LINEAR -> ColorRGBa(t(r), t(g), t(b), alpha, Linearity.SRGB)\n            Linearity.UNKNOWN, Linearity.ASSUMED_LINEAR -> ColorRGBa(t(r), t(g), t(b), alpha, Linearity.ASSUMED_SRGB)\n            Linearity.ASSUMED_SRGB, Linearity.SRGB -> this\n        }\n    }\n\n    override fun toRGBa(): ColorRGBa = this\n\n    // This is here because the default hashing of enums on the JVM is not stable.\n    override fun hashCode(): Int {\n        var result = r.hashCode()\n        result = 31 * result + g.hashCode()\n        result = 31 * result + b.hashCode()\n        result = 31 * result + alpha.hashCode()\n        // here we overcome the unstable hash by using the ordinal value\n        result = 31 * result + linearity.ordinal.hashCode()\n        return result\n    }\n\n    override fun plus(right: ColorRGBa) = copy(\n        r = r + right.r,\n        g = g + right.g,\n        b = b + right.b,\n        alpha = alpha + right.alpha\n    )\n\n    override fun minus(right: ColorRGBa) = copy(\n        r = r - right.r,\n        g = g - right.g,\n        b = b - right.b,\n        alpha = alpha - right.alpha\n    )\n\n    override fun times(scale: Double) = copy(r = r * scale, g = g * scale, b = b * scale, alpha = alpha * scale)\n\n    override fun mix(other: ColorRGBa, factor: Double): ColorRGBa {\n        return mix(this, other, factor)\n    }\n\n    override fun toVector4(): Vector4 = Vector4(r, g, b, alpha)\n}\n\n/**\n * Weighted mix between two colors in the generic RGB color space.\n * @param x the weighting of colors, a value 0.0 is equivalent to [left],\n * 1.0 is equivalent to [right] and at 0.5 both colors contribute to the result equally\n * @return a mix of [left] and [right] weighted by [x]\n */\nfun mix(left: ColorRGBa, right: ColorRGBa, x: Double): ColorRGBa {\n    val sx = x.coerceIn(0.0, 1.0)\n\n    if (left.linearity.isEquivalent(right.linearity)) {\n        return ColorRGBa(\n            (1.0 - sx) * left.r + sx * right.r,\n            (1.0 - sx) * left.g + sx * right.g,\n            (1.0 - sx) * left.b + sx * right.b,\n            (1.0 - sx) * left.alpha + sx * right.alpha,\n            linearity = left.linearity.leastCertain(right.linearity)\n        )\n    } else {\n        return when (right.linearity) {\n            Linearity.LINEAR, Linearity.ASSUMED_LINEAR -> {\n                mix(left.toLinear(), right.toLinear(), x)\n            }\n\n            Linearity.SRGB, Linearity.ASSUMED_SRGB -> {\n                mix(left.toSRGB(), right.toSRGB(), x)\n            }\n\n            else -> {\n                error(\"can't blend ${right.linearity} with ${left.linearity}\")\n            }\n        }\n    }\n}\n\n/**\n * Shorthand for calling [ColorRGBa].\n * Specify only one value to obtain a shade of gray.\n * @param r red in `[0,1]`\n * @param g green in `[0,1]`\n * @param b blue in `[0,1]`\n * @param a alpha in `[0,1]`, defaults to `1.0`\n */\nfun rgb(r: Double, g: Double, b: Double, a: Double = 1.0) = ColorRGBa(r, g, b, a, linearity = Linearity.SRGB)\n\n/**\n * Shorthand for calling [ColorRGBa].\n * @param gray shade of gray in `[0,1]`\n * @param a alpha in `[0,1]`, defaults to `1.0`\n */\nfun rgb(gray: Double, a: Double = 1.0) = ColorRGBa(gray, gray, gray, a, linearity = Linearity.SRGB)\n\n/**\n * Create a color in RGBa space\n * This function is a shorthand for using the ColorRGBa constructor\n * @param r red in `[0,1]`\n * @param g green in `[0,1]`\n * @param b blue in `[0,1]`\n * @param a alpha in `[0,1]`\n */\n@Deprecated(\"Use rgb(r, g, b, a)\", ReplaceWith(\"rgb(r, g, b, a)\"), DeprecationLevel.WARNING)\nfun rgba(r: Double, g: Double, b: Double, a: Double) = ColorRGBa(r, g, b, a, linearity = Linearity.SRGB)\n\n/**\n * Shorthand for calling [ColorRGBa.fromHex].\n * Creates a [ColorRGBa] from a hex string.\n * @param hex string encoded hex value, for example `\"ffc0cd\"`\n */\nfun rgb(hex: String) = ColorRGBa.fromHex(hex)\n\noperator fun Matrix55.times(color: ColorRGBa): ColorRGBa {\n    return color.copy(\n        r = color.r * c0r0 + color.g * c1r0 + color.b * c2r0 + color.alpha * c3r0 + c4r0,\n        g = color.r * c0r1 + color.g * c1r1 + color.b * c2r1 + color.alpha * c3r1 + c4r1,\n        b = color.r * c0r2 + color.g * c1r2 + color.b * c2r2 + color.alpha * c3r2 + c4r2,\n        alpha = color.r * c0r3 + color.g * c1r3 + color.b * c2r3 + color.alpha * c3r3 + c4r3\n    )\n}","package org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Vector4\nimport org.openrndr.math.mixAngle\nimport kotlin.jvm.JvmOverloads\n\n/**\n * Practically identical to [ColorHSLa], but\n * for mapping colors to classical painter's scheme\n * of complementary colors.\n *\n * @see ColorHSLa\n * @see ColorXSVa\n */\n@Serializable\ndata class ColorXSLa @JvmOverloads constructor (val x: Double, val s: Double, val l: Double, override val alpha: Double = 1.0) :\n    ColorModel<ColorXSLa>,\n    ShadableColor<ColorXSLa>,\n    HueShiftableColor<ColorXSLa>,\n    SaturatableColor<ColorXSLa>,\n    AlgebraicColor<ColorXSLa> {\n\n    companion object {\n        fun fromHSLa(hsla: ColorHSLa): ColorXSLa {\n            val h = ((hsla.h % 360.0) + 360.0) % 360.0\n            val x = if (0 <= h && h < 35) {\n                map(h, 0.0, 35.0, 0.0, 60.0)\n            } else if (35 <= h && h < 60) {\n                map(h, 35.0, 60.0, 60.0, 120.0)\n            } else if (60 <= h && h < 135.0) {\n                map(h, 60.0, 135.0, 120.0, 180.0)\n            } else if (135.0 <= h && h < 225.0) {\n                map(h, 135.0, 225.0, 180.0, 240.0)\n            } else if (225.0 <= h && h < 275.0) {\n                map(h, 225.0, 275.0, 240.0, 300.0)\n            } else {\n                map(h, 275.0, 360.0, 300.0, 360.0)\n            }\n            return ColorXSLa(x, hsla.s, hsla.l, hsla.alpha)\n        }\n    }\n\n    @Deprecated(\"Legacy alpha parameter name\", ReplaceWith(\"alpha\"))\n    val a = alpha\n\n    fun toHSLa(): ColorHSLa {\n        val x = this.x % 360.0\n        val h = if (0.0 <= x && x < 60.0) {\n            map(x, 0.0, 60.0, 0.0, 35.0)\n        } else if (60.0 <= x && x < 120.0) {\n            map(x, 60.0, 120.0, 35.0, 60.0)\n        } else if (120.0 <= x && x < 180.0) {\n            map(x, 120.0, 180.0, 60.0, 135.0)\n        } else if (180.0 <= x && x < 240.0) {\n            map(x, 180.0, 240.0, 135.0, 225.0)\n        } else if (240.0 <= x && x < 300.0) {\n            map(x, 240.0, 300.0, 225.0, 275.0)\n        } else {\n            map(x, 300.0, 360.0, 275.0, 360.0)\n        }\n        return ColorHSLa(h, s, l, alpha)\n    }\n\n    override fun toRGBa() = toHSLa().toRGBa()\n\n    override fun shiftHue(shiftInDegrees: Double) = copy(x = (x + shiftInDegrees))\n    override fun withHue(hue: Double) = copy(x = hue)\n\n    override val hue: Double\n        get() = x\n    override fun withSaturation(saturation: Double): ColorXSLa = copy(s = saturation)\n\n    override val saturation: Double\n        get() = s\n\n    override fun shade(factor: Double) = copy(l = l * factor)\n    override fun opacify(factor: Double) = copy(alpha = alpha * factor)\n\n    override fun plus(right: ColorXSLa) = copy(\n        x = x + right.x,\n        s = s + right.s,\n        l = l + right.l,\n        alpha = alpha + right.alpha\n    )\n    override fun minus(right: ColorXSLa) = copy(\n        x = x - right.x,\n        s = s - right.s,\n        l = l - right.l,\n        alpha = alpha - right.alpha\n    )\n    override fun times(scale: Double) = copy(x = x * scale, s = s * scale, l = l * scale, alpha = alpha * scale)\n\n    override fun mix(other: ColorXSLa, factor: Double) = mix(this, other, factor)\n\n    override fun toVector4(): Vector4 = Vector4(x, s, l, alpha)\n}\n\nprivate fun map(x: Double, a: Double, b: Double, c: Double, d: Double): Double {\n    return ((x - a) / (b - a)) * (d - c) + c\n}\n\n/**\n * Weighted mix between two colors in the XSL color space.\n *\n * @param x the weighting of colors, a value 0.0 is equivalent to [left],\n * 1.0 is equivalent to [right] and at 0.5 both colors contribute to the result equally\n * @return a mix of [left] and [right] weighted by [x]\n */\nfun mix(left: ColorXSLa, right: ColorXSLa, x: Double): ColorXSLa {\n    val sx = x.coerceIn(0.0, 1.0)\n    return ColorXSLa(\n        mixAngle(left.x, right.x, sx),\n        (1.0 - sx) * left.s + sx * right.s,\n        (1.0 - sx) * left.l + sx * right.l,\n        (1.0 - sx) * left.alpha + sx * right.alpha\n    )\n}\n","package org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Vector4\nimport org.openrndr.math.mixAngle\nimport kotlin.jvm.JvmOverloads\n\n/**\n * Practically identical to [ColorHSVa], but\n * for mapping colors to classical painter's scheme\n * of complementary colors.\n *\n * @see ColorHSVa\n * @see ColorXSLa\n */\n@Serializable\ndata class ColorXSVa @JvmOverloads constructor (val x: Double, val s: Double, val v: Double, override val alpha: Double = 1.0) :\n    ColorModel<ColorXSVa>,\n    ShadableColor<ColorXSVa>,\n    HueShiftableColor<ColorXSVa>,\n    SaturatableColor<ColorXSVa>,\n    AlgebraicColor<ColorXSVa> {\n\n    companion object {\n        fun fromHSVa(hsva: ColorHSVa): ColorXSVa {\n            val h = ((hsva.h % 360.0) + 360.0) % 360.0\n            val x = if (0 <= h && h < 35) {\n                map(h, 0.0, 35.0, 0.0, 60.0)\n            } else if (35 <= h && h < 60) {\n                map(h, 35.0, 60.0, 60.0, 120.0)\n            } else if (60 <= h && h < 135.0) {\n                map(h, 60.0, 135.0, 120.0, 180.0)\n            } else if (135.0 <= h && h < 225.0) {\n                map(h, 135.0, 225.0, 180.0, 240.0)\n            } else if (225.0 <= h && h < 275.0) {\n                map(h, 225.0, 275.0, 240.0, 300.0)\n            } else {\n                map(h, 275.0, 360.0, 300.0, 360.0)\n            }\n            return ColorXSVa(x, hsva.s, hsva.v, hsva.alpha)\n        }\n    }\n\n    @Deprecated(\"Legacy alpha parameter name\", ReplaceWith(\"alpha\"))\n    val a = alpha\n\n    fun toHSVa(): ColorHSVa {\n        val x = this.x % 360.0\n        val h = if (0.0 <= x && x < 60.0) {\n            map(x, 0.0, 60.0, 0.0, 35.0)\n        } else if (60.0 <= x && x < 120.0) {\n            map(x, 60.0, 120.0, 35.0, 60.0)\n        } else if (120.0 <= x && x < 180.0) {\n            map(x, 120.0, 180.0, 60.0, 135.0)\n        } else if (180.0 <= x && x < 240.0) {\n            map(x, 180.0, 240.0, 135.0, 225.0)\n        } else if (240.0 <= x && x < 300.0) {\n            map(x, 240.0, 300.0, 225.0, 275.0)\n        } else {\n            map(x, 300.0, 360.0, 275.0, 360.0)\n        }\n        return ColorHSVa(h, s, v, alpha)\n    }\n\n    override fun toRGBa() = toHSVa().toRGBa()\n\n    override fun shiftHue(shiftInDegrees: Double) = copy(x = (x + shiftInDegrees))\n    override fun withHue(hue: Double): ColorXSVa = copy(x = hue)\n\n    override val hue: Double\n        get() = x\n\n    override fun withSaturation(saturation: Double): ColorXSVa = copy(s = saturation)\n\n    override val saturation: Double\n        get() = s\n\n    override fun shade(factor: Double) = copy(v = v * factor)\n    override fun opacify(factor: Double): ColorXSVa = copy(alpha = alpha * factor)\n\n    override fun plus(right: ColorXSVa) = copy(\n        x = x + right.x,\n        s = s + right.s,\n        v = v + right.v,\n        alpha = alpha + right.alpha\n    )\n    override fun minus(right: ColorXSVa) = copy(\n        x = x - right.x,\n        s = s - right.s,\n        v = v - right.v,\n        alpha = alpha - right.alpha\n    )\n    override fun times(scale: Double) = copy(x = x * scale, s = s * scale, v = v * scale, alpha = alpha * scale)\n\n    override fun mix(other: ColorXSVa, factor: Double) = mix(this, other, factor)\n\n    override fun toVector4(): Vector4 = Vector4(x, s, v, alpha)\n}\n\nprivate fun map(x: Double, a: Double, b: Double, c: Double, d: Double): Double {\n    return ((x - a) / (b - a)) * (d - c) + c\n}\n\n/**\n * Weighted mix between two colors in the XSV color space.\n *\n * @param x the weighting of colors, a value 0.0 is equivalent to [left],\n * 1.0 is equivalent to [right] and at 0.5 both colors contribute to the result equally\n * @return a mix of [left] and [right] weighted by [x]\n */\nfun mix(left: ColorXSVa, right: ColorXSVa, x: Double): ColorXSVa {\n    val sx = x.coerceIn(0.0, 1.0)\n    return ColorXSVa(\n        mixAngle(left.x, right.x, sx),\n        (1.0 - sx) * left.s + sx * right.s,\n        (1.0 - sx) * left.v + sx * right.v,\n        (1.0 - sx) * left.alpha + sx * right.alpha\n    )\n}\n","package org.openrndr.color\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Vector4\nimport kotlin.jvm.JvmOverloads\nimport kotlin.math.min\n\n/**\n * The [CIE XYZ color space](https://en.wikipedia.org/wiki/CIE_1931_color_space#Definition_of_the_CIE_XYZ_color_space).\n *\n * @param x first chromaticity coordinate, mix of the three CIE RGB curves chosen to be nonnegative\n * @param y luminance of the color, in a range of 0.0 (darkest) to 1.0 (brightest)\n * @param z second chromaticity coordinate, quasi-equal to blue\n * @param alpha alpha as a percentage between 0.0 and 1.0\n */\n@Serializable\ndata class ColorXYZa @JvmOverloads constructor (val x: Double, val y: Double, val z: Double, override val alpha: Double = 1.0) :\n    ColorModel<ColorXYZa>,\n    AlgebraicColor<ColorXYZa> {\n\n    @Suppress(\"unused\")\n    companion object {\n        // White points of standard illuminants as per the CIE 1931 2° Standard Observer\n        // Also see: https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_standard_observer,\n        // https://en.wikipedia.org/wiki/Standard_illuminant#White_points_of_standard_illuminants\n        val SO2_A = ColorXYZa(109.83 / 100.0, 1.0, 35.55 / 100.0)\n        val SO2_C = ColorXYZa(98.04 / 100.0, 1.0, 118.11 / 100.0)\n        val SO2_F2 = ColorXYZa(98.09 / 100.0, 1.0, 67.53 / 100.0)\n        val SO2_TL4 = ColorXYZa(101.40 / 100.0, 1.0, 65.90 / 100.0)\n        val SO2_UL3000 = ColorXYZa(107.99 / 100.0, 1.0, 33.91 / 100.0)\n        val SO2_D50 = ColorXYZa(107.99 / 100.0, 1.0, 82.45 / 100.0)\n        val SO2_D60 = ColorXYZa(107.99 / 100.0, 1.0, 100.86 / 100.0)\n        val SO2_D65 = ColorXYZa(95.02 / 100.0, 1.0, 108.82 / 100.0)\n        val SO2_D75 = ColorXYZa(107.99 / 100.0, 1.0, 122.53 / 100.0)\n\n        // White points of standard illuminants as per the CIE 1963 10° Standard Observer\n        val SO10_A = ColorXYZa(111.16 / 100.0, 1.0, 35.19 / 100.0)\n        val SO10_C = ColorXYZa(97.30 / 100.0, 1.0, 116.14 / 100.0)\n        val SO10_F2 = ColorXYZa(102.12 / 100.0, 1.0, 69.37 / 100.0)\n        val SO10_TL4 = ColorXYZa(103.82 / 100.0, 1.0, 66.90 / 100.0)\n        val SO10_UL3000 = ColorXYZa(111.12 / 100.0, 1.0, 35.21 / 100.0)\n        val SO10_D50 = ColorXYZa(96.72 / 100.0, 1.0, 81.45 / 100.0)\n        val SO10_D60 = ColorXYZa(95.21 / 100.0, 1.0, 99.60 / 100.0)\n        val SO10_D65 = ColorXYZa(94.83 / 100.0, 1.0, 107.38 / 100.0)\n        val SO10_D75 = ColorXYZa(94.45 / 100.0, 1.0, 120.70 / 100.0)\n\n        val NEUTRAL = fromRGBa(ColorRGBa(1.0, 1.0, 1.0, linearity = Linearity.LINEAR))\n\n        fun fromRGBa(rgba: ColorRGBa): ColorXYZa {\n            val linear = rgba.toLinear()\n            val x = 0.4124 * linear.r + 0.3576 * linear.g + 0.1805 * linear.b\n            val y = 0.2126 * linear.r + 0.7152 * linear.g + 0.0722 * linear.b\n            val z = 0.0193 * linear.r + 0.1192 * linear.g + 0.9505 * linear.b\n            return ColorXYZa(x, y, z, linear.alpha)\n        }\n    }\n\n    @Deprecated(\"Legacy alpha parameter name\", ReplaceWith(\"alpha\"))\n    val a = alpha\n\n    val minValue get() = min(min(x, y), z)\n\n    fun toLABa(ref: ColorXYZa) = ColorLABa.fromXYZa(this, ref)\n    fun toLUVa(ref: ColorXYZa) = ColorLUVa.fromXYZa(this, ref)\n    override fun toRGBa(): ColorRGBa {\n        val r = 3.2406 * x - 1.5372 * y - 0.4986 * z\n        val g = -0.9689 * x + 1.8758 * y + 0.0415 * z\n        val b = 0.0557 * x - 0.2040 * y + 1.0570 * z\n        return ColorRGBa(r, g, b, alpha, Linearity.LINEAR)\n    }\n\n    fun toHSVa(): ColorHSVa = toRGBa().toHSVa()\n    fun toHSLa(): ColorHSLa = toRGBa().toHSLa()\n    override fun plus(right: ColorXYZa) = copy(\n        x = x + right.x,\n        y = y + right.y,\n        z = z + right.z,\n        alpha = alpha + right.alpha\n    )\n    override fun minus(right: ColorXYZa) = copy(\n        x = x - right.x,\n        y = y - right.y,\n        z = z - right.z,\n        alpha = alpha - right.alpha\n    )\n    override fun times(scale: Double): ColorXYZa = copy(\n        x = x * scale,\n        y = y * scale,\n        z = z * scale,\n        alpha = alpha * scale\n    )\n    override fun opacify(factor: Double) = copy(alpha = alpha * factor)\n\n    override fun toVector4() = Vector4(x, y, z, alpha)\n}","@file:Suppress(\"unused\")\n\npackage org.openrndr.math\n\nimport kotlin.jvm.JvmName\nimport kotlin.math.max\nimport kotlin.math.min\n\nfun mod(a: Double, b: Double) = ((a % b) + b) % b\nfun mod(a: Int, b: Int) = ((a % b) + b) % b\nfun mod(a: Float, b: Float) = ((a % b) + b) % b\nfun mod(a: Long, b: Long) = ((a % b) + b) % b\n\n@Deprecated(\"deprecated\", replaceWith = ReplaceWith(\"mod\"))\n@JvmName(\"modDouble\")\nfun Double.mod_(b: Double) = mod(this, b)\n\n@Suppress(\"FunctionName\")\n@Deprecated(\"deprecated\", replaceWith = ReplaceWith(\"mod\"))\n@JvmName(\"modInt\")\nfun Int.mod_(b: Int) = mod(this, b)\n\n@Suppress(\"FunctionName\")\n@Deprecated(\"deprecated\", replaceWith = ReplaceWith(\"mod\"))\n@JvmName(\"modFloat\")\nfun Float.mod_(b: Float) = mod(this, b)\n\n@Suppress(\"FunctionName\")\n@Deprecated(\"deprecated\", replaceWith = ReplaceWith(\"mod\"))\n@JvmName(\"modLong\")\nfun Long.mod_(b: Long) = mod(this, b)\n\nfun Vector2.mod(b: Vector2) =\n        Vector2(x.mod(b.x),\n                y.mod(b.y))\n\nfun Vector3.mod(b: Vector3) =\n        Vector3(x.mod(b.x),\n                y.mod(b.y),\n                z.mod(b.z))\n\nfun Vector4.mod(b: Vector4) =\n        Vector4(x.mod(b.x),\n                y.mod(b.y),\n                z.mod(b.z),\n                w.mod(b.w))\n\nfun IntVector2.mod(b: IntVector2) =\n        IntVector2(x.mod(b.x),\n                y.mod(b.y))\n\nfun IntVector3.mod(b: IntVector3) =\n        IntVector3(x.mod(b.x),\n                y.mod(b.y),\n                z.mod(b.z))\n\nfun IntVector4.mod(b: IntVector4) =\n        IntVector4(x.mod(b.x),\n                y.mod(b.y),\n                z.mod(b.z),\n                w.mod(b.w))\n\n/** Returns number whose value is limited between [min] and [max]. */\nfun clamp(value: Double, min: Double, max: Double) = max(min, min(max, value))\n/** Returns number whose value is limited between [min] and [max]. */\nfun clamp(value: Int, min: Int, max: Int) = max(min, min(max, value))\n\n@JvmName(\"doubleClamp\")\nfun Double.clamp(min: Double, max: Double) = clamp(this, min, max)\n\n@JvmName(\"intClamp\")\nfun Int.clamp(min: Int, max: Int) = clamp(this, min, max)\n\n/** Returns [Vector2] whose value is limited between [min] and [max] per vector component. */\nfun Vector2.clamp(min : Vector2, max : Vector2) =\n        Vector2(x.clamp(min.x, max.x),\n                y.clamp(min.y, max.y))\n\n/** Returns [Vector3] whose value is limited between [min] and [max] per vector component. */\nfun Vector3.clamp(min : Vector3, max : Vector3) =\n        Vector3(x.clamp(min.x, max.x),\n                y.clamp(min.y, max.y),\n                z.clamp(min.y, max.z))\n\n/** Returns [Vector4] whose value is limited between [min] and [max] per vector component. */\nfun Vector4.clamp(min : Vector4, max : Vector4) =\n        Vector4(x.clamp(min.x, max.x),\n                y.clamp(min.y, max.y),\n                z.clamp(min.z, max.z),\n                w.clamp(min.w, max.w))\n\n/** Returns [IntVector2] whose value is limited between [min] and [max] per vector component. */\nfun IntVector2.clamp(min : IntVector2, max : IntVector2) =\n        IntVector2(x.clamp(min.x, max.x),\n                y.clamp(min.y, max.y))\n\n/** Returns [IntVector3] whose value is limited between [min] and [max] per vector component. */\nfun IntVector3.clamp(min : IntVector3, max : IntVector3) =\n        IntVector3(x.clamp(min.x, max.x),\n                y.clamp(min.y, max.y),\n                z.clamp(min.y, max.z))\n\n/** Returns [IntVector4] whose value is limited between [min] and [max] per vector component. */\nfun IntVector4.clamp(min : IntVector4, max : IntVector4) =\n        IntVector4(x.clamp(min.x, max.x),\n                y.clamp(min.y, max.y),\n                z.clamp(min.z, max.z),\n                w.clamp(min.w, max.w))\n\ninline val Double.asRadians: Double get() = this * 0.017453292519943295\ninline val Double.asDegrees: Double get() = this * 57.29577951308232\n\nval Double.asExponent: Int get() = (\n        (this.toRawBits() and EXP_BIT_MASK shr SIGNIFICAND_WIDTH - 1) - EXP_BIAS\n        ).toInt()\n\nprivate const val EXP_BIT_MASK = 0x7FF0000000000000L\nprivate const val SIGNIFICAND_WIDTH = 53\nprivate const val EXP_BIAS = 1023\n","package org.openrndr.draw\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.math.*\n\ninterface StyleParameters {\n    var parameterValues: MutableMap<String, Any>\n    var parameterTypes: ObservableHashmap<String, String>\n\n    var textureBaseIndex: Int\n\n    fun parameter(name: String, value: Cubemap) {\n        parameterValues[name] = value\n        parameterTypes[name] = when (value.type.colorSampling) {\n            ColorSampling.UNSIGNED_INTEGER -> \"Cubemap_UINT\"\n            ColorSampling.SIGNED_INTEGER -> \"Cubemap_SINT\"\n            else -> \"Cubemap\"\n        }\n    }\n\n    fun parameter(name: String, value: Boolean) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<Boolean>()\n    }\n\n    fun parameter(name: String, value: Int) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<Int>()\n    }\n\n    fun parameter(name: String, value: Matrix33) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<Matrix33>()\n    }\n\n    fun parameter(name: String, value: Matrix44) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<Matrix44>()\n    }\n\n    fun parameter(name: String, value: Array<Matrix44>) {\n        parameterValues[name] = value\n        parameterTypes[name] = \"${shadeStyleType<Matrix44>()},${value.size}\"\n    }\n\n    fun parameter(name: String, value: Array<Vector2>) {\n        parameterValues[name] = value\n        parameterTypes[name] = \"${shadeStyleType<Vector2>()},${value.size}\"\n    }\n\n    fun parameter(name: String, value: Array<Vector3>) {\n        parameterValues[name] = value\n        parameterTypes[name] = \"${shadeStyleType<Vector3>()},${value.size}\"\n    }\n\n    fun parameter(name: String, value: Array<Vector4>) {\n        parameterValues[name] = value\n        parameterTypes[name] = \"${shadeStyleType<Vector4>()},${value.size}\"\n    }\n\n    fun parameter(name: String, value: Array<ColorRGBa>) {\n        parameterValues[name] = value\n        parameterTypes[name] = \"${shadeStyleType<ColorRGBa>()},${value.size}\"\n    }\n\n    fun parameter(name: String, value: Float) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<Float>()\n    }\n\n    fun parameter(name: String, value: Double) {\n        parameterValues[name] = value.toFloat()\n        parameterTypes[name] = shadeStyleType<Float>()\n    }\n\n    fun parameter(name: String, value: Vector2) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<Vector2>()\n    }\n\n    fun parameter(name: String, value: Vector3) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<Vector3>()\n    }\n\n    fun parameter(name: String, value: Vector4) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<Vector4>()\n    }\n\n    fun parameter(name: String, value: IntVector2) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<IntVector2>()\n    }\n\n    fun parameter(name: String, value: IntVector3) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<IntVector3>()\n    }\n\n    fun parameter(name: String, value: IntVector4) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<IntVector4>()\n    }\n\n    fun parameter(name: String, value: ColorRGBa) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<ColorRGBa>()\n    }\n\n    fun parameter(name: String, value: ColorBuffer) {\n        parameterValues[name] = value\n        parameterTypes[name] = when (value.type.colorSampling) {\n            ColorSampling.UNSIGNED_INTEGER -> \"ColorBuffer_UINT\"\n            ColorSampling.SIGNED_INTEGER -> \"ColorBuffer_SINT\"\n            else -> \"ColorBuffer\"\n        }\n    }\n\n    fun parameter(name: String, value: DepthBuffer) {\n        parameterValues[name] = value\n        parameterTypes[name] = shadeStyleType<DepthBuffer>()\n    }\n\n    fun parameter(name: String, value: ArrayTexture) {\n        parameterValues[name] = value\n        parameterTypes[name] = when (value.type.colorSampling) {\n            ColorSampling.UNSIGNED_INTEGER -> \"ArrayTexture_UINT\"\n            ColorSampling.SIGNED_INTEGER -> \"ArrayTexture_SINT\"\n            else -> \"ArrayTexture\"\n        }\n    }\n\n    fun parameter(name: String, value: IntArray) {\n        parameterValues[name] = value\n        parameterTypes[name] = \"${shadeStyleType<Int>()}, ${value.size}\"\n    }\n\n    fun parameter(name: String, value: DoubleArray) {\n        parameterValues[name] = value\n        parameterTypes[name] = \"${shadeStyleType<Double>()}, ${value.size}\"\n    }\n\n    fun parameter(name: String, value: ArrayCubemap) {\n        parameterValues[name] = value\n        parameterTypes[name] = when (value.type.colorSampling) {\n            ColorSampling.UNSIGNED_INTEGER -> \"ArrayCubemap_UINT\"\n            ColorSampling.SIGNED_INTEGER -> \"ArrayCubemap_SINT\"\n            else -> \"ArrayCubemap\"\n        }\n    }\n\n    fun parameter(name: String, value: BufferTexture) {\n        parameterValues[name] = value\n        parameterTypes[name] = when (value.type.colorSampling) {\n            ColorSampling.UNSIGNED_INTEGER -> \"BufferTexture_UINT\"\n            ColorSampling.SIGNED_INTEGER -> \"BufferTexture_SINT\"\n            else -> \"BufferTexture\"\n        }\n    }\n\n    fun parameter(name: String, value: VolumeTexture) {\n        parameterValues[name] = value\n        parameterTypes[name] = when (value.type.colorSampling) {\n            ColorSampling.UNSIGNED_INTEGER -> \"VolumeTexture_UINT\"\n            ColorSampling.SIGNED_INTEGER -> \"VolumeTexture_SINT\"\n            else -> \"VolumeTexture\"\n        }\n    }\n\n\n\n}\n\ninline fun <reified T : Struct<T>> StyleParameters.parameter(name: String, value: T) {\n    parameterValues[name] = value\n    parameterTypes[name] = \"struct ${T::class.simpleName}\"\n}\n\ninline fun <reified T : Struct<T>> StyleParameters.parameter(name: String, value: Array<T>) {\n    parameterValues[name] = value\n    parameterTypes[name] = \"struct ${T::class.simpleName},${value.size}\"\n}\n","package org.openrndr.draw\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.draw.font.BufferAccess\nimport org.openrndr.draw.font.BufferFlag\nimport org.openrndr.math.*\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\nimport kotlin.properties.ReadWriteProperty\nimport kotlin.reflect.KProperty\n\ninline fun <reified F> shadeStyleTypeOrNull(): String? {\n    return when (F::class) {\n        Boolean::class -> \"boolean\"\n        Int::class -> \"int\"\n        Float::class -> \"float\"\n        Double::class -> \"float\"\n        Vector2::class -> \"Vector2\"\n        IntVector2::class -> \"IntVector2\"\n        Vector3::class -> \"Vector3\"\n        IntVector3::class -> \"IntVector3\"\n        Vector4::class -> \"Vector4\"\n        IntVector4::class -> \"IntVector4\"\n        Matrix33::class -> \"Matrix33\"\n        Matrix44::class -> \"Matrix44\"\n        ColorRGBa::class -> \"ColorRGBa\"\n        DepthBuffer::class -> \"DepthBuffer\"\n        else -> \"struct ${F::class.simpleName}\"\n    }\n}\n\ninline fun <reified F> shadeStyleType(): String {\n    return shadeStyleTypeOrNull<F>() ?: error(\"shade style type not supported: ${F::class.simpleName}\")\n}\n\nprivate fun shadeStyleTypeToGLSLOrNull(type: String): String? {\n    return when (type) {\n        shadeStyleType<Boolean>() -> \"bool\"\n        shadeStyleType<Int>() -> \"int\"\n        shadeStyleType<Matrix33>() -> \"mat3\"\n        shadeStyleType<Matrix44>() -> \"mat4\"\n        shadeStyleType<Float>(), shadeStyleType<Double>() -> \"float\"\n        shadeStyleType<Vector2>() -> \"vec2\"\n        shadeStyleType<Vector3>() -> \"vec3\"\n        shadeStyleType<Vector4>(), shadeStyleType<ColorRGBa>() -> \"vec4\"\n        \"BufferTexture\" -> \"samplerBuffer\"\n        \"BufferTexture_UINT\" -> \"usamplerBuffer\"\n        \"BufferTexture_SINT\" -> \"isamplerBuffer\"\n        \"ColorBuffer\" -> \"sampler2D\"\n        \"ColorBuffer_UINT\" -> \"usampler2D\"\n        \"ColorBuffer_SINT\" -> \"isampler2D\"\n        \"DepthBuffer\" -> \"sampler2D\"\n        \"Cubemap\" -> \"samplerCube\"\n        \"Cubemap_UINT\" -> \"usamplerCube\"\n        \"Cubemap_SINT\" -> \"isamplerCube\"\n        \"ArrayCubemap\" -> \"samplerCubeArray\"\n        \"ArrayCubemap_UINT\" -> \"usamplerCubeArray\"\n        \"ArrayCubemap_SINT\" -> \"isamplerCubeArray\"\n        \"ArrayTexture\" -> \"sampler2DArray\"\n        \"ArrayTexture_UINT\" -> \"usampler2DArray\"\n        \"ArrayTexture_SINT\" -> \"isampler2DArray\"\n        \"VolumeTexture\" -> \"sampler3D\"\n        \"VolumeTexture_UINT\" -> \"usampler3D\"\n        \"VolumeTexture_SINT\" -> \"isampler3D\"\n        else -> if (type.startsWith(\"struct\")) {\n            type.drop(7)\n        } else {\n            null\n        }\n    }\n}\n\nfun shadeStyleTypeToGLSL(type: String): String {\n    return shadeStyleTypeToGLSLOrNull(type) ?: error(\"unsupported type $type\")\n}\n\ndata class ShadeStyleOutput(\n    val attachment: Int,\n    val format: ColorFormat = ColorFormat.RGBa,\n    val type: ColorType = ColorType.FLOAT32\n)\n\n\nclass ObservableHashmap<K, V>(val b: MutableMap<K, V>, inline val onChange: () -> Unit) : MutableMap<K, V> by b {\n    override fun put(key: K, value: V): V? {\n        if (key in this) {\n            if (get(key) != value) {\n                onChange()\n            }\n        }\n        return b.put(key, value)\n    }\n\n    override fun remove(key: K): V? {\n        onChange()\n        return b.remove(key)\n    }\n}\n\n\n\n@Suppress(\"unused\")\nopen class ShadeStyle : StyleParameters, StyleBufferBindings, StyleImageBindings {\n    var dirty = true\n\n    override var textureBaseIndex = 0\n\n    var vertexPreamble: String? = null\n        set(value) {\n            dirty = true\n            field = value\n        }\n\n    var geometryPreamble: String? = null\n        set(value) {\n            dirty = true\n            field = value\n        }\n\n    var fragmentPreamble: String? = null\n        set(value) {\n            dirty = true\n            field = value\n        }\n\n    var vertexTransform: String? = null\n        set(value) {\n            dirty = true\n            field = value\n        }\n\n    var geometryTransform: String? = null\n        set(value) {\n            dirty = true\n            field = value\n        }\n\n    var fragmentTransform: String? = null\n        set(value) {\n            dirty = true\n            field = value\n        }\n\n    override var bufferValues = mutableMapOf<String, Any>()\n    override val buffers = mutableMapOf<String, String>()\n    override val bufferTypes = mutableMapOf<String, String>()\n    override val bufferFlags = mutableMapOf<String, Set<BufferFlag>>()\n    override val bufferAccess = mutableMapOf<String, BufferAccess>()\n\n    override val imageTypes: MutableMap<String, String> = mutableMapOf()\n    override val imageValues: MutableMap<String, Array<out ImageBinding>> = mutableMapOf()\n    override val imageAccess: MutableMap<String, ImageAccess> = mutableMapOf()\n    override val imageFlags: MutableMap<String, Set<ImageFlag>> = mutableMapOf()\n    override val imageArrayLength: MutableMap<String, Int> = mutableMapOf()\n\n\n    var outputs = ObservableHashmap(HashMap<String, ShadeStyleOutput>()) { dirty = true }\n    var attributes = mutableListOf<VertexBuffer>()\n\n    var suppressDefaultOutput = false\n        set(value) {\n            dirty = true\n            field = value\n        }\n\n    constructor()\n\n    constructor(other: ShadeStyle) {\n        this.fragmentPreamble = other.fragmentPreamble\n        this.geometryPreamble = other.geometryPreamble\n        this.vertexPreamble = other.vertexPreamble\n\n        this.fragmentTransform = other.fragmentTransform\n        this.geometryTransform = other.geometryTransform\n        this.vertexTransform = other.vertexTransform\n\n        this.parameterTypes.putAll(other.parameterTypes)\n        this.outputs.putAll(other.outputs)\n    }\n\n    fun output(name: String, output: ShadeStyleOutput) {\n        outputs[name] = output\n    }\n\n    fun attributes(attributesBuffer: VertexBuffer) {\n        attributes.add(attributesBuffer)\n    }\n\n\n    operator fun plus(other: ShadeStyle): ShadeStyle {\n        val s = ShadeStyle()\n        s.vertexTransform = concat(vertexTransform, other.vertexTransform)\n        s.fragmentTransform = concat(fragmentTransform, other.fragmentTransform)\n\n        s.vertexPreamble =\n            (if (vertexPreamble == null) \"\" else vertexPreamble) + \"\\n\" + if (other.vertexPreamble == null) \"\" else other.vertexPreamble\n        s.fragmentPreamble =\n            (if (fragmentPreamble == null) \"\" else fragmentPreamble) + \"\\n\" + if (other.fragmentPreamble == null) \"\" else other.fragmentPreamble\n\n        s.parameterTypes.apply {\n            putAll(parameterTypes)\n            putAll(other.parameterTypes)\n        }\n\n        s.parameterValues.apply {\n            putAll(parameterValues)\n            putAll(other.parameterValues)\n        }\n\n        s.outputs.apply {\n            putAll(outputs)\n            putAll(other.outputs)\n        }\n\n        s.attributes.apply {\n            addAll(attributes)\n            addAll(other.attributes)\n        }\n\n        return s\n    }\n\n    inner class Parameter<R : Any> : ReadWriteProperty<ShadeStyle, R> {\n\n        override fun getValue(thisRef: ShadeStyle, property: KProperty<*>): R {\n            @Suppress(\"UNCHECKED_CAST\")\n            return parameterValues[property.name] as R\n        }\n\n        override fun setValue(thisRef: ShadeStyle, property: KProperty<*>, value: R) {\n            parameterValues[property.name] = value\n            parameterTypes[property.name] = when (value) {\n                is Boolean -> \"boolean\"\n                is Int -> \"int\"\n                is Double -> \"float\"\n                is Float -> \"float\"\n                is IntArray -> \"int, ${value.size}\"\n                is FloatArray -> \"float, ${value.size}\"\n                is Vector2 -> \"Vector2\"\n                is Vector3 -> \"Vector3\"\n                is Vector4 -> \"Vector4\"\n                is IntVector2 -> \"IntVector2\"\n                is IntVector3 -> \"IntVector3\"\n                is IntVector4 -> \"IntVector4\"\n                is Matrix33 -> \"Matrix33\"\n                is Matrix44 -> \"Matrix44\"\n                is ColorRGBa -> \"ColorRGBa\"\n                is BufferTexture -> when (value.type.colorSampling) {\n                    ColorSampling.UNSIGNED_INTEGER -> \"BufferTexture_UINT\"\n                    ColorSampling.SIGNED_INTEGER -> \"BufferTexture_SINT\"\n                    else -> \"BufferTexture\"\n                }\n\n                is DepthBuffer -> \"DepthBuffer\"\n                is ArrayTexture -> when (value.type.colorSampling) {\n                    ColorSampling.UNSIGNED_INTEGER -> \"ArrayTexture_UINT\"\n                    ColorSampling.SIGNED_INTEGER -> \"ArrayTexture_SINT\"\n                    else -> \"ArrayTexture\"\n                }\n\n                is ArrayCubemap -> when (value.type.colorSampling) {\n                    ColorSampling.UNSIGNED_INTEGER -> \"ArrayCubemap_UINT\"\n                    ColorSampling.SIGNED_INTEGER -> \"ArrayCubemap_SINT\"\n                    else -> \"ArrayCubemap\"\n                }\n\n                is Cubemap -> when (value.type.colorSampling) {\n                    ColorSampling.UNSIGNED_INTEGER -> \"Cubemap_UINT\"\n                    ColorSampling.SIGNED_INTEGER -> \"Cubemap_SINT\"\n                    else -> \"Cubemap\"\n                }\n\n                is ColorBuffer -> when (value.type.colorSampling) {\n                    ColorSampling.UNSIGNED_INTEGER -> \"ColorBuffer_UINT\"\n                    ColorSampling.SIGNED_INTEGER -> \"ColorBuffer_SINT\"\n                    else -> \"ColorBuffer\"\n                }\n\n                is Array<*> -> {\n                    if (value.isNotEmpty()) {\n                        when (value.first()) {\n                            is Matrix44 -> {\n                                \"Matrix44, ${value.size}\"\n                            }\n\n                            is Vector2 -> {\n                                \"Vector2, ${value.size}\"\n                            }\n\n                            is Vector3 -> {\n                                \"Vector3, ${value.size}\"\n                            }\n\n                            is Vector4 -> {\n                                \"Vector4, ${value.size}\"\n                            }\n\n                            is ColorRGBa -> {\n                                \"ColorRGBa, ${value.size}\"\n                            }\n\n                            is Double -> {\n                                \"float, ${value.size}\"\n                            }\n\n                            is IntVector2 -> {\n                                \"IntVector2, ${value.size}\"\n                            }\n\n                            is IntVector3 -> {\n                                \"IntVector3, ${value.size}\"\n                            }\n\n                            is IntVector4 -> {\n                                \"IntVector4, ${value.size}\"\n                            }\n\n                            is CastableToVector4 -> {\n                                \"Vector4, ${value.size}\"\n                            }\n\n                            else -> error(\"unsupported array type ${(value.first()!!)::class}\")\n                        }\n                    } else {\n                        error(\"empty array\")\n                    }\n                }\n\n                is CastableToVector4 -> {\n                    \"Vector4\"\n                }\n\n                else -> error(\"unsupported type ${value::class}\")\n            }\n        }\n    }\n\n    override var parameterValues: MutableMap<String, Any> = mutableMapOf()\n    override var parameterTypes: ObservableHashmap<String, String> = ObservableHashmap(mutableMapOf()) { dirty = true }\n}\n\n@OptIn(ExperimentalContracts::class)\nfun shadeStyle(builder: ShadeStyle.() -> Unit): ShadeStyle {\n    contract {\n        callsInPlace(builder, InvocationKind.EXACTLY_ONCE)\n    }\n    return ShadeStyle().apply(builder)\n}\n\nprivate fun concat(left: String?, right: String?): String? {\n    return if (left == null && right == null) {\n        null\n    } else if (left == null && right != null) {\n        right\n    } else if (left != null && right == null) {\n        left\n    } else if (left != null && right != null) {\n        \"${isolate(left)}\\n${isolate(right)}\"\n    } else {\n        throw RuntimeException(\"should never happen\")\n    }\n}\n\nprivate fun isolate(code: String): String =\n    if (code.startsWith(\"{\") && code.endsWith(\"}\")) {\n        code\n    } else {\n        \"{$code}\"\n    }","package org.openrndr.draw\n\nimport org.openrndr.draw.font.BufferAccess\nimport org.openrndr.draw.font.BufferFlag\n\ninterface StyleBufferBindings {\n\n    var bufferValues: MutableMap<String, Any>\n    val buffers: MutableMap<String, String>\n    val bufferTypes: MutableMap<String, String>\n    val bufferFlags: MutableMap<String, Set<BufferFlag>>\n    val bufferAccess: MutableMap<String, BufferAccess>\n\n    fun buffer(name: String, buffer: ShaderStorageBuffer) {\n        bufferValues[name] = buffer\n        buffers[name] = buffer.format.hashCode().toString()\n    }\n\n    fun buffer(name: String, buffer: AtomicCounterBuffer) {\n        bufferValues[name] = buffer\n        buffers[name] = \"AtomicCounterBuffer\"\n    }\n}\n\ninline fun <reified T : Struct<T>> StyleBufferBindings.registerStructuredBuffer(\n    name: String,\n    access: BufferAccess = BufferAccess.READ_WRITE,\n    flags: Set<BufferFlag> = emptySet()\n) {\n    bufferTypes[name] = \"struct ${T::class.simpleName}\"\n    bufferFlags[name] = flags\n    bufferAccess[name] = access\n}\n\ninline fun <reified T : Struct<T>> StyleBufferBindings.structuredBuffer(name: String, buffer: StructuredBuffer<T>) {\n    bufferValues[name] = buffer\n    buffers[name] = buffer.format.hashCode().toString()\n    bufferTypes[name] = \"struct ${T::class.simpleName}\"\n}\n","package org.openrndr.draw\n\ninterface StyleImageBindings {\n    val imageValues: MutableMap<String, Array<out ImageBinding>>\n    val imageTypes: MutableMap<String, String>\n    val imageAccess: MutableMap<String, ImageAccess>\n    val imageFlags: MutableMap<String, Set<ImageFlag>>\n    val imageArrayLength: MutableMap<String, Int>\n\n    @Deprecated(\"renamed to image\", ReplaceWith(\"image\"))\n    fun parameter(name: String, value: ImageBinding) {\n        image(name, value)\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun StyleImageBindings.registerImageBinding(\n        name: String,\n        access: ImageAccess = ImageAccess.READ_WRITE,\n        flags: Set<ImageFlag>,\n        arrayLength: Int = -1\n    ) {\n        imageAccess[name] = access\n        imageFlags[name] = flags\n        imageArrayLength[name] = arrayLength\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun image(name: String, value: ImageBinding) {\n        if (imageAccess[name] != null) {\n            require(imageAccess[name] == value.access) {\n                \"expected image access ${imageAccess[name]}, got ${value.access}\"\n            }\n        } else {\n            imageAccess[name] = value.access\n        }\n        imageValues[name] = arrayOf(value)\n        imageTypes[name] = imageBindingType(value)\n        imageArrayLength[name] = -1\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun image(name: String, values: Array<out ImageBinding>) {\n        require(values.isNotEmpty())\n        require(values.all { it.access == values[0].access })\n\n        if (imageAccess[name] != null) {\n            require(imageAccess[name] == values[0].access) {\n                \"expected image access ${imageAccess[name]}, got ${values[0].access}\"\n            }\n        } else {\n            imageAccess[name] = values[0].access\n        }\n        imageValues[name] = values\n        imageTypes[name] = imageBindingType(values[0])\n        imageArrayLength[name] = values.size\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun image(name: String, arrayTexture: ArrayTexture, level: Int = 0) {\n        require(imageAccess[name] != null) {\n            \"image binding '$name' is not registered\"\n        }\n        val imageBinding =\n            arrayTexture.imageBinding(level, imageAccess[name] ?: error(\"image binding '$name' is not registered\"))\n        image(name, imageBinding)\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun image(\n        name: String,\n        arrayTextures: Array<ArrayTexture>,\n        levels: Array<Int> = Array(arrayTextures.size) { 0 }\n    ) {\n        require(arrayTextures.isNotEmpty())\n        require(imageAccess[name] != null) {\n            \"image binding '$name' is not registered\"\n        }\n        val imageBindings = arrayTextures.mapIndexed { index, it ->\n            it.imageBinding(levels[index], imageAccess[name]!!)\n        }.toTypedArray()\n        image(name, imageBindings)\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun image(name: String, colorBuffer: ColorBuffer, level: Int = 0) {\n        require(imageAccess[name] != null) {\n            \"image binding '$name' is not registered\"\n        }\n        val imageBinding =\n            colorBuffer.imageBinding(level, imageAccess[name] ?: error(\"image binding '$name' is not registered\"))\n        image(name, imageBinding)\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun image(\n        name: String,\n        colorBuffers: Array<ColorBuffer>,\n        levels: Array<Int> = Array(colorBuffers.size) { 0 }\n    ) {\n        require(colorBuffers.isNotEmpty())\n        require(imageAccess[name] != null) {\n            \"image binding '$name' is not registered\"\n        }\n        val imageBindings = colorBuffers.mapIndexed { index, it ->\n            it.imageBinding(levels[index], imageAccess[name]!!)\n        }.toTypedArray()\n        image(name, imageBindings)\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun image(name: String, cubemap: Cubemap, level: Int = 0) {\n        require(imageAccess[name] != null) {\n            \"image binding '$name' is not registered\"\n        }\n        val imageBinding =\n            cubemap.imageBinding(level, imageAccess[name] ?: error(\"image binding '$name' is not registered\"))\n        image(name, imageBinding)\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun image(\n        name: String,\n        cubemaps: Array<Cubemap>,\n        levels: Array<Int> = Array(cubemaps.size) { 0 }\n    ) {\n        require(cubemaps.isNotEmpty())\n        require(imageAccess[name] != null) {\n            \"image binding '$name' is not registered\"\n        }\n        val imageBindings = cubemaps.mapIndexed { index, it ->\n            it.imageBinding(levels[index], imageAccess[name]!!)\n        }.toTypedArray()\n        image(name, imageBindings)\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun image(name: String, volumeTexture: VolumeTexture, level: Int = 0) {\n        require(imageAccess[name] != null) {\n            \"image binding '$name' is not registered\"\n        }\n        val imageBinding = volumeTexture.imageBinding(level, imageAccess[name]!!)\n        image(name, imageBinding)\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun image(\n        name: String,\n        volumeTextures: Array<VolumeTexture>,\n        levels: Array<Int> = Array(volumeTextures.size) { 0 }\n    ) {\n        require(volumeTextures.isNotEmpty())\n        require(imageAccess[name] != null) {\n            \"image binding '$name' is not registered\"\n        }\n        val imageBindings = volumeTextures.mapIndexed { index, it ->\n            it.imageBinding(levels[index], imageAccess[name]!!)\n        }.toTypedArray()\n        image(name, imageBindings)\n    }\n\n    /**\n     * @since 0.4.4\n     */\n    fun imageBindingType(value: ImageBinding): String {\n        return when (value) {\n            is BufferTextureImageBinding -> {\n                \"ImageBuffer,${value.bufferTexture.format.name},${value.bufferTexture.type.name}\"\n            }\n\n            is CubemapImageBinding -> {\n                \"ImageCube,${value.cubemap.format.name},${value.cubemap.type.name}\"\n            }\n\n            is ArrayCubemapImageBinding -> {\n                \"ImageCubeArray,${value.arrayCubemap.format.name},${value.arrayCubemap.type.name}\"\n            }\n\n            is ColorBufferImageBinding -> {\n                \"Image2D,${value.colorBuffer.format.name},${value.colorBuffer.type.name}\"\n            }\n\n            is ArrayTextureImageBinding -> {\n                \"Image2DArray,${value.arrayTexture.format.name},${value.arrayTexture.type.name}\"\n            }\n\n            is VolumeTextureImageBinding -> {\n                \"Image3D,${value.volumeTexture.format.name},${value.volumeTexture.type.name}\"\n            }\n\n            else -> error(\"unsupported image binding\")\n        }\n    }\n}\n","package org.openrndr.draw\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.Vector3\nimport org.openrndr.shape.Circle\nimport org.openrndr.shape.Rectangle\nimport kotlin.jvm.JvmName\n\nfun BufferWriter.write(drawStyle: DrawStyle) {\n    write(drawStyle.fill ?: ColorRGBa.TRANSPARENT)\n    write(drawStyle.stroke ?: ColorRGBa.TRANSPARENT)\n    val weight = if (drawStyle.stroke == null || drawStyle.stroke?.alpha == 0.0) 0.0 else\n        drawStyle.strokeWeight\n    write(weight.toFloat())\n}\n\nval drawStyleFormat = vertexFormat {\n    attribute(\"fill\", VertexElementType.VECTOR4_FLOAT32)\n    attribute(\"stroke\", VertexElementType.VECTOR4_FLOAT32)\n    attribute(\"strokeWeight\", VertexElementType.FLOAT32)\n}\n\nval circleFormat = vertexFormat {\n    attribute(\"offset\", VertexElementType.VECTOR3_FLOAT32)\n    attribute(\"radius\", VertexElementType.VECTOR2_FLOAT32)\n}\n\nval rectangleFormat = vertexFormat {\n    attribute(\"offset\", VertexElementType.VECTOR3_FLOAT32)\n    attribute(\"dimensions\", VertexElementType.VECTOR2_FLOAT32)\n    attribute(\"rotation\", VertexElementType.FLOAT32)\n}\n\nval pointFormat = vertexFormat {\n    attribute(\"offset\", VertexElementType.VECTOR3_FLOAT32)\n}\n\n/**\n * Stored circle batch\n */\nclass CircleBatch(val geometry: VertexBuffer, val drawStyle: VertexBuffer) {\n    init {\n        require(geometry.vertexFormat == circleFormat)\n        require(drawStyle.vertexFormat == drawStyleFormat)\n        require(geometry.vertexCount == drawStyle.vertexCount)\n    }\n\n    val size\n        get() = geometry.vertexCount\n\n    companion object {\n        fun create(size: Int, session: Session? = Session.active): CircleBatch {\n            return CircleBatch(vertexBuffer(circleFormat, size, session), vertexBuffer(drawStyleFormat, size, session))\n        }\n    }\n\n    /**\n     * Destroy the stored batch\n     */\n    fun destroy() {\n        geometry.destroy()\n        drawStyle.destroy()\n    }\n}\n\n\nopen class BatchBuilder(val drawer: Drawer) {\n    /**\n     * Active fill color\n     */\n    var fill = drawer.fill\n\n    /**\n     * Active stroke color\n     */\n    var stroke = drawer.stroke\n\n    /**\n     * Active stroke weight\n     */\n    var strokeWeight = drawer.strokeWeight\n\n}\n\n/**\n * Builder for stored circle batches\n */\nclass CircleBatchBuilder(drawer: Drawer) : BatchBuilder(drawer) {\n    class Entry(\n            val fill: ColorRGBa?,\n            val stroke: ColorRGBa?,\n            val strokeWeight: Double,\n            val offset: Vector3,\n            val radius: Vector2\n    )\n\n    val entries = mutableListOf<Entry>()\n\n    /**\n     * Add a circle to the batch\n     */\n    fun circle(x: Double, y: Double, radius: Double) {\n        entries.add(Entry(fill, stroke, strokeWeight, Vector3(x, y, 0.0), Vector2(radius, radius)))\n    }\n\n    /**\n     * Add a circle to the batch\n     */\n    fun circle(position: Vector2, radius: Double) {\n        entries.add(Entry(fill, stroke, strokeWeight, position.xy0, Vector2(radius, radius)))\n    }\n\n    /**\n     * Add a circle to the batch\n     */\n    fun circle(circle: Circle) {\n        entries.add(Entry(fill, stroke, strokeWeight, circle.center.xy0, Vector2(circle.radius, circle.radius)))\n    }\n\n    /**\n     * Add a circle to the batch\n     */\n    fun circles(circles: List<Circle>) {\n        for (circle in circles) {\n            circle(circle)\n        }\n    }\n\n    /**\n     * Add circles to the batch\n     */\n    fun circles(centers: List<Vector2>, radius: Double) {\n        for (center in centers) {\n            entries.add(Entry(fill, stroke, strokeWeight, center.xy0, Vector2(radius, radius)))\n        }\n    }\n\n    /**\n     * Add circles to the batch\n     */\n    fun circles(centers: List<Vector2>, radii: List<Double>) {\n        require(centers.size == radii.size)\n        for (i in centers.indices) {\n            entries.add(Entry(fill, stroke, strokeWeight, centers[i].xy0, Vector2(radii[i], radii[i])))\n        }\n    }\n\n    /**\n     * Generate the stored batch\n     */\n    fun batch(existingBatch: CircleBatch? = null): CircleBatch {\n        val geometry = existingBatch?.geometry ?: vertexBuffer(circleFormat, entries.size)\n        geometry.put {\n            for (entry in entries) {\n                write(entry.offset)\n                write(entry.radius)\n            }\n        }\n\n        val drawStyle = existingBatch?.drawStyle ?: vertexBuffer(drawStyleFormat, entries.size)\n        drawStyle.put {\n            for (entry in entries) {\n                write(entry.fill ?: ColorRGBa.TRANSPARENT)\n                write(entry.stroke ?: ColorRGBa.TRANSPARENT)\n                write(if (entry.stroke == null || entry.stroke.alpha == 0.0) 0.0f else entry.strokeWeight.toFloat())\n            }\n        }\n        return existingBatch ?: CircleBatch(geometry, drawStyle)\n    }\n}\n\n/**\n * Create a stored batch of circles\n */\nfun Drawer.circleBatch(build: CircleBatchBuilder.() -> Unit): CircleBatch {\n    val circleBatchBuilder = CircleBatchBuilder(this)\n    circleBatchBuilder.build()\n    return circleBatchBuilder.batch()\n}\n\n\nclass RectangleBatch(val geometry: VertexBuffer, val drawStyle: VertexBuffer) {\n    init {\n        require(geometry.vertexFormat == rectangleFormat)\n        require(drawStyle.vertexFormat == drawStyleFormat)\n        require(geometry.vertexCount == drawStyle.vertexCount)\n    }\n\n    val size\n        get() = geometry.vertexCount\n\n    companion object {\n        fun create(size: Int, session: Session? = Session.active): RectangleBatch {\n            return RectangleBatch(vertexBuffer(rectangleFormat, size, session), vertexBuffer(drawStyleFormat, size, session))\n        }\n    }\n\n    /**\n     * Destroy the stored batch\n     */\n    fun destroy() {\n        geometry.destroy()\n        drawStyle.destroy()\n    }\n}\n\n\nclass RectangleBatchBuilder(drawer: Drawer) : BatchBuilder(drawer) {\n    class Entry(\n            val fill: ColorRGBa?,\n            val stroke: ColorRGBa?,\n            val strokeWeight: Double,\n            val offset: Vector3,\n            val dimensions: Vector2,\n            val rotation: Double\n    )\n\n    val entries = mutableListOf<Entry>()\n\n    fun rectangle(x: Double, y: Double, width: Double, height: Double, rotationInDegrees: Double = 0.0) {\n        entries.add(Entry(fill, stroke, strokeWeight, Vector3(x, y, 0.0), Vector2(width, height), rotationInDegrees))\n    }\n\n    fun rectangle(corner: Vector2, width: Double, height: Double, rotationInDegrees: Double = 0.0) {\n        entries.add(Entry(fill, stroke, strokeWeight, corner.xy0, Vector2(width, height), rotationInDegrees))\n    }\n\n    fun rectangle(rectangle: Rectangle, rotationInDegrees: Double = 0.0) {\n        entries.add(Entry(fill, stroke, strokeWeight, rectangle.corner.xy0, Vector2(rectangle.width, rectangle.height), rotationInDegrees))\n    }\n\n    fun rectangles(rectangles: List<Rectangle>) {\n        for (rectangle in rectangles) {\n            rectangle(rectangle)\n        }\n    }\n\n    /**\n     * Generate the stored batch\n     */\n    fun batch(existingBatch: RectangleBatch? = null): RectangleBatch {\n        val geometry = existingBatch?.geometry ?: vertexBuffer(rectangleFormat, entries.size)\n        geometry.put {\n            for (entry in entries) {\n                write(entry.offset)\n                write(entry.dimensions)\n                write(entry.rotation.toFloat())\n            }\n        }\n\n        val drawStyle = existingBatch?.drawStyle ?: vertexBuffer(drawStyleFormat, entries.size)\n        drawStyle.put {\n            for (entry in entries) {\n                write(entry.fill ?: ColorRGBa.TRANSPARENT)\n                write(entry.stroke ?: ColorRGBa.TRANSPARENT)\n                write(if (entry.stroke == null) 0.0f else entry.strokeWeight.toFloat())\n            }\n        }\n        return existingBatch ?: RectangleBatch(geometry, drawStyle)\n    }\n}\n\n/**\n * Create a stored batch of rectangles\n */\nfun Drawer.rectangleBatch(build: RectangleBatchBuilder.() -> Unit): RectangleBatch {\n    val rectangleBatchBuilder = RectangleBatchBuilder(this)\n    rectangleBatchBuilder.build()\n    return rectangleBatchBuilder.batch()\n}\n\nclass PointBatch(val geometry: VertexBuffer, val drawStyle: VertexBuffer) {\n    init {\n        require(geometry.vertexFormat == pointFormat)\n        require(drawStyle.vertexFormat == drawStyleFormat)\n        require(geometry.vertexCount == drawStyle.vertexCount)\n    }\n\n    val size\n        get() = geometry.vertexCount\n\n    companion object {\n        fun create(size: Int, session: Session? = Session.active): PointBatch {\n            return PointBatch(vertexBuffer(pointFormat, size, session), vertexBuffer(drawStyleFormat, size, session))\n        }\n    }\n\n    /**\n     * Destroy the stored batch\n     */\n    fun destroy() {\n        geometry.destroy()\n        drawStyle.destroy()\n    }\n}\n\n/**\n* Create a stored batch of points\n*/\nfun Drawer.pointBatch(build: PointBatchBuilder.() -> Unit): PointBatch {\n    val pointBatchBuilder = PointBatchBuilder(this)\n    pointBatchBuilder.build()\n    return pointBatchBuilder.batch()\n}\n\n\nclass PointBatchBuilder(drawer: Drawer) : BatchBuilder(drawer) {\n    class Entry(\n            val fill: ColorRGBa?,\n            val offset: Vector3\n    )\n\n    val entries = mutableListOf<Entry>()\n\n    fun point(x: Double, y: Double) {\n        entries.add(Entry(fill, Vector3(x, y, 0.0)))\n    }\n\n    fun point(x: Double, y: Double, z: Double) {\n        entries.add(Entry(fill, Vector3(x, y, z)))\n    }\n\n    fun point(position: Vector2) {\n        entries.add(Entry(fill, position.xy0))\n    }\n\n    fun point(position: Vector3) {\n        entries.add(Entry(fill, position))\n    }\n\n    @JvmName(\"points3D\")\n    fun points(positions: List<Vector3>) {\n        for (position in positions) {\n            point(position)\n        }\n    }\n    @JvmName(\"points2D\")\n    fun points(positions: List<Vector2>) {\n        for (position in positions) {\n            point(position)\n        }\n    }\n\n\n    /**\n     * Generate the stored batch\n     */\n    fun batch(existingBatch: PointBatch? = null): PointBatch {\n        val geometry = existingBatch?.geometry ?: vertexBuffer(pointFormat, entries.size)\n        geometry.put {\n            for (entry in entries) {\n                write(entry.offset)\n            }\n        }\n\n        val drawStyle = existingBatch?.drawStyle ?: vertexBuffer(drawStyleFormat, entries.size)\n        drawStyle.put {\n            for (entry in entries) {\n                write(entry.fill ?: ColorRGBa.TRANSPARENT)\n                write(entry.fill ?: ColorRGBa.TRANSPARENT)\n                write(1.0f)\n            }\n        }\n        return existingBatch ?: PointBatch(geometry, drawStyle)\n    }\n}","package org.openrndr.draw\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.internal.Driver\nimport org.openrndr.internal.ImageDriver\nimport org.openrndr.shape.IntRectangle\nimport org.openrndr.shape.Rectangle\nimport org.openrndr.utils.buffer.MPPBuffer\n\n\n/**\n * Buffer multisample options\n */\nsealed class BufferMultisample {\n    /**\n     * Disable multisampling\n     */\n    object Disabled : BufferMultisample() {\n        override fun toString(): String {\n            return \"Disabled()\"\n        }\n    }\n\n    /**\n     * Enable multisampling with a given [sampleCount]\n     */\n    data class SampleCount(val sampleCount: Int) : BufferMultisample()\n}\n\n\n/**\n * Texture wrapping mode\n */\nenum class WrapMode {\n    CLAMP_TO_EDGE,\n    REPEAT,\n    MIRRORED_REPEAT\n}\n\n/**\n * Texture filters used for minification\n */\nenum class MinifyingFilter {\n    NEAREST,\n    LINEAR,\n    NEAREST_MIPMAP_NEAREST,\n    LINEAR_MIPMAP_NEAREST,\n    NEAREST_MIPMAP_LINEAR,\n    LINEAR_MIPMAP_LINEAR\n}\n\n/**\n * Texture filters for magnification\n */\nenum class MagnifyingFilter {\n    /** nearest neighbour, blocky */\n    NEAREST,\n    LINEAR\n}\n\n\nexpect abstract class ColorBuffer {\n    abstract val session: Session?\n\n    /** the width of the [ColorBuffer] in device units */\n    abstract val width: Int\n\n    /** the height of the [ColorBuffer] in device units */\n    abstract val height: Int\n\n    /** the content scale of the [ColorBuffer] */\n    abstract val contentScale: Double\n\n    /**\n     * the [ColorFormat] of the image stored in the [ColorBuffer]\n     */\n    abstract val format: ColorFormat\n\n    /**\n     * the [ColorType] of the image stored in the [ColorBuffer]\n     */\n    abstract val type: ColorType\n\n    /** the number of mipmap levels */\n    abstract val levels: Int\n\n    /** the multisampling method used for this [ColorBuffer] */\n    abstract val multisample: BufferMultisample\n\n    /** the width of the [ColorBuffer] in pixels */\n    val effectiveWidth: Int\n\n    /** the height of the [ColorBuffer] in pixels */\n    val effectiveHeight: Int\n\n    val bounds: Rectangle\n\n    /** permanently destroy the underlying [ColorBuffer] resources, [ColorBuffer] can not be used after it is destroyed */\n    abstract fun destroy()\n\n    /** bind the colorbuffer to a texture unit, internal API */\n    abstract fun bind(unit: Int)\n\n\n    /** generates mipmaps from the top-level mipmap */\n    abstract fun generateMipmaps()\n\n    /**\n     * write the contents from [sourceBuffer] to the [ColorBuffer], potentially with format and type conversions\n     *\n     * @param sourceBuffer a [MPPBuffer] holding raw image data\n     * @param sourceFormat the [ColorFormat] that is used for the image data stored in [sourceBuffer], default is [ColorBuffer.format]\n     * @param sourceType the [ColorType] that is used for the image data stored in [sourceBuffer], default is [ColorBuffer.type]\n     * @param level the mipmap-level of [ColorBuffer] to write to\n     */\n    abstract fun write(\n        sourceBuffer: MPPBuffer,\n        sourceFormat: ColorFormat = format,\n        sourceType: ColorType = type,\n        x: Int = 0,\n        y: Int = 0,\n        width: Int = effectiveWidth,\n        height: Int = effectiveHeight,\n        level: Int = 0\n    )\n\n    /** the (unitless?) degree of anisotropy to be used in filtering */\n    abstract var anisotropy: Double\n\n    /**\n     * should the v coordinate be flipped because the [ColorBuffer] contents are stored upside-down?\n     */\n    abstract var flipV: Boolean\n\n\n    /** the wrapping mode to use in the horizontal direction */\n    abstract var wrapU: WrapMode\n\n    /** the wrapping mode to use in the vertical direction */\n    abstract var wrapV: WrapMode\n\n    abstract fun filter(filterMin: MinifyingFilter, filterMag: MagnifyingFilter)\n\n\n//    abstract fun copyTo(\n//        target: ColorBuffer,\n//        fromLevel: Int = 0,\n//        toLevel: Int = 0,\n//        sourceRectangle: IntRectangle = IntRectangle(\n//            0,\n//            0,\n//            this.effectiveWidth / (1 shl fromLevel),\n//            this.effectiveHeight / (1 shl fromLevel)\n//        ),\n//        targetRectangle: IntRectangle = IntRectangle(\n//            0,\n//            0,\n//            sourceRectangle.width,\n//            sourceRectangle.height\n//        ),\n//        filter: MagnifyingFilter = MagnifyingFilter.NEAREST\n//    )\n\n    // TODO restore default arguments when https://youtrack.jetbrains.com/issue/KT-45542 is fixed\n    abstract fun copyTo(\n        target: ColorBuffer,\n        fromLevel: Int = 0,\n        toLevel: Int = 0,\n        sourceRectangle: IntRectangle,\n        targetRectangle: IntRectangle,\n        filter: MagnifyingFilter = MagnifyingFilter.NEAREST\n    )\n\n    abstract fun copyTo(\n        target: ColorBuffer,\n        fromLevel: Int = 0,\n        toLevel: Int = 0,\n        filter: MagnifyingFilter = MagnifyingFilter.NEAREST\n    )\n\n\n    /**\n     * copies contents to a target array texture\n     * @param target the color buffer to which contents will be copied\n     * @param layer the array layer from which will be copied\n     * @param fromLevel the mip-map level from which will be copied\n     * @param toLevel the mip-map level of [target] to which will be copied\n     */\n    abstract fun copyTo(target: ArrayTexture, layer: Int, fromLevel: Int = 0, toLevel: Int = 0)\n\n    /**\n     * sets all pixels in the color buffer to [color]\n     * @param color the color used for filling\n     */\n    abstract fun fill(color: ColorRGBa)\n}\n\n\n/**\n * create a [ColorBuffer]\n * @param width the width in device units\n * @param height the height in device units\n * @param contentScale content scale used for denoting hi-dpi content\n * @param format the color format\n * @param type the color type\n * @param multisample multisampling mode to use\n * @param format the color format\n * @param levels the number of mip-map levels\n * @param session the [Session] that should track this color buffer\n */\nfun colorBuffer(\n    width: Int,\n    height: Int,\n    contentScale: Double = 1.0,\n    format: ColorFormat = ColorFormat.RGBa,\n    type: ColorType = ColorType.UINT8,\n    multisample: BufferMultisample = BufferMultisample.Disabled,\n    levels: Int = 1,\n    session: Session? = Session.active\n): ColorBuffer {\n    return Driver.instance.createColorBuffer(width, height, contentScale, format, type, multisample, levels, session)\n}\n\n\n/**\n * check if this [ColorBuffer] is equivalent to [other]\n * @param other the [ColorBuffer] to check against\n * @param ignoreWidth ignore [ColorBuffer.width] in check when true\n * @param ignoreHeight ignore [ColorBuffer.height] in check when true\n * @param ignoreLevels ignore [ColorBuffer.levels] in check when true\n * @param ignoreContentScale ignore [ColorBuffer.contentScale] when true\n * @param ignoreMultisample ignore [ColorBuffer.multisample] in check when true\n * @param ignoreLevels ignore [ColorBuffer.levels] in check when true\n */\nfun ColorBuffer.isEquivalentTo(\n    other: ColorBuffer,\n    ignoreWidth: Boolean = false,\n    ignoreHeight: Boolean = false,\n    ignoreContentScale: Boolean = false,\n    ignoreFormat: Boolean = false,\n    ignoreType: Boolean = false,\n    ignoreMultisample: Boolean = false,\n    ignoreLevels: Boolean = false\n): Boolean {\n    return (ignoreWidth || width == other.width) &&\n            (ignoreHeight || height == other.height) &&\n            (ignoreContentScale || contentScale == other.contentScale) &&\n            (ignoreFormat || format == other.format) &&\n            (ignoreType || type == other.type) &&\n            (ignoreMultisample || multisample == other.multisample) &&\n            (ignoreLevels || levels == other.levels)\n}\n\n\n/**\n * create an equivalent [ColorBuffer], with the option to override attributes\n */\nfun ColorBuffer.createEquivalent(\n    width: Int = this.width,\n    height: Int = this.height,\n    contentScale: Double = this.contentScale,\n    format: ColorFormat = this.format,\n    type: ColorType = this.type,\n    multisample: BufferMultisample = this.multisample,\n    levels: Int = this.levels\n): ColorBuffer {\n    return colorBuffer(width, height, contentScale, format, type, multisample, levels)\n}\n\n/**\n * load an image from a file or url encoded as [String], also accepts base64 encoded data urls\n */\nexpect fun loadImage(\n    fileOrUrl: String,\n    formatHint: ImageFileFormat? = ImageFileFormat.guessFromExtension(fileOrUrl.split(\".\").last()),\n    session: Session? = Session.active\n): ColorBuffer\n\nfun loadImage(\n    buffer: MPPBuffer,\n    name: String? = null,\n    formatHint: ImageFileFormat? = null,\n    session: Session? = Session.active\n): ColorBuffer {\n    val data = ImageDriver.instance.loadImage(buffer, name, formatHint)\n    return try {\n        val cb = colorBuffer(data.width, data.height, 1.0, data.format, data.type, session = session)\n        cb.write(data.data ?: error(\"no data\") )\n        cb\n    } finally {\n        data.close()\n    }\n}\n\nexpect suspend fun loadImageSuspend(\n    fileOrUrl: String,\n    formatHint: ImageFileFormat? = null,\n    session: Session? = Session.active\n): ColorBuffer","package org.openrndr.draw\n\nimport org.openrndr.draw.font.BufferAccess\nimport org.openrndr.draw.font.BufferFlag\nimport org.openrndr.internal.Driver\nimport org.openrndr.math.IntVector3\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\n\ndata class ComputeStructure(\n    val structDefinitions: String? = null,\n    val uniforms: String? = null,\n    val buffers: String? = null,\n    val computeTransform: String,\n    val computePreamble: String,\n    val workGroupSize: IntVector3\n)\n\n\n/**\n * ComputeStyle class\n * @since 0.4.4\n */\nclass ComputeStyle : StyleParameters, StyleBufferBindings, StyleImageBindings {\n    var computePreamble: String = \"\"\n    var computeTransform: String = \"\"\n\n    override var textureBaseIndex: Int = 0\n\n    /**\n     * The size of the compute work group\n     */\n    var workGroupSize = IntVector3(1, 1, 1)\n    private var dirty = true\n    override var parameterValues: MutableMap<String, Any> = mutableMapOf()\n    override var parameterTypes: ObservableHashmap<String, String> = ObservableHashmap(mutableMapOf()) { dirty = true }\n\n    override var bufferValues = mutableMapOf<String, Any>()\n    override val buffers = mutableMapOf<String, String>()\n    override val bufferTypes = mutableMapOf<String, String>()\n    override val bufferAccess = mutableMapOf<String, BufferAccess>()\n    override val bufferFlags: MutableMap<String, Set<BufferFlag>> = mutableMapOf()\n\n    override val imageTypes: MutableMap<String, String> = mutableMapOf()\n    override val imageValues: MutableMap<String, Array<out ImageBinding>> = mutableMapOf()\n    override val imageAccess: MutableMap<String, ImageAccess> = mutableMapOf()\n    override val imageFlags: MutableMap<String, Set<ImageFlag>> = mutableMapOf()\n    override val imageArrayLength: MutableMap<String, Int> = mutableMapOf()\n}\n\n@OptIn(ExperimentalContracts::class)\nfun computeStyle(builder: ComputeStyle.() -> Unit): ComputeStyle {\n    contract {\n        callsInPlace(builder, InvocationKind.EXACTLY_ONCE)\n    }\n    val computeStyle = ComputeStyle()\n    computeStyle.builder()\n    return computeStyle\n}\n\nval computeStyleManager by lazy { Driver.instance.createComputeStyleManager() }\nfun ComputeStyle.execute(width: Int = 1, height: Int = 1, depth: Int = 1) {\n    val cs = computeStyleManager.shader(this, \"compute-style\")\n    cs.execute(width, height, depth)\n}\n\n","@file:JvmName(\"CubemapFunctions\")\npackage org.openrndr.draw\n\nimport org.openrndr.internal.CubemapImageData\nimport org.openrndr.internal.Driver\nimport org.openrndr.math.Vector3\nimport org.openrndr.utils.buffer.MPPBuffer\nimport kotlin.jvm.JvmName\n\nenum class CubemapSide(val forward: Vector3, val up: Vector3) {\n    POSITIVE_X(Vector3.UNIT_X, -Vector3.UNIT_Y),\n    NEGATIVE_X(-Vector3.UNIT_X, -Vector3.UNIT_Y),\n    POSITIVE_Y(Vector3.UNIT_Y, Vector3.UNIT_Z),\n    NEGATIVE_Y(-Vector3.UNIT_Y, -Vector3.UNIT_Z),\n    POSITIVE_Z(Vector3.UNIT_Z, -Vector3.UNIT_Y),\n    NEGATIVE_Z(-Vector3.UNIT_Z, -Vector3.UNIT_Y)\n    ;\n\n    val right\n        get() = forward cross up\n}\n\nexpect interface Cubemap {\n    val session: Session?\n\n    val width: Int\n    val format: ColorFormat\n    val type: ColorType\n    val levels: Int\n\n    fun copyTo(target: ArrayCubemap, layer: Int, fromLevel: Int = 0, toLevel: Int = 0)\n    fun copyTo(target: Cubemap, fromLevel: Int = 0, toLevel: Int = 0)\n    fun copyTo(target: ColorBuffer, fromSide: CubemapSide, fromLevel: Int = 0, toLevel: Int = 0)\n\n    fun filter(min: MinifyingFilter, mag: MagnifyingFilter)\n    fun bind(textureUnit: Int = 0)\n    fun generateMipmaps()\n    fun destroy()\n\n    fun write(\n        side: CubemapSide,\n        source: MPPBuffer,\n        sourceFormat: ColorFormat,\n        sourceType: ColorType,\n        x: Int,\n        y: Int,\n        width: Int,\n        height: Int,\n        level: Int\n    )\n}\n\nfun cubemap(\n    width: Int,\n    format: ColorFormat = ColorFormat.RGBa,\n    type: ColorType = ColorType.UINT8,\n    levels: Int = 1,\n    session: Session? = Session.active\n) : Cubemap {\n    return Driver.instance.createCubemap(width, format, type, levels, session)\n}\n\n\nfun loadCubemap(data: CubemapImageData, session: Session? = Session.active): Cubemap {\n    try {\n        val cm = cubemap(data.width, data.format, data.type, data.mipmaps, session)\n        for (level in 0 until data.mipmaps) {\n            val levelWidth = data.width / (1 shl level)\n            for (side in CubemapSide.entries) {\n                cm.write(\n                    side,\n                    data.side(side, level),\n                    data.format,\n                    data.type,\n                    x = 0,\n                    y = 0,\n                    width = levelWidth,\n                    height = levelWidth,\n                    level = level\n                )\n            }\n        }\n        if (data.mipmaps == 1) {\n            cm.generateMipmaps()\n        }\n        cm.filter(MinifyingFilter.LINEAR_MIPMAP_LINEAR, MagnifyingFilter.LINEAR)\n        return cm\n    } finally {\n        data.close()\n    }\n}","package org.openrndr.draw\n\nimport org.openrndr.internal.Driver\n\ninterface DepthBuffer {\n    val session: Session?\n    val width: Int\n    val height: Int\n    val format: DepthFormat\n    val multisample: BufferMultisample\n\n    val hasDepth: Boolean\n        get() = format.hasDepth\n\n    val hasStencil: Boolean\n        get() = format.hasStencil\n\n    fun resolveTo(target: DepthBuffer)\n    fun copyTo(target: DepthBuffer)\n    fun destroy()\n    fun bind(textureUnit: Int)\n}\n\nfun depthBuffer(\n    width: Int,\n    height: Int,\n    format: DepthFormat = DepthFormat.DEPTH24_STENCIL8,\n    multisample: BufferMultisample\n): DepthBuffer = Driver.instance.createDepthBuffer(width, height, format, multisample)\n","package org.openrndr.draw\n\nimport org.openrndr.internal.Driver\nimport org.openrndr.math.Matrix44\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.transforms.normalMatrix\n\nprivate var lastModel = Matrix44.IDENTITY\nprivate var lastModelNormal = Matrix44.IDENTITY\nprivate var lastView = Matrix44.IDENTITY\nprivate var lastViewNormal = Matrix44.IDENTITY\n\nvar contextBlocks = mutableMapOf<Long, UniformBlock?>()\nexpect val useContextBlock : Boolean\n\n\n@Suppress(\"MemberVisibilityCanPrivate\")\ndata class DrawContext(val model: Matrix44, val view: Matrix44, val projection: Matrix44, val width: Int, val height: Int, val contentScale: Double, val modelViewScalingFactor:Double) {\n    fun applyToShader(shader: Shader) {\n        if (!useContextBlock) {\n            if (shader.hasUniform(\"u_viewMatrix\")) {\n                shader.uniform(\"u_viewMatrix\", view)\n            }\n            if (shader.hasUniform(\"u_modelMatrix\")) {\n                shader.uniform(\"u_modelMatrix\", model)\n            }\n            if (shader.hasUniform(\"u_projectionMatrix\")) {\n                shader.uniform(\"u_projectionMatrix\", projection)\n            }\n            if (shader.hasUniform(\"u_viewDimensions\")) {\n                shader.uniform(\"u_viewDimensions\", Vector2(width.toDouble(), height.toDouble()))\n            }\n            if (shader.hasUniform(\"u_modelNormalMatrix\")) {\n                val normalMatrix = if (model === lastModel) lastModelNormal else {\n                    lastModelNormal = if (model !== Matrix44.IDENTITY) normalMatrix(model) else Matrix44.IDENTITY\n                    lastModel = model\n                    lastModelNormal\n                }\n                shader.uniform(\"u_modelNormalMatrix\", normalMatrix)\n            }\n            if (shader.hasUniform(\"u_viewNormalMatrix\")) {\n                val normalMatrix = if (view === lastView) lastViewNormal else {\n                    lastViewNormal = if (view !== Matrix44.IDENTITY) normalMatrix(view) else Matrix44.IDENTITY\n                    lastView = view\n                    lastViewNormal\n                }\n                shader.uniform(\"u_viewNormalMatrix\", normalMatrix)\n            }\n            if (shader.hasUniform(\"u_contentScale\")) {\n                shader.uniform(\"u_contentScale\", contentScale)\n            }\n\n            if (shader.hasUniform(\"u_modelViewScalingFactor\")) {\n                shader.uniform(\"u_modelViewScalingFactor\", modelViewScalingFactor)\n            }\n\n        } else {\n            val contextBlock = contextBlocks.getOrPut(Driver.instance.contextID) {\n                shader.createBlock(\"ContextBlock\")\n            }\n\n            contextBlock?.apply {\n                uniform(\"u_viewMatrix\", view)\n                uniform(\"u_modelMatrix\", model)\n                uniform(\"u_projectionMatrix\", projection)\n                uniform(\"u_viewDimensions\", Vector2(width.toDouble(), height.toDouble()))\n                run {\n                    val normalMatrix = if (model === lastModel) lastModelNormal else {\n                        lastModelNormal = if (model !== Matrix44.IDENTITY) normalMatrix(model) else Matrix44.IDENTITY\n                        lastModel = model\n                        lastModelNormal\n                    }\n                    uniform(\"u_modelNormalMatrix\", normalMatrix)\n                }\n                run {\n                    val normalMatrix = if (view === lastView) lastViewNormal else {\n                        lastViewNormal = if (view !== Matrix44.IDENTITY) normalMatrix(view) else Matrix44.IDENTITY\n                        lastView = view\n                        lastViewNormal\n                    }\n                    uniform(\"u_viewNormalMatrix\", normalMatrix)\n                }\n                uniform(\"u_contentScale\", contentScale.toFloat())\n                uniform(\"u_modelViewScalingFactor\", modelViewScalingFactor.toFloat())\n                if (dirty) {\n                    upload()\n                }\n                shader.block(\"ContextBlock\", this)\n            }\n        }\n    }\n}\n","package org.openrndr.draw\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.internal.Driver\nimport org.openrndr.math.Matrix55\nimport org.openrndr.shape.*\n\n/**\n * Line join enumeration\n */\nenum class LineJoin {\n    MITER,\n    BEVEL,\n    ROUND\n}\n\n/**\n * Line cap enumeration\n */\nenum class LineCap {\n    ROUND,\n    BUTT,\n    SQUARE\n}\n\n\n/**\n * Draw primitive type enumeration\n */\nenum class DrawPrimitive {\n    TRIANGLES,\n    TRIANGLE_STRIP,\n    TRIANGLE_FAN,\n    POINTS,\n    LINES,\n    LINE_STRIP,\n    LINE_LOOP,\n    PATCHES\n}\n\nenum class StencilTest {\n    NEVER,\n    LESS,\n    LESS_OR_EQUAL,\n    GREATER,\n    GREATER_OR_EQUAL,\n    EQUAL,\n    NOT_EQUAL,\n    ALWAYS,\n    DISABLED,\n}\n\nenum class StencilOperation {\n    KEEP,\n    ZERO,\n    REPLACE,\n    INCREASE,\n    INCREASE_WRAP,\n    DECREASE,\n    DECREASE_WRAP,\n    INVERT\n}\n\n/**\n * Depth format enumeration\n */\nenum class DepthFormat(val hasDepth: Boolean, val hasStencil: Boolean) {\n    /** 16 bit integer depth */\n    DEPTH16(true, false),\n    /** 24 bit integer depth */\n    DEPTH24(true, false),\n    /** 32 bit floating point depth */\n    DEPTH32F(true, false),\n    /** 24 bit integer depth plus 8 bit integer stencil */\n    DEPTH24_STENCIL8(true, true),\n    /** 32 bit float depth plus 8 bit integer stencil */\n    DEPTH32F_STENCIL8(true, true),\n\n    /** 8 bit integer stencil */\n    STENCIL8(false, true),\n\n    /** depth buffer and stencil buffer with unspecified types */\n    DEPTH_STENCIL(true, true),\n}\n\ndata class StencilStyle(\n    var stencilFailOperation: StencilOperation = StencilOperation.KEEP,\n    var depthFailOperation: StencilOperation = StencilOperation.KEEP,\n    var depthPassOperation: StencilOperation = StencilOperation.KEEP,\n    var stencilTestMask: Int = 0xff,\n    var stencilTestReference: Int = 0,\n    var stencilWriteMask: Int = 0xff,\n    var stencilTest: StencilTest = StencilTest.DISABLED) {\n\n    fun stencilFunc(stencilTest: StencilTest, testReference: Int, writeMask: Int) {\n        this.stencilTest = stencilTest\n        this.stencilTestReference = testReference\n        this.stencilWriteMask = writeMask\n    }\n\n    fun stencilOp(onStencilTestFail: StencilOperation, onDepthTestFail: StencilOperation, onDepthTestPass: StencilOperation) {\n        stencilFailOperation = onStencilTestFail\n        depthFailOperation = onDepthTestFail\n        depthPassOperation = onDepthTestPass\n    }\n}\n\n\n/**\n * Color format enumeration\n */\n@Suppress(\"EnumEntryName\")\nenum class ColorFormat {\n    /** Format with a single component (red)*/\n    R,\n    /** Format with two components (red, green)*/\n    RG,\n    /** Format with three components (red, green, blue)*/\n    RGB,\n    /** Format with three components in reverse order (blue, green, red)*/\n    BGR,\n    /** Format with four components (red, green, blue, alpha)*/\n    RGBa,\n    /** Format with four components in reverse order (blue, green, red, alpha)*/\n    BGRa,\n    /** Format with three components (red, green, blue) in sRGB space*/\n    sRGB,\n    /** Format with four components (red, green, blue, alpha) in sRGB space*/\n    sRGBa;\n\n    /**\n     * The number of (color) components in the format\n     */\n    val componentCount: Int\n        get() {\n            return when (this) {\n                R -> 1\n                RG -> 2\n                BGR, RGB, sRGB -> 3\n                BGRa, RGBa, sRGBa -> 4\n            }\n        }\n}\n\n/**\n * Color sampling enumeration\n */\nenum class ColorSampling {\n    /** Normalized between 0 and 1 */\n    NORMALIZED,\n    UNSIGNED_INTEGER,\n    SIGNED_INTEGER\n}\n\n/**\n * Color type enumeration\n */\nenum class ColorType {\n    /** unsigned 8 bit integer type */\n    UINT8,\n    /** unsigned 16 bit integer type */\n    UINT16,\n    /** unsigned 8 bit integer type, with integer sampler */\n    UINT8_INT,\n    /** unsigned 16 bit integer type, with integer sampler */\n    UINT16_INT,\n    /** unsigned 32 bit integer type, with integer sampler */\n    UINT32_INT,\n    /** signed 8 bit integer type, with integer sampler */\n    SINT8_INT,\n    /** signed 16 bit integer type, with integer sampler */\n    SINT16_INT,\n    /** signed 32 bit integer type, with integer sampler */\n    SINT32_INT,\n    /** 16-bit float type, or half precision float type */\n    FLOAT16,\n    /** 32-bit float type, or single precision float type */\n    FLOAT32,\n    /** Compressed in DXT1 format */\n    DXT1,\n    /** Compressed in DXT3 format */\n    DXT3,\n    /** Compressed in DXT5 format */\n    DXT5,\n    /** Compressed in unsigned normalized BPTC format */\n    BPTC_UNORM,\n    /** Compressed in floating point BPTC format */\n    BPTC_FLOAT,\n    /** Compressed in unsigned floating point BPTC format */\n    BPTC_UFLOAT;\n\n    /**\n     * The type of color sampler to use for this color type\n     */\n    val colorSampling: ColorSampling\n        get() {\n            return when (this) {\n                UINT32_INT, UINT8_INT, UINT16_INT -> ColorSampling.UNSIGNED_INTEGER\n                SINT32_INT, SINT16_INT, SINT8_INT -> ColorSampling.SIGNED_INTEGER\n                else -> ColorSampling.NORMALIZED\n            }\n        }\n\n    /**\n     * The size (in bytes) for this color type\n     */\n    val componentSize: Int\n        get() {\n            return when (this) {\n                UINT8, UINT8_INT, SINT8_INT -> 1\n                UINT16, UINT16_INT, SINT16_INT, FLOAT16 -> 2\n                UINT32_INT, SINT32_INT, FLOAT32 -> 4\n                DXT1, DXT3, DXT5,\n                BPTC_UNORM, BPTC_FLOAT, BPTC_UFLOAT -> throw RuntimeException(\"component size of compressed types cannot be queried\")\n            }\n        }\n\n    /**\n     * Specifies if this is a compressed format\n     */\n    val compressed: Boolean\n        get() {\n            return when (this) {\n                DXT1, DXT3, DXT5, BPTC_UNORM, BPTC_FLOAT, BPTC_UFLOAT -> true\n                else -> false\n            }\n        }\n\n    val isFloat: Boolean\n        get() {\n            return when (this) {\n                FLOAT16, FLOAT32, BPTC_FLOAT, BPTC_UFLOAT -> true\n                else -> false\n            }\n        }\n\n}\n\n/**\n * Cull test pass condition enumeration\n */\nenum class CullTestPass {\n    /** Cull test should always pass */\n    ALWAYS,\n    FRONT,\n    BACK,\n    NEVER\n}\n\n/**\n * Depth test pass condition enumeration\n */\nenum class DepthTestPass {\n    /** Depth test should always pass */\n    ALWAYS,\n    /** Depth test will only pass when the test value is less than the target value */\n    LESS,\n    /** Depth test will only pass when the test value is less than or equal to the target value */\n    LESS_OR_EQUAL,\n    /** Depth test will only pass when the test value is equal to the target value */\n    EQUAL,\n    /** Depth test will only pass when the test value is greater than the target value */\n    GREATER,\n    /** Depth test will only pass when the test value is greater than or equal to the target value */\n    GREATER_OR_EQUAL,\n    /** Depth test will never pass, thus always fail */\n    NEVER\n}\n\n/**\n * Used for controlling how pixels are blended together. The different modes\n * can be used to simulate different kinds of effects like transparency,\n * adding light, subtracting color and others.\n */\nenum class BlendMode {\n    OVER,\n    BLEND,\n    ADD,\n    SUBTRACT,\n    MULTIPLY,\n    REPLACE,\n    REMOVE,\n    MIN,\n    MAX\n}\n\n\nenum class KernMode {\n    DISABLED,\n    METRIC\n}\n\nenum class TextSettingMode {\n    PIXEL,\n    SUBPIXEL\n}\n\n@Suppress(\"unused\")\ndata class ChannelMask(val red: Boolean, val green: Boolean, val blue: Boolean, val alpha: Boolean) {\n    companion object {\n        const val RED = 1\n        const val GREEN = 2\n        const val BLUE = 4\n        const val ALPHA = 8\n        val NONE = ChannelMask(red = false, green = false, blue = false, alpha = false)\n        val ALL = ChannelMask(red = true, green = true, blue = true, alpha = true)\n    }\n}\n\n/**\n * Specifies if to optimize drawing for quality or performance.\n */\nenum class DrawQuality {\n    QUALITY,\n    PERFORMANCE\n}\n\n\n\nvar styleBlocks = mutableMapOf<Long, UniformBlock?>()\nexpect val useStyleBlock : Boolean\n\n/**\n * A data class that controls the look of\n * drawing operations including stroke and fill color, stroke\n * weight and more.\n */\ndata class DrawStyle(\n    /** Clipping rectangle, set to null for no clipping */\n    var clip: Rectangle? = null,\n\n    /** Fill color, set to null for no fill */\n    var fill: ColorRGBa? = ColorRGBa.WHITE,\n\n    /** Stroke color, set to null for no stroke */\n    var stroke: ColorRGBa? = ColorRGBa.BLACK,\n\n    var lineCap: LineCap = LineCap.BUTT,\n    var lineJoin: LineJoin = LineJoin.MITER,\n\n    var strokeWeight: Double = 1.0,\n    var smooth: Boolean = true,\n    var miterLimit: Double = 4.0,\n\n    var quality: DrawQuality = DrawQuality.QUALITY,\n\n    var depthTestPass: DepthTestPass = DepthTestPass.ALWAYS,\n    var depthWrite: Boolean = false,\n    var blendMode: BlendMode = BlendMode.OVER,\n    var cullTestPass: CullTestPass = CullTestPass.ALWAYS,\n    var channelWriteMask: ChannelMask = ChannelMask(red = true, green = true, blue = true, alpha = true),\n\n    /** Use alpha to coverage in rendering, used in multi-sampling modes */\n    var alphaToCoverage: Boolean = false,\n\n    var shadeStyle: ShadeStyle? = null,\n    var fontMap: FontMap? = null,\n    var kerning: KernMode = KernMode.METRIC,\n    var textSetting: TextSettingMode = TextSettingMode.SUBPIXEL,\n\n    var stencil: StencilStyle = StencilStyle(),\n    var frontStencil: StencilStyle = stencil,\n    var backStencil: StencilStyle = stencil,\n\n    var colorMatrix: Matrix55 = Matrix55.IDENTITY\n) {\n\n    fun applyToShader(shader: Shader) {\n        if (!useStyleBlock) {\n            if (shader.hasUniform(\"u_fill\")) {\n                shader.uniform(\"u_fill\", fill ?: ColorRGBa.TRANSPARENT)\n            }\n\n            if (shader.hasUniform(\"u_stroke\")) {\n                shader.uniform(\"u_stroke\", stroke ?: ColorRGBa.TRANSPARENT)\n            }\n\n            if (shader.hasUniform(\"u_strokeWeight\")) {\n                shader.uniform(\"u_strokeWeight\", if (stroke != null) strokeWeight else 0.0)\n            }\n\n            if (shader.hasUniform(\"u_colorMatrix\")) {\n                shader.uniform(\"u_colorMatrix\", colorMatrix.floatArray)\n            }\n        } else {\n            val styleBlock = styleBlocks.getOrPut(Driver.instance.contextID) {\n//                println(\"heyy ${Driver.instance.contextID}\")\n//                logger.trace { \"creating styleblock UBO for ${Driver.instance.contextID}\" }\n                val styleBlock = shader.createBlock(\"StyleBlock\")\n                styleBlock\n            }\n\n            styleBlock?.apply {\n                uniform(\"u_fill\", fill ?: ColorRGBa.TRANSPARENT)\n                uniform(\"u_stroke\", stroke ?: ColorRGBa.TRANSPARENT)\n                uniform(\"u_strokeWeight\", strokeWeight.toFloat())\n                uniform(\"u_colorMatrix\", colorMatrix)\n                shader.block(\"StyleBlock\", this)\n                if (dirty) {\n                    upload()\n                }\n            }\n        }\n    }\n}\n","@file:Suppress(\"unused\")\n\npackage org.openrndr.draw\n\nimport org.openrndr.shape.Circle\nimport org.openrndr.shape.Path3D\nimport org.openrndr.shape.Segment3D\nimport org.openrndr.shape.ShapeTopology\nimport org.openrndr.collections.pop\nimport org.openrndr.collections.push\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.internal.*\nimport org.openrndr.math.Matrix44\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.Vector3\nimport org.openrndr.math.transforms.rotate\nimport org.openrndr.math.transforms.rotateZ\nimport org.openrndr.math.transforms.scale\nimport org.openrndr.math.transforms.translate\nimport org.openrndr.shape.*\nimport kotlin.jvm.JvmName\nimport org.openrndr.shape.Rectangle\nimport org.openrndr.shape.Shape\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.contract\nimport kotlin.math.abs\nimport kotlin.math.log2\nimport kotlin.reflect.KMutableProperty0\nimport org.openrndr.math.transforms.lookAt as _lookAt\nimport org.openrndr.math.transforms.ortho as _ortho\nimport org.openrndr.math.transforms.perspective as _perspective\n\n\n\n\n@Suppress(\"MemberVisibilityCanPrivate\")\n\nenum class TransformTarget {\n    MODEL,\n    VIEW,\n    PROJECTION\n}\n\n\n\n/**\n * The Drawer\n */\n@Suppress(\"MemberVisibilityCanPrivate\", \"unused\")\nclass Drawer(val driver: Driver) {\n\n    /**\n     * The bounds of the drawable area as a [Rectangle]\n     */\n    val bounds: Rectangle\n        get() = Rectangle(Vector2(0.0, 0.0), width * 1.0, height * 1.0)\n\n    private val drawStyles = ArrayDeque<DrawStyle>().apply {\n        addLast(DrawStyle())\n    }\n    private var rectangleDrawer = RectangleDrawer()\n    private var vertexBufferDrawer = VertexBufferDrawer()\n\n\n    private var circleDrawer = CircleDrawer()\n    private var pointDrawer = PointDrawer()\n    private var imageDrawer = ImageDrawer()\n    private var fastLineDrawer = PerformanceLineDrawer()\n    private val meshLineDrawer by lazy { MeshLineDrawer() }\n    private var qualityLineDrawer = QualityLineDrawer()\n    private var qualityPolygonDrawer = QualityPolygonDrawer()\n    val fontImageMapDrawer = FontImageMapDrawer()\n\n    private val modelStack = ArrayDeque<Matrix44>()\n    private val viewStack = ArrayDeque<Matrix44>()\n    private val projectionStack = ArrayDeque<Matrix44>()\n\n    val width: Int get() = RenderTarget.active.width\n    val height: Int get() = RenderTarget.active.height\n\n    private var modelViewScalingFactor = 1.0\n    private val modelViewScaling: Double\n    get() {\n        return modelViewScalingFactor * RenderTarget.active.contentScale\n    }\n\n    /** The active model matrix */\n    var model: Matrix44 = Matrix44.IDENTITY\n        set(value) {\n            field = value\n            modelViewScalingFactor = ((view * model).matrix33 * Vector3.UNIT_XYZ).length\n        }\n\n    /** The active view matrix */\n    var view: Matrix44 = Matrix44.IDENTITY\n        set(value) {\n            field = value\n            modelViewScalingFactor = ((view * model).matrix33 * Vector3.UNIT_XYZ).length\n        }\n\n\n    /** The active projection matrix */\n    var projection: Matrix44 = Matrix44.IDENTITY\n\n    /**\n     * The draw context holds references to model, view, projection matrices, width, height and content-scale\n     */\n    val context: DrawContext\n        get() = DrawContext(model, view, projection, RenderTarget.active.width, RenderTarget.active.height, RenderTarget.active.contentScale, modelViewScalingFactor)\n\n    var drawStyle = DrawStyle()\n    /** The active draw style */\n\n    /**\n     * @see isolatedWithTarget\n     * @see isolated\n     */\n    fun withTarget(target: RenderTarget, action: Drawer.() -> Unit) {\n        target.bind()\n        this.action()\n        target.unbind()\n    }\n\n    /**\n     *  Resets state stacks and load default values for draw style and transformations.\n     *  This destroys the state stacks, consider using defaults() instead of reset()\n     *  @see defaults\n     */\n    @Deprecated(\"reset is considered harmful, use defaults()\")\n    fun reset() {\n        viewStack.clear()\n        modelStack.clear()\n        projectionStack.clear()\n        drawStyles.clear()\n        defaults()\n    }\n\n    /**\n     * Loads default values for draw style and transformations\n     */\n    fun defaults() {\n        drawStyle = DrawStyle()\n        ortho()\n        view = Matrix44.IDENTITY\n        model = Matrix44.IDENTITY\n    }\n\n    /**\n     * Sets the [projection] matrix to orthogonal using the sizes of a [RenderTarget]\n     * @param renderTarget the render target to take the sizes from\n     */\n    fun ortho(renderTarget: RenderTarget) {\n        ortho(0.0, renderTarget.width.toDouble(), renderTarget.height.toDouble(), 0.0, -1.0, 1.0)\n    }\n\n    /**\n     * Sets the [projection] matrix to orthogonal using the drawer's current size\n     */\n    fun ortho() {\n        ortho(0.0, width.toDouble(), height.toDouble(), 0.0, -1.0, 1.0)\n    }\n\n    /**\n     * Sets the [projection] matrix to orthogonal using [left], [right], [bottom], [top], [near], [far]\n     * @param left left value\n     * @param right right value\n     * @param bottom bottom value\n     * @param top top value\n     * @param near near value\n     * @param far far value\n     * @see perspective\n     */\n    fun ortho(left: Double, right: Double, bottom: Double, top: Double, near: Double, far: Double) {\n        projection = _ortho(left, right, bottom, top, near, far)\n    }\n\n    /**\n     *  Sets the projection to a perspective projection matrix\n     *\n     *  [fovY] Y field of view in degrees\n     *  [aspectRatio] lens aspect aspectRatio\n     *  [zNear] The distance to the zNear clipping plane along the -Z axis.\n     *  [zFar]The distance to the zFar clipping plane along the -Z axis.\n     *  @see ortho\n     */\n    fun perspective(fovY: Double, aspectRatio: Double, zNear: Double, zFar: Double) {\n        projection = _perspective(fovY, aspectRatio, zNear, zFar)\n    }\n\n    fun lookAt(from: Vector3, to: Vector3, up: Vector3 = Vector3.UNIT_Y, target: TransformTarget = TransformTarget.VIEW) {\n        transform(target) *= _lookAt(from, to, up)\n    }\n\n    /**\n     * Apply a uniform scale to the model matrix\n     * @param s the scaling factor\n     */\n    fun scale(s: Double, target: TransformTarget = TransformTarget.MODEL) {\n        transform(target) *= Matrix44.scale(s, s, s)\n    }\n\n    /**\n     * Applies non-uniform scale to the model matrix\n     * @param x the scaling factor for the x-axis\n     * @param y the scaling factor for the y-axis\n     */\n    fun scale(x: Double, y: Double, target: TransformTarget = TransformTarget.MODEL) {\n        transform(target) *= Matrix44.scale(x, y, 1.0)\n    }\n\n    /**\n     * Applies non-uniform scale to the model matrix\n     * @param x the scaling factor for the x-axis\n     * @param y the scaling factor for the y-axis\n     * @param z the scaling factor for the y-axis\n     * @see translate\n     * @see scale\n     */\n    fun scale(x: Double, y: Double, z: Double, target: TransformTarget = TransformTarget.MODEL) {\n        transform(target) *= Matrix44.scale(x, y, z)\n    }\n\n    /**\n     * Applies a two-dimensional translation to the model matrix\n     */\n    fun translate(t: Vector2, target: TransformTarget = TransformTarget.MODEL) {\n        transform(target) *= Matrix44.translate(t.vector3())\n    }\n\n    /**\n     * Applies three-dimensional translation to the model matrix\n     */\n    fun translate(t: Vector3, target: TransformTarget = TransformTarget.MODEL) {\n        transform(target) *= Matrix44.translate(t)\n    }\n\n    /**\n     * Applies a two-dimensional translation to the model matrix\n     */\n    fun translate(x: Double, y: Double, target: TransformTarget = TransformTarget.MODEL) {\n        translate(x, y, 0.0, target)\n    }\n\n    /**\n     * Applies a three-dimensional translation to the model matrix\n     */\n    fun translate(x: Double, y: Double, z: Double, target: TransformTarget = TransformTarget.MODEL) {\n        transform(target) *= Matrix44.translate(Vector3(x, y, z))\n    }\n\n    /**\n     * Applies a rotation over the z-axis to the model matrix\n     * @param rotationInDegrees the rotation in degrees\n     */\n    fun rotate(rotationInDegrees: Double, target: TransformTarget = TransformTarget.MODEL) {\n        transform(target) *= Matrix44.rotateZ(rotationInDegrees)\n    }\n\n    /**\n     * Applies a rotation over an arbitrary axis to the model matrix\n     * @param axis the axis to rotate over, will be normalized\n     * @param rotationInDegrees the rotation in degrees\n     */\n    fun rotate(axis: Vector3, rotationInDegrees: Double, target: TransformTarget = TransformTarget.MODEL) {\n        transform(target) *= Matrix44.rotate(axis, rotationInDegrees)\n    }\n\n    fun clear(r: Double, g: Double, b: Double, a: Double) {\n        driver.clear(r, g, b, a)\n    }\n\n    fun clear(color: ColorRGBa) {\n        driver.clear(color.r, color.g, color.b, color.alpha)\n    }\n\n    @Deprecated(\"background will be replaced by clear\", replaceWith = ReplaceWith(\"clear(r,g,b,a)\"))\n    fun background(r: Double, g: Double, b: Double, a: Double) {\n        driver.clear(r, g, b, a)\n    }\n\n    @Deprecated(\"background will be replaced by clear\", replaceWith = ReplaceWith(\"clear(color)\"))\n    fun background(color: ColorRGBa) {\n        driver.clear(color.r, color.g, color.b, color.alpha)\n    }\n\n    /**\n     * Push the active draw style on the draw style stack\n     * @see drawStyle\n     * @see popStyle\n     */\n    fun pushStyle(): DrawStyle = drawStyles.push(drawStyle.copy())\n\n    /**\n     * Pop the draw style from the draw style stack\n     * @see drawStyle\n     * @see popStyle\n     */\n    fun popStyle() {\n        drawStyle = drawStyles.pop().copy()\n    }\n\n    fun pushView(): Matrix44 = viewStack.push(view)\n    fun popView() {\n        view = viewStack.pop()\n    }\n\n    fun pushModel(): Matrix44 = modelStack.push(model)\n    fun popModel() {\n        model = modelStack.pop()\n    }\n\n    /**\n     * Push the active projection matrix on the projection state stack\n     */\n    fun pushProjection(): Matrix44 = projectionStack.push(projection)\n\n    /**\n     * Pop the active projection matrix from the projection state stack\n     */\n    fun popProjection() {\n        projection = projectionStack.pop()\n    }\n\n    /**\n     * Push the active model, view and projection matrices on their respective stacks\n     * @see pushTransforms\n     * @see popTransforms\n     * @see isolated\n     * @see isolatedWithTarget\n     */\n    fun pushTransforms() {\n        pushModel()\n        pushView()\n        pushProjection()\n    }\n\n    /**\n     * Pop the active the model, view and projection matrices from their respective stacks\n     * @see pushTransforms\n     * @see popTransforms\n     * @see isolated\n     * @see isolatedWithTarget\n     */\n    fun popTransforms() {\n        popModel()\n        popView()\n        popProjection()\n    }\n\n    var depthWrite: Boolean\n        set(value) {\n            drawStyle.depthWrite = value\n        }\n        get() = drawStyle.depthWrite\n\n    var cullTestPass: CullTestPass\n        set(value) {\n            drawStyle.cullTestPass = value\n        }\n        get() = drawStyle.cullTestPass\n\n    var depthTestPass: DepthTestPass\n        set(value) {\n            drawStyle.depthTestPass = value\n        }\n        get() = drawStyle.depthTestPass\n\n\n    var shadeStyle: ShadeStyle?\n        set(value) {\n            drawStyle.shadeStyle = value\n        }\n        get() = drawStyle.shadeStyle\n\n    /**\n     * The active fill color\n     * @see stroke\n     */\n    var fill: ColorRGBa?\n        set(value) {\n            drawStyle.fill = value\n        }\n        get() = drawStyle.fill\n\n    /**\n     * The active stroke color\n     * @see fill\n     * @see strokeWeight\n     */\n    var stroke: ColorRGBa?\n        set(value) {\n            drawStyle.stroke = value\n        }\n        get() = drawStyle.stroke\n\n    /**\n     * The active stroke weight\n     * @see stroke\n     * @see lineCap\n     * @see lineJoin\n     */\n    var strokeWeight: Double\n        set(value) {\n            drawStyle.strokeWeight = value\n        }\n        get() = drawStyle.strokeWeight\n\n    /**\n     * The active line cap method\n     * @see strokeWeight\n     * @see stroke\n     * @see lineJoin\n     */\n    var lineCap: LineCap\n        set(value) {\n            drawStyle.lineCap = value\n        }\n        get() = drawStyle.lineCap\n\n\n    /**\n     * The active line join method\n     * @see strokeWeight\n     * @see stroke\n     * @see lineCap\n     */\n    var lineJoin: LineJoin\n        set(value) {\n            drawStyle.lineJoin = value\n        }\n        get() = drawStyle.lineJoin\n\n    /**\n     * When two line segments meet at a sharp angle and miter joins have been specified for [lineJoin],\n     * it is possible for the miter to extend far beyond the thickness of the line stroking the path.\n     * The miterlimit imposes a limit on the ratio of the miter length to the [strokeWeight].\n     */\n    var miterLimit: Double\n        set(value) {\n            drawStyle.miterLimit = value\n        }\n        get() = drawStyle.miterLimit\n\n    /**\n     * The active fontmap, default is null\n     */\n    var fontMap: FontMap?\n        set(value) {\n            drawStyle.fontMap = value\n        }\n        get() {\n            if (drawStyle.fontMap == null) {\n                drawStyle.fontMap = defaultFontMap\n            }\n            return drawStyle.fontMap\n        }\n\n    fun rectangle(rectangle: Rectangle) {\n        rectangleDrawer.drawRectangle(context, drawStyle, rectangle.x, rectangle.y, rectangle.width, rectangle.height)\n    }\n\n    fun rectangle(x: Double, y: Double, width: Double, height: Double = width) {\n        rectangleDrawer.drawRectangle(context, drawStyle, x, y, width, height)\n    }\n\n    fun rectangle(corner: Vector2, width: Double, height: Double = width) {\n        rectangleDrawer.drawRectangle(context, drawStyle, corner.x, corner.y, width, height)\n    }\n\n    fun rectangles(positions: List<Vector2>, width: Double, height: Double = width) {\n        rectangleDrawer.drawRectangles(context, drawStyle, positions, width, height)\n    }\n\n    fun rectangles(positions: List<Vector2>, dimensions: List<Vector2>) {\n        rectangleDrawer.drawRectangles(context, drawStyle, positions, dimensions)\n    }\n\n    fun rectangles(rectangles: List<Rectangle>) {\n        rectangleDrawer.drawRectangles(context, drawStyle, rectangles)\n    }\n\n    fun rectangles(batch: RectangleBatch, count: Int = batch.size) {\n        rectangleDrawer.drawRectangles(context, drawStyle, batch, count)\n    }\n\n    /**\n     * Create and draw batched rectangles\n     */\n    fun rectangles(build: RectangleBatchBuilder.() -> Unit) {\n        val batchBuilder = RectangleBatchBuilder(this)\n        batchBuilder.build()\n        rectangleDrawer.ensureBatchSize(batchBuilder.entries.size)\n        batchBuilder.batch(rectangleDrawer.batch)\n        rectangleDrawer.drawRectangles(context, drawStyle, rectangleDrawer.batch, batchBuilder.entries.size)\n    }\n\n    /**\n     * Draw a single point\n     * @see points\n     * @see circle\n     */\n    fun point(x: Double, y: Double, z: Double = 0.0) {\n        pointDrawer.drawPoint(context, drawStyle, x, y, z)\n    }\n\n    /**\n     * Draw a single point\n     * @see points\n     * @see circle\n     */\n    fun point(vector: Vector2) {\n        pointDrawer.drawPoint(context, drawStyle, vector.x, vector.y, 0.0)\n    }\n\n    /**\n     * Draw a single point\n     * @see points\n     * @see circle\n     */\n    fun point(vector: Vector3) {\n        pointDrawer.drawPoint(context, drawStyle, vector.x, vector.y, vector.z)\n    }\n\n    /**\n     * Draw a list of 2D points\n     * @see point\n     * @see circle\n     */\n    @JvmName(\"points2D\")\n    fun points(points: List<Vector2>) {\n        pointDrawer.drawPoints(context, drawStyle, points)\n    }\n\n    /**\n     * Draw a list of 3D points\n     * @see point\n     * @see circle\n     * @see circles\n     */\n    @JvmName(\"points3D\")\n    fun points(points: List<Vector3>) {\n        pointDrawer.drawPoints(context, drawStyle, points)\n    }\n\n    /**\n     * Create and draw batched points\n     */\n    fun points(build: PointBatchBuilder.() -> Unit) {\n        val batchBuilder = PointBatchBuilder(this)\n        batchBuilder.build()\n        pointDrawer.ensureBatchSize(batchBuilder.entries.size)\n        batchBuilder.batch(pointDrawer.batch)\n        pointDrawer.drawPoints(context, drawStyle, pointDrawer.batch, batchBuilder.entries.size)\n    }\n\n    /**\n     * Draw a stored batch of points\n     */\n    fun points(batch: PointBatch, count: Int = batch.size) {\n        pointDrawer.drawPoints(context, drawStyle, batch, count)\n    }\n\n    /**\n     * Draw a circle\n     */\n    fun circle(x: Double, y: Double, radius: Double) {\n        circleDrawer.drawCircle(context, drawStyle, x, y, radius)\n    }\n\n    fun circle(position: Vector2, radius: Double) {\n        circleDrawer.drawCircle(context, drawStyle, position.x, position.y, radius)\n    }\n\n    fun circle(circle: Circle) {\n        circleDrawer.drawCircle(context, drawStyle, circle.center.x, circle.center.y, circle.radius)\n    }\n\n    fun circles(positions: List<Vector2>, radius: Double) {\n        circleDrawer.drawCircles(context, drawStyle, positions, radius)\n    }\n\n    fun circles(positions: List<Vector2>, radii: List<Double>) {\n        circleDrawer.drawCircles(context, drawStyle, positions, radii)\n    }\n\n    fun circles(circles: List<Circle>) {\n        circleDrawer.drawCircles(context, drawStyle, circles)\n    }\n\n    /**\n     * Draw stored circle batch\n     */\n    fun circles(batch: CircleBatch, count: Int = batch.size) {\n        circleDrawer.drawCircles(context, drawStyle, batch, count)\n    }\n\n    /**\n     * Create and draw batched circles\n     */\n    fun circles(build: CircleBatchBuilder.() -> Unit) {\n        val batchBuilder = CircleBatchBuilder(this)\n        batchBuilder.build()\n        circleDrawer.ensureBatchSize(batchBuilder.entries.size)\n        batchBuilder.batch(circleDrawer.batch)\n        circleDrawer.drawCircles(context, drawStyle, circleDrawer.batch, batchBuilder.entries.size)\n    }\n\n\n    /**\n     * Draws a single [Shape] using [fill], [stroke] and [strokeWeight] settings\n     * @see contour\n     * @see shapes\n     * @see contours\n     * @see composition\n     */\n    fun shape(shape: Shape) {\n        val distanceTolerance = 0.5 / (modelViewScaling * log2(strokeWeight).coerceAtLeast(1.0))\n        val fringeWidth = 1.0 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n\n        if (RenderTarget.active.hasStencilBuffer) {\n            when (shape.topology) {\n                ShapeTopology.CLOSED -> {\n                    val closedPC = shape.contours.map { it.adaptivePositionsAndCorners(distanceTolerance) }\n                    val closedP = closedPC.map { it.first }\n                    val closedC = closedPC.map { it.second }\n                    qualityPolygonDrawer.drawPolygon(context, drawStyle,\n                            closedP, closedC, fringeWidth)\n                    qualityLineDrawer.drawLineLoops(context, drawStyle, closedP, closedC, fringeWidth)\n                }\n                ShapeTopology.OPEN -> {\n                    val openPC = shape.openContours.map { it.adaptivePositionsAndCorners(distanceTolerance) }\n                    val openP = openPC.map { it.first }\n                    val openC = openPC.map { it.second }\n                    qualityLineDrawer.drawLineStrips(context, drawStyle, openP, openC, fringeWidth)\n                }\n                ShapeTopology.MIXED -> {\n                    val closedPC = shape.closedContours.map { it.adaptivePositionsAndCorners(distanceTolerance) }\n                    val closedP = closedPC.map { it.first }\n                    val closedC = closedPC.map { it.second }\n                    qualityPolygonDrawer.drawPolygon(context, drawStyle, closedP, closedC, fringeWidth)\n                    val openPC = shape.openContours.map { it.adaptivePositionsAndCorners(distanceTolerance) }\n                    val openP = openPC.map { it.first }\n                    val openC = openPC.map { it.second }\n                    qualityLineDrawer.drawLineStrips(context, drawStyle, openP, openC, fringeWidth)\n                }\n            }\n        } else {\n            error(\"drawing shapes requires a render target with a stencil attachment\")\n        }\n    }\n\n    /**\n     * Draws shapes using [fill], [stroke] and [strokeWeight] settings\n     * @see shape\n     * @see contour\n     * @see contours\n     */\n    fun shapes(shapes: List<Shape>) {\n        shapes.forEach {\n            shape(it)\n        }\n    }\n\n    /**\n     * Draws a single [ShapeContour] using [fill], [stroke] and [strokeWeight] settings\n     */\n    fun contour(contour: ShapeContour) {\n        val distanceTolerance = 0.5 / (modelViewScaling * log2(strokeWeight).coerceAtLeast(1.0))\n        val fringeWidth = 1.0 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n\n        if (RenderTarget.active.hasStencilBuffer) {\n            if (drawStyle.fill != null && contour.closed) {\n                val apc = contour.adaptivePositionsAndCorners(distanceTolerance)\n                val ap = listOf(apc.first)\n                val ac = listOf(apc.second)\n\n                qualityPolygonDrawer.drawPolygon(context, drawStyle, ap, ac, fringeWidth)\n            }\n\n            if (drawStyle.stroke != null && drawStyle.strokeWeight > 1E-4) {\n                when (drawStyle.quality) {\n                    DrawQuality.PERFORMANCE -> when (contour.closed) {\n                        true -> fastLineDrawer.drawLineLoops(context, drawStyle, listOf(contour.adaptivePositions(distanceTolerance)))\n                        false -> fastLineDrawer.drawLineLoops(context, drawStyle, listOf(contour.adaptivePositions(distanceTolerance)))\n                    }\n                    DrawQuality.QUALITY -> {\n                        val apc = contour.adaptivePositionsAndCorners(distanceTolerance)\n                        val ap = listOf(apc.first)\n                        val ac = listOf(apc.second)\n                        when (contour.closed) {\n                            true -> qualityLineDrawer.drawLineLoops(context, drawStyle, ap, ac, fringeWidth)\n                            false -> qualityLineDrawer.drawLineStrips(context, drawStyle, ap, ac, fringeWidth)\n                        }\n                    }\n                }\n            }\n        } else {\n            error(\"drawing org.openrndr.shape.contours requires a render target with a stencil attachment\")\n        }\n    }\n\n    /**\n     * Draws org.openrndr.shape.contours using [fill], [stroke] and [strokeWeight] settings\n     */\n    fun contours(contours: List<ShapeContour>) {\n        for (contour in contours) {\n            contour(contour)\n        }\n        /*\n        if (drawStyle.fill != null) {\n            qualityPolygonDrawer.drawPolygons(context, drawStyle, org.openrndr.shape.contours.filter { it.closed }.map { listOf(it.adaptivePositions()) })\n        }\n\n        if (drawStyle.stroke != null) {\n            qualityLineDrawer.drawLineStrips(context, drawStyle, org.openrndr.shape.contours.map { it.adaptivePositions() })\n        }\n        */\n\n    }\n\n    fun lineSegment(x0: Double, y0: Double, x1: Double, y1: Double) {\n        lineSegment(Vector2(x0, y0), Vector2(x1, y1))\n    }\n\n    fun lineSegment(lineSegment: LineSegment) {\n        lineSegment(lineSegment.start, lineSegment.end)\n    }\n\n    /**\n     * Draws a line segment from [start] to [end] using 2d coordinates\n     */\n    fun lineSegment(start: Vector2, end: Vector2) {\n        val fringeWidth = 1.0 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n\n\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineSegments(context, drawStyle, listOf(start, end))\n            DrawQuality.QUALITY -> qualityLineDrawer.drawLineStrips(context, drawStyle, listOf(listOf(start, end)), listOf(listOf(true, true)), fringeWidth)\n        }\n    }\n\n    /**\n     * Draws a line segment from [start] to [end] using 3d coordinates\n     */\n    fun lineSegment(start: Vector3, end: Vector3) {\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineSegments(context, drawStyle, listOf(start, end))\n            DrawQuality.QUALITY -> meshLineDrawer.drawLineSegments(context, drawStyle, listOf(start, end))\n        }\n    }\n\n    fun lineSegments(segments: List<Vector2>) {\n        val fringeWidth = 0.5 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineSegments(context, drawStyle, segments)\n            DrawQuality.QUALITY -> {\n\n                val pairs = (0 until segments.size / 2).map {\n                    listOf(segments[it * 2], segments[it * 2 + 1])\n                }\n                val corners = pairs.map { it.map { true } }\n                qualityLineDrawer.drawLineStrips(context, drawStyle, pairs, corners, fringeWidth)\n            }\n        }\n    }\n\n    fun lineSegments(segments: List<Vector2>, weights: List<Double>) {\n        val fringeWidth = 0.5 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineSegments(context, drawStyle, segments)\n            DrawQuality.QUALITY -> {\n                val pairs = (0 until segments.size / 2).map {\n                    listOf(segments[it * 2], segments[it * 2 + 1])\n                }\n                val corners = pairs.map { it.map { true } }\n                qualityLineDrawer.drawLineStrips(context, drawStyle, pairs, corners, weights, fringeWidth)\n            }\n        }\n    }\n\n    @JvmName(\"lineSegments3d\")\n    fun lineSegments(segments: List<Vector3>) {\n        when (drawStyle.quality) {\n            DrawQuality.QUALITY -> meshLineDrawer.drawLineSegments(context, drawStyle, segments)\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineSegments(context, drawStyle, segments)\n        }\n    }\n\n    @JvmName(\"lineSegments3d\")\n    fun lineSegments(segments: List<Vector3>, weights: List<Double>) {\n        when (drawStyle.quality) {\n            DrawQuality.QUALITY -> meshLineDrawer.drawLineSegments(context, drawStyle, segments, weights)\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineSegments(context, drawStyle, segments)\n        }\n    }\n\n    @JvmName(\"lineSegments3d\")\n    fun lineSegments(segments: List<Vector3>, weights: List<Double>, colors: List<ColorRGBa>) {\n        when (drawStyle.quality) {\n            DrawQuality.QUALITY -> meshLineDrawer.drawLineSegments(context, drawStyle, segments, weights, colors)\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineSegments(context, drawStyle, segments)\n        }\n    }\n\n    @JvmName(\"lineSegmentsFromLineSegmentList\")\n    fun lineSegments(segments: List<LineSegment>) {\n        val fringeWidth = 1.0 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> {\n                // TODO: a faster version would pass `segments` to\n                // fastLineDrawer as is to avoid iterating over the points twice\n                val points = segments.map { it.start } + segments.last().end\n                fastLineDrawer.drawLineSegments(context, drawStyle, points)\n            }\n            DrawQuality.QUALITY -> {\n                val pairs = segments.map {\n                    listOf(it.start, it.end)\n                }\n                qualityLineDrawer.drawLineStrips(context, drawStyle, pairs, pairs.map { it.map { true } }, fringeWidth)\n            }\n        }\n    }\n\n    fun lineLoop(points: List<Vector2>) {\n        val fringeWidth = 1.0 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, listOf(points))\n            DrawQuality.QUALITY -> qualityLineDrawer.drawLineLoops(context, drawStyle, listOf(points), listOf(points.map { true }), fringeWidth)\n        }\n    }\n\n    @JvmName(\"lineLoop3d\")\n    fun lineLoop(points: List<Vector3>) {\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, listOf(points))\n            DrawQuality.QUALITY -> meshLineDrawer.drawLineStrips(context, drawStyle, listOf(points), closed = listOf(true))\n        }\n    }\n\n    fun lineLoops(loops: List<List<Vector2>>) {\n        val fringeWidth = 1.0 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, loops)\n            DrawQuality.QUALITY -> qualityLineDrawer.drawLineLoops(context, drawStyle, loops, loops.map { it.map { true } }, fringeWidth)\n        }\n    }\n\n    @JvmName(\"lineLoops3d\")\n    fun lineLoops(loops: List<List<Vector3>>) {\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, loops)\n            DrawQuality.QUALITY -> meshLineDrawer.drawLineStrips(context, drawStyle, loops, closed = List(loops.size) { true })\n        }\n    }\n\n    fun lineLoops(loops: List<List<Vector2>>, weights: List<Double>) {\n        val fringeWidth = 1.0 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, loops)\n            DrawQuality.QUALITY -> qualityLineDrawer.drawLineLoops(context, drawStyle, loops, loops.map { it.map { true } }, weights, fringeWidth)\n        }\n    }\n\n    @JvmName(\"lineLoops3d)\")\n    fun lineLoops(loops: List<List<Vector3>>, weights: List<Double>) {\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, loops)\n            DrawQuality.QUALITY -> meshLineDrawer.drawLineStrips(context, drawStyle, loops, weights, closed = List(loops.size) { true })\n        }\n    }\n\n    /**\n     * Draws a line strip with 2d coordinates\n     */\n    fun lineStrip(points: List<Vector2>) {\n        val fringeWidth = 1.0 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, listOf(points))\n            DrawQuality.QUALITY -> qualityLineDrawer.drawLineStrips(context, drawStyle, listOf(points), listOf(points.map { true }), fringeWidth)\n        }\n    }\n\n    /**\n     * Draws a line strip with 3d coordinates\n     */\n    @JvmName(\"lineStrip3d\")\n    fun lineStrip(points: List<Vector3>) {\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, listOf(points))\n            DrawQuality.QUALITY -> meshLineDrawer.drawLineStrips(context, drawStyle, listOf(points))\n        }\n    }\n\n    /**\n     * Draws line strips with 3d coordinates\n     */\n    fun lineStrips(strips: List<List<Vector2>>) {\n        val fringeWidth = 1.0 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, strips)\n            DrawQuality.QUALITY -> qualityLineDrawer.drawLineStrips(context, drawStyle, strips, strips.map { it.map { true } }, fringeWidth)\n        }\n    }\n\n    /**\n     * Draws line strips with 3d coordinates\n     */\n    @JvmName(\"lineStrips3d\")\n    fun lineStrips(strips: List<List<Vector3>>) {\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, strips)\n            DrawQuality.QUALITY -> meshLineDrawer.drawLineStrips(context, drawStyle, strips)\n        }\n    }\n\n    /**\n     * Draws line strips with 2d coordinates and stroke weights per strip\n     */\n    fun lineStrips(strips: List<List<Vector2>>, weights: List<Double>) {\n        val fringeWidth = 1.0 / modelViewScaling\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, strips)\n            DrawQuality.QUALITY -> qualityLineDrawer.drawLineStrips(context, drawStyle, strips, strips.map { it.map { true } }, weights, fringeWidth )\n        }\n    }\n\n    /**\n     * Draws line strips with 3d coordinates and stroke weights per strip\n     */\n    @JvmName(\"lineStrips3d\")\n    fun lineStrips(strips: List<List<Vector3>>, weights: List<Double>) {\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, strips)\n            DrawQuality.QUALITY -> meshLineDrawer.drawLineStrips(context, drawStyle, strips, weights)\n        }\n    }\n\n    /**\n     * Draws line strips with 3d coordinates and stroke weights per strip\n     */\n    @JvmName(\"lineStrips3d\")\n    fun lineStrips(strips: List<List<Vector3>>, weights: List<Double>, colors: List<ColorRGBa>) {\n        when (drawStyle.quality) {\n            DrawQuality.PERFORMANCE -> fastLineDrawer.drawLineLoops(context, drawStyle, strips)\n            DrawQuality.QUALITY -> meshLineDrawer.drawLineStrips(context, drawStyle, strips, weights, colors)\n        }\n    }\n\n    /**\n     * Draw a single segment\n     * @see contour\n     */\n    fun segment(segment: Segment) {\n        val distanceTolerance = 0.5 / (modelViewScaling * log2(strokeWeight).coerceAtLeast(1.0))\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n        lineStrip(segment.adaptivePositions(distanceTolerance))\n    }\n\n    /**\n     * Draws a single 3D segment\n     */\n    fun segment(segment: Segment3D) {\n        lineStrip(segment.adaptivePositions())\n    }\n\n    /**\n     * Draws a list of 2D segments\n     */\n    @JvmName(\"segments2d\")\n    fun segments(segments: List<Segment>) {\n        val distanceTolerance = 0.5 / (modelViewScaling * log2(strokeWeight).coerceAtLeast(1.0))\n        if (abs(modelViewScaling) < 1E-6){\n            return\n        }\n        lineStrips(segments.map { it.adaptivePositions(distanceTolerance) })\n    }\n\n    /**\n     * Draws a list of 3D segments\n     */\n    fun segments(segments: List<Segment3D>) {\n        lineStrips(segments.map { it.adaptivePositions() })\n    }\n\n    /**\n     * Draws a list of 3D segments, each with their weight and color\n     */\n    fun segments(segments: List<Segment3D>, weights: List<Double>, colors: List<ColorRGBa>) {\n        lineStrips(segments.map { it.adaptivePositions() }, weights, colors)\n    }\n\n    /**\n     * Draws a single 3D path\n     * @param path the path to draw\n     */\n    fun path(path: Path3D) {\n        lineStrip(path.adaptivePositions(0.03))\n    }\n\n    /**\n     * Draws a [source] area of an image ([ColorBuffer]) into a [target] area\n     */\n    fun image(colorBuffer: ColorBuffer, source: Rectangle, target: Rectangle) {\n        imageDrawer.drawImage(context, drawStyle, colorBuffer, listOf(source to target))\n    }\n\n    /**\n     * Draws an image ([ColorBuffer]) into a [target] area\n     */\n    fun image(colorBuffer: ColorBuffer, target: Rectangle) {\n        imageDrawer.drawImage(context, drawStyle, colorBuffer, target.x, target.y, target.width, target.height)\n    }\n\n    /**\n     * Draws an image with its top-left corner at ([x], [y]) and dimensions ([width], [height])\n     */\n    fun image(colorBuffer: ColorBuffer, x: Double, y: Double, width: Double = colorBuffer.width.toDouble(), height: Double = colorBuffer.height.toDouble()) {\n        imageDrawer.drawImage(context, drawStyle, colorBuffer, x, y, width, height)\n    }\n\n    /**\n     * Draws an image with its top-left corner at ([position]) and dimensions ([width], [height])\n     */\n    fun image(colorBuffer: ColorBuffer, position: Vector2, width: Double = colorBuffer.width.toDouble(), height: Double = colorBuffer.height.toDouble()) {\n        imageDrawer.drawImage(context, drawStyle, colorBuffer, position.x, position.y, width, height)\n    }\n\n    /**\n     * Draws an image with its top-left corner at (0,0)\n     */\n    fun image(colorBuffer: ColorBuffer) = image(colorBuffer, 0.0, 0.0)\n\n    fun image(colorBuffer: ColorBuffer, rectangles: List<Pair<Rectangle, Rectangle>>) {\n        imageDrawer.drawImage(context, drawStyle, colorBuffer, rectangles)\n    }\n\n    /**\n     * Draws an image using an ArrayTexture as source\n     */\n    fun image(arrayTexture: ArrayTexture, layer: Int = 0, x: Double = 0.0, y: Double = 0.0,\n              width: Double = arrayTexture.width.toDouble(), height: Double = arrayTexture.height.toDouble()) {\n        imageDrawer.drawImage(context, drawStyle, arrayTexture, layer, x, y, width, height)\n    }\n\n    fun image(arrayTexture: ArrayTexture, layer: Int = 0, source: Rectangle, target: Rectangle) {\n        imageDrawer.drawImage(context, drawStyle, arrayTexture, listOf(layer), listOf(source to target))\n    }\n\n    fun image(arrayTexture: ArrayTexture, layers: List<Int>, rectangles: List<Pair<Rectangle, Rectangle>>) {\n        imageDrawer.drawImage(context, drawStyle, arrayTexture, layers, rectangles)\n    }\n\n    /**\n     * Draws [text] at ([position])\n     */\n    fun text(text: String, position: Vector2) {\n        if (fontMap is FontImageMap) {\n            fontImageMapDrawer.drawText(context, drawStyle, text, position.x, position.y)\n        }\n    }\n\n    /**\n     * Draws [text] at ([x], [y])\n     */\n    fun text(text: String, x: Double = 0.0, y: Double = 0.0) {\n        if (fontMap is FontImageMap) {\n            fontImageMapDrawer.drawText(context, drawStyle, text, x, y)\n        }\n    }\n\n    /**\n     * Draws [texts] at [positions])\n     */\n    fun texts(texts: List<String>, positions: List<Vector2>) {\n        if (fontMap is FontImageMap) {\n            fontImageMapDrawer.drawTexts(context, drawStyle, texts, positions)\n        }\n    }\n\n    /**\n     * Draws a [VertexBuffer] using [primitive]\n     */\n    fun vertexBuffer(\n        vertexBuffer: VertexBuffer,\n        primitive: DrawPrimitive,\n        vertexOffset: Int = 0,\n        vertexCount: Int = vertexBuffer.vertexCount\n    ) {\n        vertexBuffer(listOf(vertexBuffer), primitive, vertexOffset, vertexCount)\n    }\n\n    fun vertexBuffer(\n        vertexBuffers: List<VertexBuffer>,\n        primitive: DrawPrimitive,\n        offset: Int = 0,\n        vertexCount: Int = vertexBuffers[0].vertexCount\n    ) {\n        vertexBufferDrawer.drawVertexBuffer(context, drawStyle, primitive, vertexBuffers, offset, vertexCount)\n    }\n\n    fun vertexBuffer(\n        indexBuffer: IndexBuffer,\n        vertexBuffers: List<VertexBuffer>,\n        primitive: DrawPrimitive,\n        offset: Int = 0,\n        indexCount: Int = indexBuffer.indexCount\n    ) {\n        vertexBufferDrawer.drawVertexBuffer(context, drawStyle, primitive, indexBuffer, vertexBuffers, offset, indexCount)\n    }\n\n    fun vertexBufferInstances(\n        vertexBuffers: List<VertexBuffer>,\n        instanceAttributes: List<VertexBuffer>,\n        primitive: DrawPrimitive,\n        instanceCount: Int,\n        offset: Int = 0,\n        vertexCount: Int = vertexBuffers[0].vertexCount\n    ) {\n        vertexBufferDrawer.drawVertexBufferInstances(context, drawStyle, primitive, vertexBuffers, instanceAttributes, offset, vertexCount, instanceCount)\n    }\n\n    fun vertexBufferInstances(\n        indexBuffer: IndexBuffer,\n        vertexBuffers: List<VertexBuffer>,\n        instanceAttributes: List<VertexBuffer>,\n        primitive: DrawPrimitive,\n        instanceCount: Int,\n        offset: Int = 0,\n        indexCount: Int = indexBuffer.indexCount\n    ) {\n        vertexBufferDrawer.drawVertexBufferInstances(context, drawStyle, primitive, indexBuffer, vertexBuffers, instanceAttributes, offset, indexCount, instanceCount)\n    }\n\n\n    fun transform(transform: TransformTarget): KMutableProperty0<Matrix44> {\n        return when (transform) {\n            TransformTarget.PROJECTION -> this::projection\n            TransformTarget.MODEL -> this::model\n            TransformTarget.VIEW -> this::view\n        }\n    }\n}\n\n/**\n * Pushes style and model-view-projection matrices, calls function and pops.\n * @param function the function that is called in the isolation\n */\n@OptIn(ExperimentalContracts::class)\nfun Drawer.isolated(function: Drawer.() -> Unit) {\n    contract {\n        callsInPlace(function, kotlin.contracts.InvocationKind.EXACTLY_ONCE)\n    }\n    pushTransforms()\n    pushStyle()\n    function()\n    popStyle()\n    popTransforms()\n}\n\n/**\n * Pushes style and model-view-projection matrices, sets render target, calls function and pops.\n * @param function the function that is called in the isolation\n */\n@OptIn(ExperimentalContracts::class)\nfun Drawer.isolatedWithTarget(target: RenderTarget, function: Drawer.() -> Unit) {\n    contract {\n        callsInPlace(function, kotlin.contracts.InvocationKind.EXACTLY_ONCE)\n    }\n    target.bind()\n    isolated(function)\n    target.unbind()\n}\n\n\nprivate operator fun KMutableProperty0<Matrix44>.timesAssign(matrix: Matrix44) = set(get() * matrix)\n","package org.openrndr.draw\n\nimport org.openrndr.platform.Platform\nimport org.openrndr.platform.PlatformType\n\n/**\n * Drawer configuration\n */\nobject DrawerConfiguration {\n\n    /**\n     * Should vertex buffer optimizations be disabled.\n     *\n     * This can be configured by passing `-Dorg.openrndr.draw.vertex_buffer_optimizations=disable` to the JVM\n     * @since openrndr 0.4.5\n     */\n    val disableVertexBufferOptimizations by lazy { Platform.property(\"org.openrndr.draw.vertex_buffer_optimizations\") == \"disable\" }\n\n\n    /**\n     * Should vertex buffer optimizations be forcefully enabled\n     *\n     * This can be configured by passing `-Dorg.openrndr.draw.vertex_buffer_optimizations=force` to the JVM\n     * @since openrndr 0.4.5\n     */\n    val forceVertexBufferOptimizations by lazy { Platform.property(\"org.openrndr.draw.vertex_buffer_optimizations\") == \"force\" }\n\n\n    /**\n     * A hint for the number of vertex buffers to create in order to reduce pipeline stall\n     *\n     * This can be configured by passing `-Dorg.openrndr.draw.vertex_buffer_multi_buffer_hint=<count>` to the JVM, the\n     * default value is 100.\n     * @since openrndr 0.4.5\n     */\n    val vertexBufferMultiBufferHint by lazy {\n        Platform.property(\"org.openrndr.draw.vertex_buffer_multi_buffer_hint\")?.toIntOrNull() ?: 100\n    }\n\n    /**\n     * The effective number of vertex buffers to create in order to reduce pipeline stall\n     *\n     * @see disableVertexBufferOptimizations\n     * @see forceVertexBufferOptimizations\n     * @see vertexBufferMultiBufferHint\n     * @since openrndr 0.4.5\n     */\n    val vertexBufferMultiBufferCount by lazy {\n        if (disableVertexBufferOptimizations) {\n            1\n        } else {\n            if (forceVertexBufferOptimizations || Platform.type == PlatformType.MAC) {\n                vertexBufferMultiBufferHint\n            } else {\n                1\n            }\n        }\n    }\n}","package org.openrndr.draw\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.internal.Driver\nimport org.openrndr.math.*\nimport org.openrndr.math.transforms.ortho\nimport org.openrndr.shape.Rectangle\n\nprivate var filterQuad: VertexBuffer? = null\nprivate var filterQuadFormat = vertexFormat {\n    position(2)\n    textureCoordinate(2)\n}\n\nfun filterShaderFromCode(fragmentShaderCode: String, name: String, includeShaderConfiguration: Boolean = true): Shader {\n    val hasExistingConfiguration = fragmentShaderCode.contains(\"#version\")\n\n    return if (!includeShaderConfiguration || hasExistingConfiguration) {\n        Shader.createFromCode(vsCode = Filter.filterVertexCode, fsCode = fragmentShaderCode, name = name)\n    } else {\n        Shader.createFromCode(\n            vsCode = Filter.filterVertexCode,\n            fsCode = \"${Driver.instance.shaderConfiguration()}\\n$fragmentShaderCode\",\n            name = name\n        )\n    }\n}\n\n/**\n * Filter base class. Renders \"full-screen\" quads.\n */\nopen class Filter(private val shader: Shader? = null, private val watcher: ShaderWatcher? = null) {\n\n    private val filterDrawStyle = DrawStyle().apply {\n        blendMode = BlendMode.REPLACE\n        depthWrite = false\n        depthTestPass = DepthTestPass.ALWAYS\n        stencil.stencilTest = StencilTest.DISABLED\n        clip = null\n    }\n\n    /**\n     * parameter map\n     */\n    open val parameters = mutableMapOf<String, Any>()\n    var padding = 0\n\n    var depthBufferOut: DepthBuffer? = null\n\n    companion object {\n        val filterVertexCode: String\n            get() {\n                return Driver.instance.shaderConfiguration() + \"\"\"\n\n#ifdef OR_IN_OUT\nin vec2 a_texCoord0;\nin vec2 a_position;\n#else\nattribute vec2 a_texCoord0;\nattribute vec2 a_position;\n#endif\n\nuniform vec2 targetSize;\nuniform vec2 padding;\nuniform mat4 projectionMatrix;\n\n#ifdef OR_IN_OUT\nout vec2 v_texCoord0;\n#else\nvarying vec2 v_texCoord0;\n#endif\n\nvoid main() {\n    v_texCoord0 = a_texCoord0;\n    vec2 transformed = a_position * (targetSize - 2.0 * padding) + padding;\n    gl_Position = projectionMatrix * vec4(transformed, 0.0, 1.0);\n}\"\"\"\n\n            }\n    }\n\n    open fun apply(source: Array<ColorBuffer>, target: Array<ColorBuffer>, clip: Rectangle? = null) {\n        if (target.isEmpty() || clip?.area == 0.0) {\n            return\n        }\n        filterDrawStyle.clip = clip\n        val renderTarget = renderTarget(target[0].width, target[0].height, target[0].contentScale) {}\n\n        target.forEach {\n            renderTarget.attach(it)\n        }\n\n        for (i in 1 until target.size) {\n            renderTarget.blendMode(i, BlendMode.REPLACE)\n        }\n\n        apply(source, renderTarget, clip)\n        depthBufferOut?.let {\n            renderTarget.attach(it)\n        }\n\n        if (depthBufferOut != null) {\n            renderTarget.detachDepthBuffer()\n        }\n        renderTarget.detachColorAttachments()\n        renderTarget.destroy()\n    }\n\n    fun apply(source: Array<ColorBuffer>, target: RenderTarget, clip: Rectangle? = null) {\n        filterDrawStyle.clip = clip\n        val shader = if (this.watcher != null) watcher.shader!! else this.shader!!\n        target.bind()\n\n        if (filterQuad == null) {\n            val fq = VertexBuffer.createDynamic(filterQuadFormat, 6, Session.root)\n\n            fq.shadow.writer().apply {\n                write(Vector2(0.0, 1.0)); write(Vector2(0.0, 0.0))\n                write(Vector2(0.0, 0.0)); write(Vector2(0.0, 1.0))\n                write(Vector2(1.0, 0.0)); write(Vector2(1.0, 1.0))\n\n                write(Vector2(0.0, 1.0)); write(Vector2(0.0, 0.0))\n                write(Vector2(1.0, 1.0)); write(Vector2(1.0, 0.0))\n                write(Vector2(1.0, 0.0)); write(Vector2(1.0, 1.0))\n            }\n            fq.shadow.upload()\n            fq.shadow.destroy()\n            filterQuad = fq\n        }\n\n        shader.begin()\n\n        source.forEachIndexed { index, colorBuffer ->\n            colorBuffer.bind(index)\n            shader.uniform(\"tex$index\", index)\n            shader.uniform(\n                \"textureSize$index\",\n                Vector2(colorBuffer.effectiveWidth.toDouble(), colorBuffer.effectiveHeight.toDouble())\n            )\n        }\n\n        Driver.instance.setState(filterDrawStyle)\n\n        shader.uniform(\n            \"projectionMatrix\",\n            ortho(0.0, target.width.toDouble(), target.height.toDouble(), 0.0, -1.0, 1.0)\n        )\n        shader.uniform(\"targetSize\", Vector2(target.width.toDouble(), target.height.toDouble()))\n        shader.uniform(\"padding\", Vector2(padding.toDouble(), padding.toDouble()))\n\n        var textureIndex = source.size + 0\n        parameters.forEach { (uniform, value) ->\n            @Suppress(\"UNCHECKED_CAST\")\n            when (value) {\n                is Double -> shader.uniform(uniform, value)\n                is Boolean -> shader.uniform(uniform, value)\n                is Float -> shader.uniform(uniform, value)\n                is Matrix44 -> shader.uniform(uniform, value)\n                is Vector2 -> shader.uniform(uniform, value)\n                is Vector3 -> shader.uniform(uniform, value)\n                is Vector4 -> shader.uniform(uniform, value)\n                is IntVector2 -> shader.uniform(uniform, value)\n                is IntVector3 -> shader.uniform(uniform, value)\n                is IntVector4 -> shader.uniform(uniform, value)\n                is ColorRGBa -> shader.uniform(uniform, value)\n                is Int -> shader.uniform(uniform, value)\n                is Matrix55 -> shader.uniform(uniform, value.floatArray)\n                is FloatArray -> shader.uniform(uniform, value)\n\n                // EJ: this is not so nice, but I have no other ideas for this\n                is Array<*> -> if (value.size > 0) when (value[0]) {\n                    is Vector2 -> shader.uniform(uniform, value as Array<Vector2>)\n                    is Vector3 -> shader.uniform(uniform, value as Array<Vector3>)\n                    is Vector4 -> shader.uniform(uniform, value as Array<Vector4>)\n                    is IntVector2 -> shader.uniform(uniform, value as Array<IntVector2>)\n                    is IntVector3 -> shader.uniform(uniform, value as Array<IntVector3>)\n                    is IntVector4 -> shader.uniform(uniform, value as Array<IntVector4>)\n                    is ColorRGBa -> shader.uniform(uniform, value as Array<ColorRGBa>)\n                    is Double -> shader.uniform(uniform, value as Array<Double>)\n                    else -> throw IllegalArgumentException(\"unsupported array value: ${value[0]!!::class}\")\n                    //is ColorRGBa -> shader.uniform(uniform, value as Array<ColorRGBa>)\n                }\n\n                is DepthBuffer -> {\n                    shader.uniform(uniform, textureIndex)\n                    value.bind(textureIndex)\n                    textureIndex++\n                }\n\n                is ColorBuffer -> {\n                    shader.uniform(uniform, textureIndex)\n                    shader.uniform(\n                        \"textureSize$textureIndex\",\n                        Vector2(value.effectiveWidth.toDouble(), value.effectiveHeight.toDouble())\n                    )\n                    value.bind(textureIndex)\n                    textureIndex++\n                }\n\n                is Cubemap -> {\n                    shader.uniform(uniform, textureIndex)\n                    value.bind(textureIndex)\n                    textureIndex++\n                }\n\n                is ArrayCubemap -> {\n                    shader.uniform(uniform, textureIndex)\n                    value.bind(textureIndex)\n                    textureIndex++\n                }\n\n                is BufferTexture -> {\n                    shader.uniform(uniform, textureIndex)\n                    value.bind(textureIndex)\n                    textureIndex++\n                }\n            }\n        }\n\n        Driver.instance.drawVertexBuffer(shader, listOf(filterQuad!!), DrawPrimitive.TRIANGLES, 0, 6)\n        shader.end()\n        target.unbind()\n    }\n\n    // TODO move to Filter1to1\n    fun apply(source: ColorBuffer, target: ColorBuffer, clip: Rectangle? = null) =\n        apply(arrayOf(source), arrayOf(target), clip)\n\n    fun apply(source: ColorBuffer, target: Array<ColorBuffer>, clip: Rectangle? = null) = apply(arrayOf(source), target, clip)\n    fun apply(source: Array<ColorBuffer>, target: ColorBuffer, clip: Rectangle? = null) = apply(source, arrayOf(target), clip)\n\n    fun untrack() {\n        shader?.let { Session.active.untrack(shader) }\n    }\n\n    open fun destroy() {\n        shader?.destroy()\n    }\n\n    protected val format get() = filterQuadFormat\n}\n\nopen class Filter1to1(shader: Shader? = null, watcher: ShaderWatcher? = null) :\n    Filter(shader, watcher)\n\nopen class Filter2to1(shader: Shader? = null, watcher: ShaderWatcher? = null) :\n    Filter(shader, watcher) {\n    fun apply(source0: ColorBuffer, source1: ColorBuffer, target: ColorBuffer, clip: Rectangle? = null) =\n        apply(arrayOf(source0, source1), arrayOf(target), clip)\n}\n\nopen class Filter3to1(shader: Shader? = null, watcher: ShaderWatcher? = null) :\n    Filter(shader, watcher) {\n    fun apply(\n        source0: ColorBuffer,\n        source1: ColorBuffer,\n        source2: ColorBuffer,\n        target: ColorBuffer,\n        clip: Rectangle? = null\n    ) =\n        apply(arrayOf(source0, source1, source2), arrayOf(target), clip)\n}\n\nopen class Filter4to1(shader: Shader? = null, watcher: ShaderWatcher? = null) :\n    Filter(shader, watcher) {\n    fun apply(\n        source0: ColorBuffer,\n        source1: ColorBuffer,\n        source2: ColorBuffer,\n        source3: ColorBuffer,\n        target: ColorBuffer,\n        clip: Rectangle? = null\n\n    ) =\n        apply(arrayOf(source0, source1, source2, source3), arrayOf(target), clip)\n}\n","package org.openrndr.draw\n\nimport org.openrndr.internal.Driver\nimport org.openrndr.shape.IntRectangle\n\nprivate val standard = charArrayOf(\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n        'ë', 'ä', 'ö', 'ü', 'ï', 'ÿ', 'Ë', 'Ä', 'Ö', 'Ü', 'Ï', 'Ÿ', 'ñ', 'Ñ', 'ç', 'Ç', 'ø', 'Ø', 'é', 'á', 'ó', 'í', 'ú', 'É', 'Á', 'Ó',\n        'Í', 'Ú', 'è', 'à', 'ò', 'ì', 'ù', 'È', 'À', 'Ò', 'Ì', 'Ù', 'â', 'ê', 'î', 'û', 'ô', 'Â', 'Ê', 'Î', 'Û', 'Ô', 'œ', 'Œ', 'æ', 'Æ',\n        'Ą', 'Ć', 'Ę', 'Ł', 'Ń', 'Ó', 'Ś', 'Ż', 'Ź', 'ą', 'ć', 'ę', 'ł', 'ń', 'ó', 'ś', 'ż', 'ź',\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',\n        '!', '?', '¿', '¡', '…', '.', ',', ' ', ':', ';', '&', '#', '№', '“', '”', '‘', '’', '`',\n        '¤', '€', '$', '£', '‒', '-', '—', '–', '_', '·', '•', '°', '@', '^', '*', '«', '»', '/',\n        '\\\\', '\"', '\\'', '+', '=', '÷', '~', '%', '(', ')', '[', ']', '{', '}', '<', '>', '|', '✕')\n\n\nprivate val cyrillic = charArrayOf(\n        'А', 'а', 'Б', 'б', 'В', 'в', 'Г', 'г', 'Д', 'д', 'Е', 'е', 'Ё', 'ё', 'Ж', 'ж', 'З', 'з', 'И', 'и', 'Й', 'й',\n        'К', 'к', 'Л', 'л', 'М', 'м', 'Н', 'н', 'О', 'о', 'П', 'п', 'Р', 'р', 'С', 'с', 'Т', 'т', 'У', 'у', 'Ф', 'ф',\n        'Х', 'х', 'Ц', 'ц', 'Ч', 'ч', 'Ш', 'ш', 'Щ', 'щ', 'Ъ', 'ъ', 'Ы', 'ы', 'Ь', 'ь', 'Э', 'э', 'Ю', 'ю', 'Я', 'я',\n        'І', 'і', 'Ў', 'ў', 'Ґ', 'ґ', 'Ї', 'ї',\t'Й', 'й'\n)\n\nval defaultFontmapCharacterSet by lazy { (standard + cyrillic).toSet() }\n\n/**\n * Holds properties common to both vector-based and image-based [FontMap]s.\n */\nabstract class FontMap {\n    abstract val size: Double\n    abstract val ascenderLength: Double\n    abstract val descenderLength: Double\n    abstract val height: Double\n    abstract val leading: Double\n    abstract val name: String\n}\n\nexpect val defaultFontMap: FontImageMap?\n\ndata class GlyphMetrics(val advanceWidth: Double, val leftSideBearing: Double, val xBitmapShift: Double, val yBitmapShift: Double)\n\ndata class FontImageMapDescriptor(val fontUrl: String, val size: Double, val alphabet:Set<Char>, val contentScale: Double)\n\nprivate val fontImageMaps: MutableMap<FontImageMapDescriptor, FontImageMap> = mutableMapOf()\n\ndata class CharacterPair(val left: Char, val right: Char)\n\n/**\n * A type of [FontMap] which keeps characters pre-rendered in a [ColorBuffer]\n * texture at a specific font [size].\n */\nclass FontImageMap(val texture: ColorBuffer,\n                   val map: Map<Char, IntRectangle>,\n                   val glyphMetrics: Map<Char, GlyphMetrics>,\n                   override val size: Double,\n                   val contentScale: Double,\n                   override val ascenderLength: Double,\n                   override val descenderLength: Double,\n                   override val height: Double,\n                   override val leading: Double,\n                   override val name: String\n) : FontMap() {\n    val kerningTable = mutableMapOf<CharacterPair, Double>()\n\n    companion object {\n        fun fromUrl(fontUrl: String, size: Double, characterSet: Set<Char> = defaultFontmapCharacterSet, contentScale: Double = 1.0): FontImageMap =\n                fontImageMaps.getOrPut(FontImageMapDescriptor(fontUrl, size,  characterSet, contentScale)) {\n                    Driver.instance.fontImageMapManager.fontMapFromUrl(fontUrl, size, characterSet, contentScale)\n                }\n\n        fun fromFile(file: String, size: Double, characterSet: Set<Char> = defaultFontmapCharacterSet, contentScale: Double = 1.0): FontImageMap =\n                fontImageMaps.getOrPut(FontImageMapDescriptor(\"file:$file\", size, characterSet, contentScale)) {\n                    Driver.instance.fontImageMapManager.fontMapFromUrl(\"file:$file\", size, characterSet, contentScale)\n                }\n    }\n\n    fun characterWidth(character: Char): Double = map[character]?.width?.toDouble() ?: 0.0\n\n    fun kerning(left: Char, right: Char): Double = kerningTable.getOrElse(CharacterPair(left, right)) { 0.0 }\n}\n\n\n/**\n * A type of [FontMap] which keeps characters stored as vector data. Good for\n * displaying very large text and for displaying text at different scales, but\n * in general less performant than [FontImageMap] because it is not\n * pre-rendered.\n */\nabstract class FontVectorMap : FontMap() {\n    companion object {\n        fun fromUrl(fontUrl: String, size: Double, characterSet: Set<Char> = defaultFontmapCharacterSet): FontImageMap {\n            return Driver.instance.fontVectorMapManager.fontMapFromUrl(fontUrl, size, characterSet)\n        }\n    }\n}\n\n","package org.openrndr.draw\n\nimport org.openrndr.draw.font.BufferAccess\nimport org.openrndr.draw.font.BufferFlag\n\ntypealias ImageAccess = BufferAccess\ntypealias ImageFlag = BufferFlag\n\nsealed class ImageBinding(val level: Int, val access: ImageAccess)\nclass ColorBufferImageBinding(val colorBuffer: ColorBuffer, level: Int, imageAccess: ImageAccess) :\n    ImageBinding(level, imageAccess)\n\nclass CubemapImageBinding(val cubemap: Cubemap, level: Int, imageAccess: ImageAccess) : ImageBinding(level, imageAccess)\nclass CubemapLayerImageBinding(val cubemap: Cubemap, val side: CubemapSide, level: Int, imageAccess: ImageAccess) :\n    ImageBinding(level, imageAccess)\n\nclass VolumeTextureImageBinding(val volumeTexture: VolumeTexture, level: Int, imageAccess: ImageAccess) :\n    ImageBinding(level, imageAccess)\n\nclass VolumeTextureLayerImageBinding(\n    val volumeTexture: VolumeTexture,\n    val layer: Int,\n    level: Int,\n    imageAccess: ImageAccess\n) : ImageBinding(level, imageAccess)\n\nclass ArrayTextureImageBinding(val arrayTexture: ArrayTexture, level: Int, imageAccess: ImageAccess) :\n    ImageBinding(level, imageAccess)\n\nclass ArrayTextureLayerImageBinding(val arrayTexture: ArrayTexture, level: Int, imageAccess: ImageAccess) :\n    ImageBinding(level, imageAccess)\n\nclass ArrayCubemapImageBinding(val arrayCubemap: ArrayCubemap, level: Int, imageAccess: ImageAccess) :\n    ImageBinding(level, imageAccess)\n\nclass BufferTextureImageBinding(val bufferTexture: BufferTexture, imageAccess: ImageAccess) :\n    ImageBinding(0, imageAccess)\n\n\nfun BufferTexture.imageBinding(imageAccess: ImageAccess) = BufferTextureImageBinding(this, imageAccess)\nfun ColorBuffer.imageBinding(level: Int = 0, imageAccess: ImageAccess) =\n    ColorBufferImageBinding(this, level, imageAccess)\n\nfun Cubemap.imageBinding(level: Int = 0, imageAccess: ImageAccess) = CubemapImageBinding(this, level, imageAccess)\nfun ArrayTexture.imageBinding(level: Int = 0, imageAccess: ImageAccess) =\n    ArrayTextureImageBinding(this, level, imageAccess)\n\nfun VolumeTexture.imageBinding(level: Int = 0, imageAccess: ImageAccess) : VolumeTextureImageBinding {\n    require(level in 0 until levels) { \"requested level $level but volume texture has only $levels mip-levels\" }\n    return VolumeTextureImageBinding(this, level, imageAccess)\n}\n\n\nfun ArrayCubemap.imageBinding(level: Int = 0, imageAccess: ImageAccess) =\n    ArrayCubemapImageBinding(this, level, imageAccess)\n\ninterface ShaderImageBindings {\n    /**\n     * Bind image unit to [imageBinding]\n     */\n    fun image(name: String, image: Int, imageBinding: ImageBinding)\n\n    /**\n     * Bind image units to [imageBinding] array\n     * @since 0.4.4\n     */\n    fun image(name: String, image: Int, imageBinding: Array<out ImageBinding>)\n}","package org.openrndr.draw\n\n\nenum class IndexType(val sizeInBytes:Int) {\n    INT16(2),\n    INT32(4)\n}\n\nexpect interface IndexBuffer {\n    companion object {\n        fun createDynamic(elementCount: Int, type: IndexType): IndexBuffer\n    }\n\n    val indexCount: Int\n    val type: IndexType\n    fun destroy()\n}\n\n\nfun indexBuffer(elementCount: Int, type: IndexType): IndexBuffer {\n    return IndexBuffer.createDynamic(elementCount, type)\n}\n\n","package org.openrndr.draw\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.internal.Driver\nimport org.openrndr.shape.IntRectangle\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\nimport org.openrndr.draw.colorBuffer as _colorBuffer\nimport org.openrndr.draw.depthBuffer as _depthBuffer\n\n/**\n * Color attachment for [RenderTarget].\n * @param index the binding index for [RenderTarget]\n * @param name an optional name for the binding, defaults to `null`\n */\nsealed class ColorAttachment(val index: Int, val name: String?)\nclass ColorBufferAttachment(\n    index: Int,\n    name: String?,\n    val colorBuffer: ColorBuffer,\n    val level: Int\n) : ColorAttachment(index, name)\n\nclass ArrayTextureAttachment(\n    index: Int,\n    name: String?,\n    val arrayTexture: ArrayTexture,\n    val layer: Int,\n    val level: Int\n) : ColorAttachment(index, name)\n\nclass LayeredArrayTextureAttachment(\n    index: Int,\n    name: String?,\n    val arrayTexture: ArrayTexture,\n    val level: Int\n) : ColorAttachment(index, name)\n\nclass VolumeTextureAttachment(\n    index: Int,\n    name: String?,\n    val volumeTexture: VolumeTexture,\n    val layer: Int,\n    val level: Int\n) : ColorAttachment(index, name)\n\nclass LayeredVolumeTextureAttachment(\n    index: Int,\n    name: String?,\n    val volumeTexture: VolumeTexture,\n    val level: Int\n) : ColorAttachment(index, name)\n\nclass ArrayCubemapAttachment(\n    index: Int,\n    name: String?,\n    val arrayCubemap: ArrayCubemap,\n    val side: CubemapSide,\n    val layer: Int,\n    val level: Int\n) : ColorAttachment(index, name)\n\nclass LayeredArrayCubemapAttachment(\n    index: Int,\n    name: String?,\n    val arrayCubemap: ArrayCubemap,\n    val level: Int\n) : ColorAttachment(index, name)\n\nclass CubemapAttachment(\n    index: Int,\n    name: String?,\n    val cubemap: Cubemap,\n    val side: CubemapSide,\n    val level: Int\n) : ColorAttachment(index, name)\n\nclass LayeredCubemapAttachment(\n    index: Int,\n    name: String?,\n    val cubemap: Cubemap,\n    val level: Int\n) : ColorAttachment(index, name)\n\ninterface RenderTarget {\n    /** [Session] in which this render target is created. */\n    val session: Session?\n\n    /** Width in display units. */\n    val width: Int\n\n    /** Height in display units. */\n    val height: Int\n\n    /** Content scaling factor. */\n    val contentScale: Double\n\n    /** Multisampling mode. */\n    val multisample: BufferMultisample\n\n    /** Effective width in pixels. */\n    //@Deprecated(\"use pixelWidth\", replaceWith = ReplaceWith(\"pixelWidth\"))\n    val effectiveWidth: Int get() = (width * contentScale).toInt()\n\n    /** Effective width in pixels. */\n    val pixelWidth: Int get() = (width * contentScale).toInt()\n\n    /** Effective height in pixels. */\n    //@Deprecated(\"use pixelHeight\", replaceWith = ReplaceWith(\"pixelHeight\"))\n    val effectiveHeight: Int get() = (height * contentScale).toInt()\n\n    /** Effective height in pixels. */\n    val pixelHeight: Int get() = (height * contentScale).toInt()\n\n    /** List of [ColorAttachment]s. */\n    val colorAttachments: List<ColorAttachment>\n\n    /** Find the index of a [ColorAttachment] by name. */\n    fun colorAttachmentIndexByName(name: String): Int? {\n        return colorAttachments.find { it.name == name }?.index\n    }\n\n    /** Find [ColorAttachment] by name. */\n    fun colorAttachmentByName(name: String): ColorAttachment? {\n        return colorAttachments.find { it.name == name }\n    }\n\n    val depthBuffer: DepthBuffer?\n\n    companion object {\n        /**\n         * Points to the [RenderTarget] that is currently in use. This is either an\n         * instance of ProgramRenderTarget, which represents the window's surface or to\n         * a user created RenderTarget that is made active using [Drawer.withTarget] or similar.\n         */\n        val active: RenderTarget\n            get() = Driver.instance.activeRenderTarget\n    }\n\n    fun attach(colorBuffer: ColorBuffer, level: Int = 0, name: String? = null)\n    fun attach(depthBuffer: DepthBuffer)\n\n    fun attach(arrayTexture: ArrayTexture, layer: Int, level: Int = 0, name: String? = null)\n    fun attach(arrayCubemap: ArrayCubemap, side: CubemapSide, layer: Int, level: Int = 0, name: String? = null)\n    fun attach(cubemap: Cubemap, side: CubemapSide, level: Int = 0, name: String? = null)\n    fun attach(volumeTexture: VolumeTexture, layer: Int, level: Int = 0, name: String? = null)\n\n    fun attachLayered(arrayTexture: ArrayTexture, level: Int = 0, name: String? = null)\n    fun attachLayered(arrayCubemap: ArrayCubemap, level: Int = 0, name: String? = null)\n    fun attachLayered(cubemap: Cubemap, level: Int = 0, name: String? = null)\n    fun attachLayered(volumeTexture: VolumeTexture, level: Int = 0, name: String? = null)\n\n    /** Detach all color attachments. */\n    fun detachColorAttachments()\n\n    @Deprecated(\"detachColorBuffer is deprecated, use detachColorAttachments\", replaceWith = ReplaceWith(\"detachColorAttachments\"))\n    fun detachColorBuffers()\n\n    /** Detach the [depthBuffer]. */\n    fun detachDepthBuffer()\n\n    /**\n     * Destroy the [RenderTarget].\n     *\n     * In order to fully destroy the RenderTarget, you should\n     *   1. Destroy the color attachments and the depth attachment\n     *   2. Call [detachColorAttachments] and [detachDepthBuffer]\n     *   3. Call [destroy]\n     */\n    fun destroy()\n\n    /** Get a color attachment as a [ColorBuffer]. */\n    fun colorBuffer(index: Int): ColorBuffer\n\n    /**\n     * Clear a color attachment.\n     * @param index the index of the attachment to clear\n     * @param color the [ColorRGBa] to use for clearing\n     */\n    fun clearColor(index: Int, color: ColorRGBa)\n\n    /**\n     * Clear the depth attachment.\n     * @param depth the value to use for clearing the depth attachment, defaults to `1.0`\n     * @param stencil the value to use for clearing the stencil attachment, defaults to `0`\n     */\n    fun clearDepth(depth: Double = 1.0, stencil: Int = 0)\n\n    /**\n     * Set the [BlendMode] for a [ColorAttachment].\n     * @param index the attachment index\n     */\n    fun blendMode(index: Int, blendMode: BlendMode)\n\n    /** Binds the [RenderTarget] to the active target. */\n    fun bind()\n\n    /** Unbinds the [RenderTarget] from the active target. */\n    fun unbind()\n\n    /** Indicates if this [RenderTarget] has a [DepthBuffer] with depth component */\n    val hasDepthBuffer: Boolean\n\n    /** Indicates if this [RenderTarget] has a [DepthBuffer] with stencil index */\n    val hasStencilBuffer: Boolean\n\n    /** Indicates if this [RenderTarget] has at least one [ColorAttachment]. */\n    val hasColorAttachments: Boolean\n\n    fun resolveTo(to: RenderTarget) {\n        require(this.width == to.width && this.height == to.height)\n        require(colorAttachments.size == to.colorAttachments.size)\n        require((to.depthBuffer == null) == (depthBuffer == null))\n        for (i in colorAttachments.indices) {\n            when (val a = colorAttachments[i]) {\n                is ColorBufferAttachment -> {\n                    // TODO remove sourceRectangle and targetRectangle arguments when https://youtrack.jetbrains.com/issue/KT-45542 is fixed\n                    val sourceRectangle = IntRectangle(\n                    0,\n                    0,\n                    this.effectiveWidth / (1 shl 0),\n                    this.effectiveHeight / (1 shl 0)\n                    )\n                    val targetRectangle = IntRectangle(0,0, sourceRectangle.width, sourceRectangle.height)\n                    a.colorBuffer.copyTo((to.colorAttachments[i] as ColorBufferAttachment).colorBuffer, sourceRectangle = sourceRectangle, targetRectangle = targetRectangle)\n                }\n                else -> {\n\n                }\n\n\n            }\n        }\n        depthBuffer?.resolveTo((to.depthBuffer!!))\n    }\n}\n\n@Suppress(\"unused\")\nclass RenderTargetBuilder(private val renderTarget: RenderTarget) {\n\n    @Deprecated(\"you should not use this\", replaceWith = ReplaceWith(\"colorBuffer()\"), level = DeprecationLevel.ERROR)\n    @Suppress(\"UNUSED_PARAMETER\")\n    fun colorBuffer(width: Int, height: Int, contentScale: Double = 1.0, format: ColorFormat = ColorFormat.RGBa, type: ColorType = ColorType.UINT8, multisample: BufferMultisample): Nothing {\n        throw IllegalStateException(\"use colorBuffer without width and height arguments\")\n    }\n\n    /**\n     * attach an existing [ColorBuffer] to the [RenderTarget]\n     * @param colorBuffer an existing [ColorBuffer]\n     * @param level the [ColorBuffer]'s mipmap-level to attach, default is 0\n     */\n    fun colorBuffer(colorBuffer: ColorBuffer, level: Int = 0) {\n        renderTarget.attach(colorBuffer, level)\n    }\n\n    /**\n     * attach an existing [ColorBuffer] to the [RenderTarget] and give it a name\n     * @param name the name for the attachment\n     * @param colorBuffer an existing [ColorBuffer]\n     * @param level the [ColorBuffer]'s mipmap-level to attach, default is 0\n     */\n    fun colorBuffer(name: String, colorBuffer: ColorBuffer, level: Int = 0) {\n        if (colorBuffer.multisample == renderTarget.multisample) {\n            renderTarget.attach(colorBuffer, level, name)\n        } else {\n            throw IllegalArgumentException(\"${colorBuffer.multisample} != ${renderTarget.multisample}\")\n        }\n    }\n\n    /**\n     * create a new [ColorBuffer] and create a named attachment to the [RenderTarget]\n     * @param name the name for the attachment\n     * @param format the [ColorFormat] for the [ColorBuffer], default is [ColorFormat.RGBa]\n     * @param type the [ColorType] for the [ColorBuffer], default is [ColorType.UINT8]\n     */\n    fun colorBuffer(name: String, format: ColorFormat = ColorFormat.RGBa, type: ColorType = ColorType.UINT8) {\n        val cb = _colorBuffer(renderTarget.width, renderTarget.height, renderTarget.contentScale, format, type, renderTarget.multisample)\n        renderTarget.attach(cb, 0, name)\n    }\n\n    /**\n     * create a new [ColorBuffer] and create a nameless attachment to the [RenderTarget]\n     * @param format the [ColorFormat] for the [ColorBuffer], default is [ColorFormat.RGBa]\n     * @param type the [ColorType] for the [ColorBuffer], default is [ColorType.UINT8]\n     */\n    fun colorBuffer(format: ColorFormat = ColorFormat.RGBa, type: ColorType = ColorType.UINT8) {\n        val cb = _colorBuffer(renderTarget.width, renderTarget.height, renderTarget.contentScale, format, type, renderTarget.multisample)\n        renderTarget.attach(cb)\n    }\n\n    /**\n     * attach an existing [ArrayTexture] with a named binding to [RenderTarget]\n     * @param name the name for the attachment\n     * @param arrayTexture the [ArrayTexture] to attach\n     * @param layer the layer of the [ArrayTexture] to attach\n     * @param level mipmap level of the [ArrayTexture] to attach, default is 0\n     */\n    fun arrayTexture(name: String, arrayTexture: ArrayTexture, layer: Int, level: Int = 0) {\n        renderTarget.attach(arrayTexture, layer, level, name)\n    }\n\n    /**\n     * attach an existing [ArrayTexture] with a named binding to [RenderTarget]\n     * @param arrayTexture the [ArrayTexture] to attach\n     * @param layer the layer of the [ArrayTexture] to attach\n     * @param level mipmap level of the [ArrayTexture] to attach, default is 0\n     */\n    fun arrayTexture(arrayTexture: ArrayTexture, layer: Int, level: Int = 0) {\n        renderTarget.attach(arrayTexture, layer, level)\n    }\n\n    /**\n     * attach an existing [ArrayCubemap] with a named binding to [RenderTarget]\n     * @param name the name for the attachment\n     * @param arrayCubemap the [ArrayCubemap] to attach\n     * @param side the [CubemapSide] of the [ArrayCubemap] to attach\n     * @param layer the layer of the [ArrayCubemap] to attach\n     * @param level mipmap level of the [ArrayCubemap] to attach, default is 0\n     */\n    fun arrayCubemap(name: String, arrayCubemap: ArrayCubemap, side: CubemapSide, layer: Int, level: Int = 0) {\n        renderTarget.attach(arrayCubemap, side, layer, level, name)\n    }\n\n    /**\n     * attach an existing [ArrayCubemap] with a nameless binding to [RenderTarget]\n     * @param arrayCubemap the [ArrayCubemap] to attach\n     * @param side the [CubemapSide] of the [ArrayCubemap] to attach\n     * @param layer the layer of the [ArrayCubemap] to attach\n     * @param level level of the [ArrayCubemap] to attach, default is 0\n     */\n    fun arrayCubemap(arrayCubemap: ArrayCubemap, side: CubemapSide, layer: Int, level: Int = 0) {\n        renderTarget.attach(arrayCubemap, side, layer, level)\n    }\n\n    /**\n     * attach an existing [Cubemap] with a named binding to [RenderTarget]\n     * @param name the name for the attachment\n     * @param cubemap the [Cubemap] to attach\n     * @param side the [CubemapSide] of the [Cubemap] to attach\n     * @param level mipmap level of the [Cubemap] to attach, default is 0\n     */\n    fun cubemap(name: String, cubemap: Cubemap, side: CubemapSide, level: Int = 0) {\n        renderTarget.attach(cubemap, side, level, name)\n    }\n\n    /**\n     * attach an existing [Cubemap] with a nameless binding to [RenderTarget]\n     * @param cubemap the [Cubemap] to attach\n     * @param side the [CubemapSide] of the [Cubemap] to attach\n     * @param level mipmap level of the [Cubemap] to attach, default is 0\n     */\n    fun cubemap(cubemap: Cubemap, side: CubemapSide, level: Int = 0) {\n        renderTarget.attach(cubemap, side, level)\n    }\n\n    /**\n     * attach an existing [VolumeTexture] with a named binding to [RenderTarget]\n     * @param name the name for the attachment\n     * @param volumeTexture the [VolumeTexture] to attach\n     * @param layer the layer of the [VolumeTexture] to attach\n     * @param level mipmap level of the [VolumeTexture] to attach, default is 0\n     */\n    fun volumeTexture(name: String, volumeTexture: VolumeTexture, layer: Int, level: Int = 0) {\n        renderTarget.attach(volumeTexture, layer, level, name)\n    }\n\n    /**\n     * attach an existing [VolumeTexture] with a nameless binding to [RenderTarget]\n     * @param volumeTexture the [VolumeTexture] to attach\n     * @param layer the layer of the [VolumeTexture] to attach\n     * @param level mipmap level of the [VolumeTexture] to attach, default is 0\n     */\n    fun volumeTexture(volumeTexture: VolumeTexture, layer: Int, level: Int = 0) {\n        renderTarget.attach(volumeTexture, layer, level)\n    }\n\n    /**\n     * create and attach a [DepthBuffer]\n     * @param format the [DepthFormat] for the [DepthBuffer], default is [DepthFormat.DEPTH_STENCIL]\n     */\n    fun depthBuffer(format: DepthFormat = DepthFormat.DEPTH_STENCIL) {\n        renderTarget.attach(_depthBuffer(renderTarget.effectiveWidth, renderTarget.effectiveHeight, format, renderTarget.multisample))\n        renderTarget.clearDepth()\n    }\n\n    /**\n     * attach an existing [DepthBuffer]\n     *  @param depthBuffer the [DepthBuffer] to attach to [RenderTarget]\n     */\n    fun depthBuffer(depthBuffer: DepthBuffer) {\n        if (depthBuffer.multisample == renderTarget.multisample) {\n            renderTarget.attach(depthBuffer)\n        } else {\n            throw IllegalArgumentException(\"${depthBuffer.multisample} != ${renderTarget.multisample}\")\n        }\n    }\n}\n\n/**\n * build a [RenderTarget]\n * @param width positive non-zero width of the [RenderTarget]\n * @param height positive non-zero height of the [RenderTarget]\n * @param multisample determine if the [RenderTarget] uses multi-sampling, default is disabled\n * @param session specify the session under which the [RenderTarget] should be created, default is [Session.active]\n */\n@OptIn(ExperimentalContracts::class)\nfun renderTarget(width: Int, height: Int,\n                 contentScale: Double = 1.0,\n                 multisample: BufferMultisample = BufferMultisample.Disabled,\n                 session: Session? = Session.active,\n                 builder: RenderTargetBuilder.() -> Unit): RenderTarget {\n\n    contract {\n        callsInPlace(builder, InvocationKind.EXACTLY_ONCE)\n    }\n\n    if (width <= 0 || height <= 0 || width > Driver.instance.properties.maxTextureSize || height > Driver.instance.properties.maxTextureSize) {\n        error(\"unsupported resolution ($width×$height)\")\n    }\n\n    val effectiveMultisample = when (multisample) {\n        is BufferMultisample.SampleCount -> {\n            if (multisample.sampleCount > Driver.instance.properties.maxRenderTargetSamples) {\n                BufferMultisample.SampleCount(Driver.instance.properties.maxRenderTargetSamples)\n            } else {\n                multisample\n            }\n        }\n        else -> multisample\n    }\n\n    val renderTarget = Driver.instance.createRenderTarget(width, height, contentScale, effectiveMultisample, session)\n    RenderTargetBuilder(renderTarget).builder()\n    return renderTarget\n}","package org.openrndr.draw\n\nimport org.openrndr.internal.Driver\n\nprivate val sessionStack = mutableMapOf<Long, ArrayDeque<Session>>()\n\n/**\n * Session statistics\n */\nclass SessionStatistics(\n        val renderTargets: Int,\n        val colorBuffers: Int,\n        val depthBuffers: Int,\n        val bufferTextures: Int,\n        val indexBuffers: Int,\n        val vertexBuffers: Int,\n        val shaders: Int,\n        val cubemaps: Int,\n        val arrayTextures: Int,\n        val computeShaders: Int,\n        val atomicCounterBuffers: Int,\n        val arrayCubemaps: Int,\n        val shaderStorageBuffers: Int)\n\n/**\n * Session\n */\nclass Session(val parent: Session?) {\n    val context = Driver.instance.contextID\n\n    companion object {\n        /**\n         * The session stack (on the active context)\n         */\n        val stack: ArrayDeque<Session>\n            get() = sessionStack.getOrPut(Driver.instance.contextID) { ArrayDeque<Session>().apply { addLast(Session(null)) } }\n\n        /**\n         * The active session (on the active context)\n         */\n        val active: Session\n            get() = stack.last()\n\n        /**\n         * The root session (on the active context)\n         */\n        val root: Session\n            get() = stack.first()\n\n        /**\n         * Ends the active session and pops it off the session stack (on the active context)\n         */\n        fun endActive() {\n            val session = sessionStack.getValue(Driver.instance.contextID).removeLast()\n            session.end()\n        }\n    }\n\n    private val children = mutableListOf<Session>()\n\n    private val renderTargets = mutableSetOf<RenderTarget>()\n    private val colorBuffers = mutableSetOf<ColorBuffer>()\n    private val depthBuffers = mutableSetOf<DepthBuffer>()\n    private val bufferTextures = mutableSetOf<BufferTexture>()\n    private val vertexBuffers = mutableSetOf<VertexBuffer>()\n    private val shaders = mutableSetOf<Shader>()\n    private val computeShaders = mutableSetOf<ComputeShader>()\n    private val cubemaps = mutableSetOf<Cubemap>()\n    private val arrayTextures = mutableSetOf<ArrayTexture>()\n    private val arrayCubemaps = mutableSetOf<ArrayCubemap>()\n    private val indexBuffers = mutableSetOf<IndexBuffer>()\n    private val volumeTextures = mutableSetOf<VolumeTexture>()\n    private val shaderStorageBuffers = mutableSetOf<ShaderStorageBuffer>()\n    private val atomicCounterBuffers = mutableSetOf<AtomicCounterBuffer>()\n\n    /** Session statistics */\n    val statistics\n        get() =\n            SessionStatistics(renderTargets = renderTargets.size,\n                    colorBuffers = colorBuffers.size,\n                    depthBuffers = depthBuffers.size,\n                    bufferTextures = bufferTextures.size,\n                    indexBuffers = indexBuffers.size,\n                    vertexBuffers = vertexBuffers.size,\n                    shaders = shaders.size,\n                    cubemaps = cubemaps.size,\n                    arrayTextures = arrayTextures.size,\n                    computeShaders = computeShaders.size,\n                    atomicCounterBuffers = atomicCounterBuffers.size,\n                    arrayCubemaps = arrayCubemaps.size,\n                    shaderStorageBuffers = shaderStorageBuffers.size)\n\n    fun track(renderTarget: RenderTarget) = renderTargets.add(renderTarget)\n    fun untrack(renderTarget: RenderTarget) = renderTargets.remove(renderTarget)\n\n    fun track(colorBuffer: ColorBuffer) = colorBuffers.add(colorBuffer)\n    fun untrack(colorBuffer: ColorBuffer) = colorBuffers.remove(colorBuffer)\n\n    fun track(depthBuffer: DepthBuffer) = depthBuffers.add(depthBuffer)\n    fun untrack(depthBuffer: DepthBuffer) = depthBuffers.remove(depthBuffer)\n\n    fun track(vertexBuffer: VertexBuffer) = vertexBuffers.add(vertexBuffer)\n    fun untrack(vertexBuffer: VertexBuffer) = vertexBuffers.remove(vertexBuffer)\n\n    fun track(indexBuffer: IndexBuffer) = indexBuffers.add(indexBuffer)\n    fun untrack(indexBuffer: IndexBuffer) = indexBuffers.remove(indexBuffer)\n\n    fun track(shader: Shader) = shaders.add(shader)\n    fun untrack(shader: Shader) = shaders.remove(shader)\n\n    fun track(computeShader: ComputeShader) = computeShaders.add(computeShader)\n    fun untrack(computeShader: ComputeShader) = computeShaders.remove(computeShader)\n\n    fun track(cubemap: Cubemap) = cubemaps.add(cubemap)\n    fun untrack(cubemap: Cubemap) = cubemaps.remove(cubemap)\n\n    fun track(bufferTexture: BufferTexture) = bufferTextures.add(bufferTexture)\n    fun untrack(bufferTexture: BufferTexture) = bufferTextures.remove(bufferTexture)\n\n    fun track(arrayTexture: ArrayTexture) = arrayTextures.add(arrayTexture)\n    fun untrack(arrayTexture: ArrayTexture) = arrayTextures.remove(arrayTexture)\n\n    fun track(atomicCounterBuffer: AtomicCounterBuffer) = atomicCounterBuffers.add(atomicCounterBuffer)\n    fun untrack(atomicCounterBuffer: AtomicCounterBuffer) = atomicCounterBuffers.remove(atomicCounterBuffer)\n\n    fun track(arrayCubemap: ArrayCubemap) = arrayCubemaps.add(arrayCubemap)\n    fun untrack(arrayCubemap: ArrayCubemap) = arrayCubemaps.remove(arrayCubemap)\n\n    fun track(volumeTexture: VolumeTexture) = volumeTextures.add(volumeTexture)\n    fun untrack(volumeTexture: VolumeTexture) = volumeTextures.remove(volumeTexture)\n\n    fun track(shaderStorageBuffer: ShaderStorageBuffer) = shaderStorageBuffers.add(shaderStorageBuffer)\n    fun untrack(shaderStorageBuffer: ShaderStorageBuffer) = shaderStorageBuffers.remove(shaderStorageBuffer)\n\n    /**\n     * Fork the session\n     */\n    fun fork(): Session {\n        val child = Session(this)\n        sessionStack.getValue(Driver.instance.contextID).addLast(child)\n        children.add(child)\n        return child\n    }\n\n    /**\n     * Ends the session, destroys any GPU resources in use by the session\n     */\n    fun end() {\n        parent?.children?.remove(this)\n\n        for (child in children.map { it }) {\n            child.end()\n        }\n        children.clear()\n\n        renderTargets.map { it }.forEach {\n            it.detachColorAttachments()\n            it.detachDepthBuffer()\n            it.destroy()\n        }\n        renderTargets.clear()\n\n        colorBuffers.map { it }.forEach {\n            it.destroy()\n        }\n        colorBuffers.clear()\n\n        depthBuffers.map { it }.forEach {\n            it.destroy()\n        }\n        depthBuffers.clear()\n\n        vertexBuffers.map { it }.forEach {\n            it.destroy()\n        }\n        vertexBuffers.clear()\n\n        indexBuffers.map { it }.forEach {\n            it.destroy()\n        }\n        indexBuffers.clear()\n\n        cubemaps.map { it }.forEach {\n            it.destroy()\n        }\n        cubemaps.clear()\n\n        bufferTextures.map { it }.forEach {\n            it.destroy()\n        }\n        bufferTextures.clear()\n\n        shaders.map { it }.forEach {\n            it.destroy()\n        }\n        shaders.clear()\n\n        computeShaders.map { it }.forEach {\n            it.destroy()\n        }\n        computeShaders.clear()\n\n        arrayTextures.map { it }.forEach {\n            it.destroy()\n        }\n        arrayTextures.clear()\n\n        arrayCubemaps.map { it }.forEach {\n            it.destroy()\n        }\n        arrayCubemaps.clear()\n\n\n        shaderStorageBuffers.map { it }.forEach {\n            it.destroy()\n        }\n        shaderStorageBuffers.clear()\n    }\n}\n\n/** Runs code inside a (short-lived) session */\nfun session(code: () -> Unit) {\n    val s = Session.active.fork()\n    code()\n    s.end()\n}\n\n/**\n * Mark a GPU resource or code that uses GPU resources as persistent\n */\nfun <T> persistent(builder: () -> T): T {\n    Session.stack.addLast(Session.root)\n    val result = builder()\n    Session.stack.removeLast()\n    return result\n}","package org.openrndr.draw\n\nimport org.openrndr.internal.Driver\n\ndata class ShadeStructure(\n    var structDefinitions: String? = null,\n    var uniforms: String? = null,\n    var attributes: String? = null,\n    var buffers: String? = null,\n    var vertexTransform: String? = null,\n    var geometryTransform: String? = null,\n    var fragmentTransform: String? = null,\n    var vertexPreamble: String? = null,\n    var geometryPreamble: String? = null,\n    var fragmentPreamble: String? = null,\n    var outputs: String? = null,\n    var varyingOut: String? = null,\n    var varyingIn: String? = null,\n    var varyingBridge: String? = null,\n    var suppressDefaultOutput: Boolean = false\n)\n\nabstract class ShadeStyleManager(val name: String) {\n    companion object {\n        fun fromGenerators(\n            name: String,\n            vsGenerator: (ShadeStructure) -> String,\n            tscGenerator: ((ShadeStructure) -> String)? = null,\n            tseGenerator: ((ShadeStructure) -> String)? = null,\n            gsGenerator: ((ShadeStructure) -> String)? = null,\n            fsGenerator: (ShadeStructure) -> String\n        ): ShadeStyleManager {\n            return Driver.instance.createShadeStyleManager(\n                name,\n                vsGenerator = vsGenerator,\n                tcsGenerator = tscGenerator,\n                tesGenerator = tseGenerator,\n                gsGenerator = gsGenerator,\n                fsGenerator = fsGenerator\n            )\n        }\n    }\n\n    abstract fun shader(\n        style: ShadeStyle?,\n        vertexFormats: List<VertexFormat>,\n        instanceFormats: List<VertexFormat> = emptyList()\n    ): Shader\n\n    fun shader(\n        style: ShadeStyle?,\n        format: VertexFormat\n    ): Shader = shader(style, listOf(format), emptyList())\n}","package org.openrndr.draw\n\nimport org.openrndr.internal.Driver\nimport kotlin.math.max\n\nexpect interface ShaderStorageBuffer {\n    val session: Session?\n    val format: ShaderStorageFormat\n\n    /* Gives a read/write shadow for the shader storage buffer\n    */\n    val shadow: ShaderStorageBufferShadow\n\n    fun clear()\n    fun destroy()\n\n    fun put(elementOffset: Int = 0, putter: BufferWriterStd430.() -> Unit): Int\n\n    fun vertexBufferView(): VertexBuffer\n}\n\ninterface ShaderStorageElement {\n    val name: String\n    val offset: Int\n    val arraySize: Int\n}\n\nenum class BufferPrimitiveType(val componentCount: Int, val sizeInBytes: Int, val alignmentInBytes: Int) {\n    UINT32(1, 4, 4),\n    INT32(1, 4, 4),\n    BOOLEAN(1, 4, 4),\n    FLOAT32(1, 4, 4),\n\n    FLOAT64(1, 8, 8),\n\n    VECTOR2_BOOLEAN(2, 8, 8),\n    VECTOR2_INT32(2, 8, 8),\n    VECTOR2_UINT32(2, 8, 8),\n    VECTOR2_FLOAT32(2, 8, 8),\n\n    VECTOR2_FLOAT64(2, 16, 16),\n\n    VECTOR3_BOOLEAN(2, 12, 16),\n    VECTOR3_INT32(2, 12, 16),\n    VECTOR3_UINT32(2, 12, 16),\n    VECTOR3_FLOAT32(3, 12, 16),\n\n    VECTOR3_FLOAT64(3, 24, 32),\n\n    VECTOR4_BOOLEAN(2, 16, 16),\n    VECTOR4_INT32(2, 16, 16),\n    VECTOR4_UINT32(2, 16, 16),\n    VECTOR4_FLOAT32(4, 16, 16),\n\n    VECTOR4_FLOAT64(4, 16, 32),\n\n    MATRIX22_FLOAT32(4, 4 * 4, 8),\n    MATRIX33_FLOAT32(9, 9 * 4, 16),\n    MATRIX44_FLOAT32(16, 16 * 4, 16),\n}\n\ndata class ShaderStoragePrimitive(\n    override val name: String,\n    val type: BufferPrimitiveType,\n    override val arraySize: Int = 1,\n    override var offset: Int = 0,\n    var padding: Int = 0\n) : ShaderStorageElement\n\n\ndata class ShaderStorageStruct(\n    val structName: String,\n    override val name: String,\n    val elements: List<ShaderStorageElement>,\n    override val arraySize: Int = 1,\n    override var offset: Int = 0,\n) : ShaderStorageElement\n\nclass ShaderStorageFormat {\n    var elements: MutableList<ShaderStorageElement> = mutableListOf()\n    private var formatSize = 0\n\n    /**\n     * The size of the [ShaderStorageFormat] in bytes\n     */\n    val size get() = formatSize\n\n\n    /**\n     * Adds a custom member to the [ShaderStorageFormat]\n     */\n    fun primitive(name: String, type: BufferPrimitiveType, arraySize: Int = 1) {\n        val item = ShaderStoragePrimitive(name, type, arraySize)\n        elements.add(item)\n    }\n\n    fun struct(structName: String, name: String, arraySize: Int = 1, builder: ShaderStorageFormat.() -> Unit) {\n        val structElements = ShaderStorageFormat().let {\n            it.builder()\n            it.elements\n        }.filterIsInstance<ShaderStoragePrimitive>()\n\n        val struct = ShaderStorageStruct(structName, name, structElements, arraySize)\n        elements.add(struct)\n    }\n\n    override fun toString(): String {\n        return \"ShaderStorageFormat{\" +\n                \"items=\" + elements +\n                \", formatSize=\" + formatSize +\n                '}'\n    }\n\n    fun hasMember(name: String): Boolean = elements.any { it.name == name }\n\n    override fun hashCode(): Int {\n        return elements.hashCode()\n    }\n\n    fun commit() {\n        val memberCount = elements.sumOf { if (it is ShaderStorageStruct) it.elements.size else 1 }\n        val paddings = IntArray(memberCount)\n        var largestAlign = 0\n        var ints = 0\n\n        var paddingIdx = -1\n        /* Compute necessary padding after each field */\n        for (idx in elements.indices) {\n\n            when (val element = elements[idx]) {\n                is ShaderStoragePrimitive -> {\n                    val len = element.arraySize\n                    val align = element.type.alignmentInBytes\n\n                    largestAlign = max(largestAlign, align)\n\n                    if (idx >= 1) {\n                        val neededPadding = (align - ints % align) % align\n                        paddings[paddingIdx] = neededPadding\n                        ints += neededPadding\n                    }\n\n                    ints += element.type.sizeInBytes * len\n                    paddingIdx++\n                }\n\n                is ShaderStorageStruct -> {\n                    for (sIdx in element.elements.indices) {\n                        val structMember = element.elements[sIdx] as ShaderStoragePrimitive\n                        val len = structMember.arraySize\n                        val align = structMember.type.alignmentInBytes\n\n                        largestAlign = max(largestAlign, align)\n\n                        if (idx + sIdx >= 1) {\n                            val neededPadding = (align - ints % align) % align\n                            paddings[paddingIdx] = neededPadding\n                            ints += neededPadding\n                        }\n\n                        ints += structMember.type.sizeInBytes * len\n                        paddingIdx++\n                    }\n                }\n            }\n        }\n\n        /* Compute padding at the end of the struct */\n        val endPadding = (largestAlign - ints % largestAlign) % largestAlign\n        paddings[memberCount - 1] = endPadding\n\n        paddingIdx = 0\n\n        for (memberIdx in elements.indices) {\n\n            when (val element = elements[memberIdx]) {\n                is ShaderStoragePrimitive -> {\n                    val padding = paddings[paddingIdx]\n\n                    element.offset = element.arraySize * element.type.sizeInBytes\n                    element.padding = padding\n\n                    formatSize += element.offset + padding\n                    paddingIdx++\n                }\n\n                is ShaderStorageStruct -> {\n                    var totalSize = 0\n\n                    for (sIdx in element.elements.indices) {\n                        val structMember = element.elements[sIdx] as ShaderStoragePrimitive\n                        val padding = paddings[paddingIdx]\n\n                        structMember.offset = structMember.arraySize * structMember.type.sizeInBytes\n                        structMember.padding = padding\n\n                        totalSize += structMember.offset + padding\n                        paddingIdx++\n                    }\n\n                    formatSize += totalSize * element.arraySize\n                }\n            }\n        }\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other == null || this::class != other::class) return false\n\n        other as ShaderStorageFormat\n\n        return elements == other.elements\n    }\n}\n\nfun shaderStorageFormat(builder: ShaderStorageFormat.() -> Unit): ShaderStorageFormat {\n    return ShaderStorageFormat().apply {\n        builder()\n        commit()\n    }\n}\n\nfun shaderStorageFormatToVertexFormat(format: ShaderStorageFormat): VertexFormat {\n\n    return vertexFormat {\n        if (format.elements.first() is ShaderStorageStruct) {\n            val outerStruct = format.elements.first() as ShaderStorageStruct\n            for (member in outerStruct.elements) {\n                if (member is ShaderStoragePrimitive) {\n                    val vet = when (member.type) {\n                        BufferPrimitiveType.VECTOR4_FLOAT32 -> VertexElementType.VECTOR4_FLOAT32\n                        BufferPrimitiveType.VECTOR3_FLOAT32 -> VertexElementType.VECTOR3_FLOAT32\n                        BufferPrimitiveType.VECTOR2_FLOAT32 -> VertexElementType.VECTOR2_FLOAT32\n                        BufferPrimitiveType.MATRIX22_FLOAT32 -> VertexElementType.MATRIX33_FLOAT32\n                        BufferPrimitiveType.MATRIX33_FLOAT32 -> VertexElementType.MATRIX33_FLOAT32\n                        BufferPrimitiveType.MATRIX44_FLOAT32 -> VertexElementType.MATRIX44_FLOAT32\n                        BufferPrimitiveType.INT32 -> VertexElementType.INT32\n                        BufferPrimitiveType.UINT32 -> VertexElementType.UINT32\n                        BufferPrimitiveType.FLOAT32 -> VertexElementType.FLOAT32\n                        else -> error(\"unsupported type '${member.type}\")\n                    }\n\n                    val padding = member.padding\n                    attribute(member.name, vet)\n                    if (padding > 0) {\n                        padding(padding)\n                    }\n                }\n            }\n        } else {\n            error(\"first item of storage buffer format must be a struct\")\n        }\n\n    }\n}\n\nfun shaderStorageBuffer(format: ShaderStorageFormat): ShaderStorageBuffer {\n    return Driver.instance.createShaderStorageBuffer(format)\n}\n\n","package org.openrndr.draw\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.math.*\n\ndata class UniformBlockLayout(val sizeInBytes: Int, val entries: Map<String, UniformDescription>)\n\nenum class UniformType(val sizeInBytes: Int) {\n    INT32(4),\n    VECTOR2_INT32(8),\n    VECTOR3_INT32(12),\n    VECTOR4_INT32(16),\n    FLOAT32(4),\n    VECTOR2_FLOAT32(8),\n    VECTOR3_FLOAT32(12),\n    VECTOR4_FLOAT32(16),\n    MATRIX22_FLOAT32(4 * 4),\n    MATRIX33_FLOAT32(9 * 4),\n    MATRIX44_FLOAT32(16 * 4),\n    COLOR_BUFFER_SAMPLER(4),\n}\n\ndata class UniformDescription(val name: String, val type: UniformType, val size: Int, val offset: Int, val stride:Int)\n\ninterface UniformBlock {\n    val dirty:Boolean\n    val layout: UniformBlockLayout\n    fun uniform(name: String, value: Float)\n    fun uniform(name: String, value: Vector2)\n    fun uniform(name: String, value: Vector3)\n    fun uniform(name: String, value: Vector4)\n    fun uniform(name: String, value: ColorRGBa)\n    fun uniform(name: String, value: Matrix44)\n    fun uniform(name: String, value: Matrix55)\n    fun uniform(name: String, value: Array<Float>)\n    fun uniform(name: String, value: Array<Vector2>)\n    fun uniform(name: String, value: Array<Vector3>)\n    fun uniform(name: String, value: Array<Vector4>)\n    fun upload()\n}","package org.openrndr.draw\n\nimport org.openrndr.utils.buffer.MPPBuffer\n\n\nexpect abstract class VertexBuffer {\n    abstract val session: Session?\n\n    abstract val vertexFormat: VertexFormat\n    abstract val vertexCount: Int\n\n    /**\n     * Gives a read/write shadow for the vertex buffer\n     */\n    abstract val shadow: VertexBufferShadow\n    /**\n     * Destroy the vertex buffer\n     */\n    abstract fun destroy()\n\n    fun put(elementOffset: Int = 0, putter: BufferWriter.() -> Unit): Int\n\n    abstract fun write(\n        source: MPPBuffer,\n        targetByteOffset: Int = 0,\n        sourceByteOffset: Int = 0,\n        byteLength: Int = source.capacity()\n    )\n\n    companion object {\n        fun createDynamic(format: VertexFormat, vertexCount: Int, session: Session? = Session.active): VertexBuffer\n        fun createFromFloats(format: VertexFormat, data: FloatArray, session: Session?): VertexBuffer\n    }\n}\n\n/**\n * VertexBuffer builder function.\n * @param vertexFormat a VertexFormat object that describes the vertex layout\n * @param vertexCount the number of vertices the vertex buffer should hold\n */\nfun vertexBuffer(vertexFormat: VertexFormat, vertexCount: Int, session: Session? = Session.active): VertexBuffer {\n    return VertexBuffer.createDynamic(vertexFormat, vertexCount, session)\n}","package org.openrndr.draw\n/**\n * Vertex element type enumeration\n */\nenum class VertexElementType(val componentCount: Int, val sizeInBytes: Int) {\n    /** signed 8-bit integer */\n    INT8(1, 1),\n    /** unsigned 8 bit integer */\n    UINT8(1, 1),\n\n    UINT16(1, 2),\n    /** signed 16-bit integer */\n    INT16(1, 2),\n\n    UINT32(1, 4),\n\n    /** signed 32-bit integer */\n    INT32(1, 4),\n\n    VECTOR2_UINT8(2, 2),\n    VECTOR2_INT8(2, 2),\n    VECTOR2_UINT16(2, 4),\n    VECTOR2_INT16(2, 4),\n    VECTOR2_UINT32(2, 8),\n    VECTOR2_INT32(2, 8),\n\n    VECTOR3_UINT8(3, 3),\n    VECTOR3_INT8(3, 3),\n    VECTOR3_UINT16(3, 6),\n    VECTOR3_INT16(3, 6),\n    VECTOR3_UINT32(3, 12),\n    VECTOR3_INT32(3, 12),\n\n    VECTOR4_UINT8(3, 3),\n    VECTOR4_INT8(4, 4),\n    VECTOR4_UINT16(4, 8),\n    VECTOR4_INT16(4, 8),\n    VECTOR4_UINT32(4, 16),\n    VECTOR4_INT32(4, 16),\n\n    /** 32 bit float, or single precision float scalar */\n    FLOAT32(1, 4),\n    /** 32-bit float, or single precision float 2-component vector */\n    VECTOR2_FLOAT32(2, 8),\n    /** 32-bit float, or single precision float 3-component vector */\n    VECTOR3_FLOAT32(3, 12),\n    /** 32-bit float, or single precision float 4-component vector */\n    VECTOR4_FLOAT32(4, 16),\n    /** 32 bit float, or single precision float 2x2 matrix */\n    MATRIX22_FLOAT32(4, 4 * 4),\n    /** 32 bit float, or single precision float 3x3 matrix */\n    MATRIX33_FLOAT32(9, 9 * 4),\n    /** 32 bit float, or single precision float 4x4 matrix */\n    MATRIX44_FLOAT32(16, 16 * 4),\n}\n","package org.openrndr.draw\n\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\n\ndata class VertexElement(val attribute: String, val offset: Int, val type: VertexElementType, val arraySize: Int)\n\n/**\n * VertexBuffer Layout describes how data is organized in the VertexBuffer\n */\nclass VertexFormat {\n\n    var items: MutableList<VertexElement> = mutableListOf()\n    private var vertexSize = 0\n\n    /**\n     * The size of the [VertexFormat] in bytes\n     */\n    val size get() = vertexSize\n\n    /**\n     * Appends a position component to the layout\n     * @param dimensions\n     */\n    fun position(dimensions: Int) = attribute(\"position\", floatTypeFromDimensions(dimensions))\n\n    /**\n     * Insert padding in the layout\n     * @param paddingInBytes the amount of padding in bytes\n     */\n    fun padding(paddingInBytes: Int) = attribute(\"_\", VertexElementType.UINT8, paddingInBytes)\n\n    private fun floatTypeFromDimensions(dimensions: Int): VertexElementType {\n        return when (dimensions) {\n            1 -> VertexElementType.FLOAT32\n            2 -> VertexElementType.VECTOR2_FLOAT32\n            3 -> VertexElementType.VECTOR3_FLOAT32\n            4 -> VertexElementType.VECTOR4_FLOAT32\n            else -> throw IllegalArgumentException(\"dimensions can only be 1, 2, 3 or 4 (got $dimensions)\")\n        }\n    }\n\n    /**\n     * Appends a normal component to the layout\n     * @param dimensions the number of dimensions of the normal vector\n     */\n    fun normal(dimensions: Int) = attribute(\"normal\", floatTypeFromDimensions(dimensions))\n\n    /**\n     * Appends a color attribute to the layout\n     * @param dimensions\n     */\n    fun color(dimensions: Int) = attribute(\"color\", floatTypeFromDimensions(dimensions))\n\n    fun textureCoordinate(dimensions: Int = 2, index: Int = 0) = attribute(\"texCoord$index\", floatTypeFromDimensions(dimensions))\n\n\n    /**\n     * Adds a custom attribute to the [VertexFormat]\n     */\n    fun attribute(name: String, type: VertexElementType, arraySize: Int = 1) {\n        val offset = items.sumOf { it.arraySize * it.type.sizeInBytes }\n        val item = VertexElement(name, offset, type, arraySize)\n        items.add(item)\n        vertexSize += type.sizeInBytes * arraySize\n    }\n\n    override fun toString(): String {\n        return \"VertexFormat{\" +\n                \"items=\" + items +\n                \", vertexSize=\" + vertexSize +\n                '}'\n    }\n\n    fun hasAttribute(name: String): Boolean = items.any { it.attribute == name }\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other !is VertexFormat) return false\n\n\n        return items == other.items\n    }\n\n    override fun hashCode(): Int {\n        return items.hashCode()\n    }\n\n\n}\n\n/**\n * Build a vertex format\n */\n@OptIn(ExperimentalContracts::class)\nfun vertexFormat(builder: VertexFormat.() -> Unit): VertexFormat {\n    contract {\n        callsInPlace(builder, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return VertexFormat().apply { builder() }\n}\n","package org.openrndr.draw.font\n\n\nenum class BufferFlag {\n    VOLATILE,\n    COHERENT,\n    RESTRICT\n}\nenum class BufferAccess {\n    READ,\n    READ_WRITE,\n    WRITE\n}","package org.openrndr.internal\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.draw.*\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.Vector3\nimport org.openrndr.platform.Platform\nimport org.openrndr.platform.PlatformType\nimport org.openrndr.shape.Circle\nimport kotlin.math.abs\n\n\nclass CircleDrawer {\n    private val vertices: VertexBuffer = VertexBuffer.createDynamic(VertexFormat().apply {\n        position(3)\n        normal(3)\n        textureCoordinate(2)\n    }, 6, Session.root)\n\n    internal var batch = CircleBatch.create(10_000)\n    private var count = 0\n\n    private val singleBatches = (0 until DrawerConfiguration.vertexBufferMultiBufferCount).map { CircleBatch.create(1) }\n\n    private val shaderManager: ShadeStyleManager = ShadeStyleManager.fromGenerators(\n        \"circle\",\n        vsGenerator = Driver.instance.shaderGenerators::circleVertexShader,\n        fsGenerator = Driver.instance.shaderGenerators::circleFragmentShader\n    )\n\n    internal fun ensureBatchSize(size: Int) {\n        if (batch.size < size) {\n            batch.destroy()\n            batch = CircleBatch.create(size, session = Session.root)\n        }\n    }\n\n    init {\n        val w = vertices.shadow.writer()\n\n        w.rewind()\n        val x = 0.0\n        val y = 0.0\n        val radius = 1.0\n        val pa = Vector3(x - radius, y - radius, 0.0)\n        val pb = Vector3(x + radius, y - radius, 0.0)\n        val pc = Vector3(x + radius, y + radius, 0.0)\n        val pd = Vector3(x - radius, y + radius, 0.0)\n\n        val ta = Vector2(0.0, 0.0)\n        val tb = Vector2(1.0, 0.0)\n        val tc = Vector2(1.0, 1.0)\n        val td = Vector2(0.0, 1.0)\n\n        val n = Vector3(0.0, 0.0, -1.0)\n        w.apply {\n            write(pa); write(n); write(ta)\n            write(pd); write(n); write(td)\n            write(pc); write(n); write(tc)\n\n            write(pc); write(n); write(tc)\n            write(pb); write(n); write(tb)\n            write(pa); write(n); write(ta)\n        }\n        vertices.shadow.upload()\n    }\n\n    fun drawCircles(drawContext: DrawContext, drawStyle: DrawStyle, positions: List<Vector2>, radii: List<Double>) {\n        ensureBatchSize(positions.size)\n        batch.geometry.shadow.writer().apply {\n            rewind()\n            for (i in positions.indices) {\n                write(Vector3(positions[i].x, positions[i].y, 0.0))\n                write(Vector2(abs(radii[i])))\n            }\n        }\n        batch.geometry.shadow.uploadElements(0, positions.size)\n\n        batch.drawStyle.shadow.writer().apply {\n            rewind()\n            for (i in positions.indices) {\n                write(drawStyle)\n            }\n        }\n        batch.drawStyle.shadow.uploadElements(0, positions.size)\n        drawCircles(drawContext, drawStyle, positions.size)\n    }\n\n    fun drawCircles(drawContext: DrawContext, drawStyle: DrawStyle, positions: List<Vector2>, radius: Double) {\n        ensureBatchSize(positions.size)\n        batch.geometry.shadow.writer().apply {\n            rewind()\n            for (i in positions.indices) {\n                write(Vector3(positions[i].x, positions[i].y, 0.0))\n                write(Vector2(abs(radius)))\n            }\n        }\n        batch.geometry.shadow.uploadElements(0, positions.size)\n\n        batch.drawStyle.shadow.writer().apply {\n            rewind()\n            for (i in positions.indices) {\n                write(drawStyle)\n            }\n        }\n        batch.drawStyle.shadow.uploadElements(0, positions.size)\n        drawCircles(drawContext, drawStyle, positions.size)\n    }\n\n    fun drawCircles(drawContext: DrawContext, drawStyle: DrawStyle, circles: List<Circle>) {\n        ensureBatchSize(circles.size)\n        batch.geometry.shadow.writer().apply {\n            rewind()\n            for (i in circles.indices) {\n                write(circles[i].center.xy0)\n                write(Vector2(abs(circles[i].radius)))\n            }\n        }\n        batch.geometry.shadow.uploadElements(0, circles.size)\n\n        batch.drawStyle.shadow.writer().apply {\n            rewind()\n            for (i in circles.indices) {\n                write(drawStyle)\n            }\n        }\n        batch.drawStyle.shadow.uploadElements(0, circles.size)\n\n        drawCircles(drawContext, drawStyle, circles.size)\n    }\n\n\n    fun drawCircle(\n        drawContext: DrawContext,\n        drawStyle: DrawStyle, x: Double, y: Double, radius: Double\n    ) {\n\n        val batch = singleBatches[count.mod(singleBatches.size)]\n\n        //ensureBatchSize(1)\n        batch.geometry.shadow.writer().apply {\n            rewind()\n            write(Vector3(x, y, 0.0))\n            write(Vector2(abs(radius)))\n        }\n        batch.geometry.shadow.uploadElements(0, 1)\n\n        batch.drawStyle.shadow.writer().apply {\n            rewind()\n            write(drawStyle.fill ?: ColorRGBa.TRANSPARENT)\n            write(drawStyle.stroke ?: ColorRGBa.TRANSPARENT)\n            val weight = if (drawStyle.stroke == null || drawStyle.stroke?.alpha == 0.0) 0.0 else\n                drawStyle.strokeWeight\n            write(weight.toFloat())\n        }\n        batch.drawStyle.shadow.uploadElements(0, 1)\n\n        drawCircles(drawContext, drawStyle, batch, 1)\n        count++\n    }\n\n    private fun drawCircles(drawContext: DrawContext, drawStyle: DrawStyle, count: Int) {\n        drawCircles(drawContext, drawStyle, batch, count)\n    }\n\n    fun drawCircles(drawContext: DrawContext, drawStyle: DrawStyle, circleBatch: CircleBatch, count: Int) {\n        val instanceAttributes = listOf(circleBatch.geometry, circleBatch.drawStyle)\n        val instanceAttributeFormats = listOf(circleBatch.geometry.vertexFormat, circleBatch.drawStyle.vertexFormat)\n\n        val shader = shaderManager.shader(\n            drawStyle.shadeStyle,\n            listOf(vertices.vertexFormat),\n            instanceAttributeFormats\n        )\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawInstances(\n            shader,\n            listOf(vertices),\n            instanceAttributes + (drawStyle.shadeStyle?.attributes.orEmpty()),\n            DrawPrimitive.TRIANGLES,\n            0,\n            6,\n            0,\n            count,\n            verticesPerPatch = 0\n        )\n        shader.end()\n    }\n}","@file:JvmName(\"DriverJVM\")\n\npackage org.openrndr.internal\n\nimport org.openrndr.draw.*\nimport org.openrndr.utils.buffer.MPPBuffer\nimport kotlin.jvm.JvmName\n\n\nsealed class ShaderLanguage\nclass GLSL(val version: String) : ShaderLanguage()\nclass WebGLSL(val version: String) : ShaderLanguage()\n\ndata class DriverProperties(\n    val maxRenderTargetSamples: Int,\n    val maxTextureSamples: Int,\n    val maxTextureSize: Int\n)\n\n\n/**\n * Driver interface. This is the internal interface\n */\nexpect interface Driver {\n\n    val properties: DriverProperties\n\n    val contextID: Long\n    /**\n     * Create a shader from code\n     * @param vsCode vertex shader code\n     * @param gsCode optional geometry shader code\n     * @param fsCode fragment shader code\n     */\n\n    fun createShader(\n        vsCode: String,\n        tcsCode: String?,\n        tesCode: String?,\n        gsCode: String?,\n        fsCode: String,\n        name: String,\n        session: Session? = Session.active\n    ): Shader\n\n    fun createComputeShader(code: String, name: String, session: Session? = Session.active): ComputeShader\n\n    fun createComputeStyleManager(session: Session? = Session.root) : ComputeStyleManager\n\n    fun createShadeStyleManager(\n        name: String,\n        vsGenerator: (ShadeStructure) -> String,\n        tcsGenerator: ((ShadeStructure) -> String)? = null,\n        tesGenerator: ((ShadeStructure) -> String)? = null,\n        gsGenerator: ((ShadeStructure) -> String)? = null,\n        fsGenerator: (ShadeStructure) -> String,\n        session: Session? = Session.root\n    ): ShadeStyleManager\n\n    fun createRenderTarget(\n        width: Int,\n        height: Int,\n        contentScale: Double = 1.0,\n        multisample: BufferMultisample = BufferMultisample.Disabled,\n        session: Session? = Session.active\n    ): RenderTarget\n\n    fun createArrayCubemap(\n        width: Int,\n        layers: Int,\n        format: ColorFormat,\n        type: ColorType,\n        levels: Int = 1,\n        session: Session? = Session.active\n    ): ArrayCubemap\n\n    fun createArrayTexture(\n        width: Int,\n        height: Int,\n        layers: Int,\n        format: ColorFormat,\n        type: ColorType,\n        levels: Int = 1,\n        session: Session? = Session.active\n    ): ArrayTexture\n\n    fun createAtomicCounterBuffer(counterCount: Int, session: Session? = Session.active): AtomicCounterBuffer\n\n    fun createColorBuffer(\n        width: Int,\n        height: Int,\n        contentScale: Double,\n        format: ColorFormat,\n        type: ColorType,\n        multisample: BufferMultisample = BufferMultisample.Disabled,\n        levels: Int = 1,\n        session: Session? = Session.active\n    ): ColorBuffer\n\n    fun createDepthBuffer(\n        width: Int,\n        height: Int,\n        format: DepthFormat,\n        multisample: BufferMultisample = BufferMultisample.Disabled,\n        session: Session? = Session.active\n    ): DepthBuffer\n\n    fun createBufferTexture(\n        elementCount: Int,\n        format: ColorFormat,\n        type: ColorType,\n        session: Session? = Session.active\n    ): BufferTexture\n\n    fun createCubemap(\n        width: Int,\n        format: ColorFormat,\n        type: ColorType,\n        levels: Int,\n        session: Session? = Session.active\n    ): Cubemap\n\n    fun createVolumeTexture(\n        width: Int,\n        height: Int,\n        depth: Int,\n        format: ColorFormat,\n        type: ColorType,\n        levels: Int,\n        session: Session? = Session.active\n    ): VolumeTexture\n\n//    fun createResourceThread(session: Session? = Session.active, f: () -> Unit): ResourceThread\n//    fun createDrawThread(session: Session? = Session.active): DrawThread\n\n    fun clear(r: Double, g: Double, b: Double, a: Double)\n\n//    fun clear(color: ColorRGBa) {\n//        clear(color.r, color.g, color.b, color.a)\n//    }\n\n    fun createDynamicVertexBuffer(\n        format: VertexFormat,\n        vertexCount: Int,\n        session: Session? = Session.active\n    ): VertexBuffer\n\n//    fun createStaticVertexBuffer(format: VertexFormat, buffer: Buffer, session: Session? = Session.active): VertexBuffer\n\n    fun createDynamicIndexBuffer(elementCount: Int, type: IndexType, session: Session? = Session.active): IndexBuffer\n\n    fun createShaderStorageBuffer(format: ShaderStorageFormat, session: Session? = Session.active): ShaderStorageBuffer\n\n    fun drawVertexBuffer(\n        shader: Shader, vertexBuffers: List<VertexBuffer>,\n        drawPrimitive: DrawPrimitive,\n        vertexOffset: Int, vertexCount: Int, verticesPerPatch: Int = 0\n    )\n\n    fun drawIndexedVertexBuffer(\n        shader: Shader, indexBuffer: IndexBuffer, vertexBuffers: List<VertexBuffer>,\n        drawPrimitive: DrawPrimitive,\n        indexOffset: Int, indexCount: Int, verticesPerPatch: Int = 0\n    )\n\n    fun drawInstances(\n        shader: Shader, vertexBuffers: List<VertexBuffer>,\n        instanceAttributes: List<VertexBuffer>,\n        drawPrimitive: DrawPrimitive, vertexOffset: Int, vertexCount: Int,\n        instanceOffset: Int, instanceCount: Int, verticesPerPatch: Int = 0\n    )\n\n    fun drawIndexedInstances(\n        shader: Shader, indexBuffer: IndexBuffer, vertexBuffers: List<VertexBuffer>,\n        instanceAttributes: List<VertexBuffer>,\n        drawPrimitive: DrawPrimitive, indexOffset: Int, indexCount: Int,\n        instanceOffset: Int, instanceCount: Int, verticesPerPatch: Int = 0\n    )\n\n    fun setState(drawStyle: DrawStyle)\n\n    fun destroyContext(context: Long)\n\n    val fontImageMapManager: FontMapManager\n    val fontVectorMapManager: FontMapManager\n    val shaderGenerators: ShaderGenerators\n    val activeRenderTarget: RenderTarget\n\n    /**\n     * waits for all drawing to complete\n     */\n    fun finish()\n\n    fun internalShaderResource(resourceId: String): String\n\n    fun shaderConfiguration() : String\n\n    val shaderLanguage: ShaderLanguage\n\n\n    companion object {\n        var driver: Driver?\n\n//        = null\n//            set(value) {\n//                logger.debug {\"setting driver instance to $value\" }\n//                field = value\n//            }\n\n        val instance: Driver\n//        get() = driver ?: error(\"No graphical context has been set up yet.\")\n    }\n}\n\n/**\n * Wait for the [Driver] to finish drawing\n */\nfun finish() {\n    Driver.instance.finish()\n}","package org.openrndr.internal\n\nimport org.openrndr.draw.LineCap\nimport org.openrndr.draw.LineJoin\nimport org.openrndr.internal.PathPoint.Companion.BEVEL\nimport org.openrndr.internal.PathPoint.Companion.CORNER\nimport org.openrndr.internal.PathPoint.Companion.INNER_BEVEL\nimport org.openrndr.internal.PathPoint.Companion.LEFT\nimport org.openrndr.math.Vector2\nimport kotlin.math.*\n\nprivate val List<PathPoint>.renderable: Boolean\n    get() = when (size) {\n        0, 1 -> false\n        2 -> {\n            val dx = this[1].x - this[0].x\n            val dy = this[1].y - this[0].y\n            dx * dx + dy * dy > 10E-6\n        }\n        else -> true\n    }\n\ninternal enum class ExpansionType {\n    STROKE,\n    FILL,\n    FRINGE,\n    SKIP\n}\n\ninternal class Expansion(val type: ExpansionType, val fb: FloatArray, val bufferStart: Int) {\n    var vertexCount = 0\n    var minx = Double.POSITIVE_INFINITY\n    var maxx = Double.NEGATIVE_INFINITY\n    var miny = Double.POSITIVE_INFINITY\n    var maxy = Double.NEGATIVE_INFINITY\n    var bufferPosition = bufferStart\n\n    private fun chooseBevel(bevel: Boolean, p0: PathPoint, p1: PathPoint, w: Double): DoubleArray {\n        val x0: Double\n        val y0: Double\n        val x1: Double\n        val y1: Double\n\n        if (bevel) {\n            x0 = p1.x + p0.dy * w\n            y0 = p1.y - p0.dx * w\n            x1 = p1.x + p1.dy * w\n            y1 = p1.y - p1.dx * w\n        } else {\n            x0 = p1.x + p1.dmx * w\n            y0 = p1.y + p1.dmy * w\n            x1 = p1.x + p1.dmx * w\n            y1 = p1.y + p1.dmy * w\n        }\n        return doubleArrayOf(x0, y0, x1, y1)\n    }\n\n    fun bevelJoin(\n        p0: PathPoint, p1: PathPoint,\n        lw: Double, rw: Double, lu: Double, ru: Double,\n        offset: Double\n    ) {\n\n\n\n        val dlx0 = p0.dy\n        val dly0 = -p0.dx\n        val dlx1 = p1.dy\n        val dly1 = -p1.dx\n\n        if (dlx0 != dlx0 || dly0 != dly0 || dlx1 != dlx1 || dly1 != dly1 || lw != lw || rw != rw || p0.x != p0.x || p0.y != p0.y || p1.x != p1.x || p1.y != p1.y)\n            return\n\n        if (p1.flags and LEFT != 0) {\n            val r = chooseBevel(p1.flags and INNER_BEVEL != 0, p0, p1, lw)\n            val lx0 = r[0]\n            val ly0 = r[1]\n            val lx1 = r[2]\n            val ly1 = r[3]\n\n            addVertex(lx0, ly0, lu, 1.0, offset)\n            addVertex(p1.x - dlx0 * rw, p1.y - dly0 * rw, ru, 1.0, offset)\n\n            if (p1.flags and BEVEL != 0) {\n                addVertex(lx0, ly0, lu, 1.0, offset)\n                addVertex(p1.x - dlx0 * rw, p1.y - dly0 * rw, ru, 1.0, offset)\n\n                addVertex(lx1, ly1, lu, 1.0, offset)\n                addVertex(p1.x - dlx1 * rw, p1.y - dly1 * rw, ru, 1.0, offset)\n            } else {\n                val rx0 = p1.x - p1.dmx * rw\n                val ry0 = p1.y - p1.dmy * rw\n\n                addVertex(p1.x, p1.y, 0.5, 1.0, offset)\n                addVertex(p1.x - dlx0 * rw, p1.y - dly0 * rw, ru, 1.0, offset)\n\n                addVertex(rx0, ry0, ru, 1.0, offset)\n                addVertex(rx0, ry0, ru, 1.0, offset)\n\n                addVertex(p1.x, p1.y, 0.5, 1.0, offset)\n                addVertex(p1.x - dlx1 * rw, p1.y - dly1 * rw, ru, 1.0, offset)\n            }\n\n            addVertex(lx1, ly1, lu, 1.0, offset)\n            addVertex(p1.x - dlx1 * rw, p1.y - dly1 * rw, ru, 1.0, offset)\n\n        } else {\n            val r = chooseBevel(p1.flags and INNER_BEVEL != 0, p0, p1, -rw)\n\n            val rx0 = r[0]\n            val ry0 = r[1]\n            val rx1 = r[2]\n            val ry1 = r[3]\n\n            addVertex(p1.x + dlx0 * lw, p1.y + dly0 * lw, lu, 1.0, offset)\n            addVertex(rx0, ry0, ru, 1.0, offset)\n\n            if (p1.flags and BEVEL != 0) {\n                addVertex(p1.x + dlx0 * lw, p1.y + dly0 * lw, lu, 1.0, offset)\n                addVertex(rx0, ry0, ru, 1.0, offset)\n\n                addVertex(p1.x + dlx1 * lw, p1.y + dly1 * lw, lu, 1.0, offset)\n                addVertex(rx1, ry1, ru, 1.0, offset)\n            } else {\n                val lx0 = p1.x + p1.dmx * lw\n                val ly0 = p1.y + p1.dmy * lw\n\n                addVertex(p1.x + dlx0 * lw, p1.y + dly0 * lw, lu, 1.0, offset)\n                addVertex(p1.x, p1.y, 0.5, 1.0, offset)\n\n                addVertex(lx0, ly0, lu, 1.0, offset)\n                addVertex(lx0, ly0, lu, 1.0, offset)\n\n                addVertex(p1.x + dlx1 * lw, p1.y + dly1 * lw, lu, 1.0, offset)\n                addVertex(p1.x, p1.y, 0.5, 1.0, offset)\n            }\n\n            addVertex(p1.x + dlx1 * lw, p1.y + dly1 * lw, lu, 1.0, offset)\n            addVertex(rx1, ry1, ru, 1.0, offset)\n        }\n    }\n\n    fun roundJoin(\n        p0: PathPoint, p1: PathPoint,\n        lw: Double, rw: Double, lu: Double, ru: Double, ncap: Int, offset: Double\n    ) {\n\n        val dlx0 = p0.dy\n        val dly0 = -p0.dx\n        val dlx1 = p1.dy\n        val dly1 = -p1.dx\n\n        if (p1.flags and LEFT != 0) {\n\n            val r = chooseBevel(p1.flags and INNER_BEVEL != 0, p0, p1, lw)\n            val lx0 = r[0]\n            val ly0 = r[1]\n            val lx1 = r[2]\n            val ly1 = r[3]\n\n            var a0 = atan2(-dly0, -dlx0)\n            var a1 = atan2(-dly1, -dlx1)\n            if (a1 > a0) a0 += PI * 2\n\n            if (a0 < 0 || a1 < 0) {\n                a0 += PI * 2\n                a1 += PI * 2\n            }\n\n            addVertex(lx0, ly0, lu, 1.0, offset)\n            addVertex(p1.x - dlx0 * rw, p1.y - dly0 * rw, ru, 1.0, offset)\n\n            val n = ncap.coerceAtMost(ceil((a0 - a1) / PI * ncap).toInt()).coerceAtLeast(2)\n            for (i in 0 until n) {\n                val u = i / (n - 1.0)\n                val a = a0 + u * (a1 - a0)\n                val rx = p1.x + cos(a) * rw\n                val ry = p1.y + sin(a) * rw\n                addVertex(p1.x, p1.y, 0.5, 1.0, offset)\n                addVertex(rx, ry, ru, 1.0, offset)\n            }\n\n            addVertex(lx1, ly1, lu, 1.0, offset)\n            addVertex(p1.x - dlx1 * rw, p1.y - dly1 * rw, ru, 1.0, offset)\n\n        } else {\n            val r = chooseBevel(p1.flags and INNER_BEVEL != 0, p0, p1, -rw)\n            val rx0 = r[0]\n            val ry0 = r[1]\n            val rx1 = r[2]\n            val ry1 = r[3]\n\n            val a0 = atan2(dly0, dlx0)\n            var a1 = atan2(dly1, dlx1)\n            if (a1 < a0) {\n                a1 += PI * 2\n            }\n            addVertex(p1.x + dlx0 * rw, p1.y + dly0 * rw, lu, 1.0, offset)\n            addVertex(rx0, ry0, ru, 1.0, offset)\n\n            val n = ncap.coerceAtMost(ceil((a1 - a0) / PI * ncap).toInt()).coerceAtLeast(2)\n\n            for (i in 0 until n) {\n                val a = a0 + i.toDouble() / (n - 1.0) * (a1 - a0)\n                addVertex(p1.x + cos(a) * lw, p1.y + sin(a) * lw, lu, 1.0, offset)\n                addVertex(p1.x, p1.y, 0.5, 1.0, offset)\n            }\n            addVertex(p1.x + dlx1 * rw, p1.y + dly1 * rw, lu, 1.0, offset)\n            addVertex(rx1, ry1, ru, 1.0, offset)\n        }\n    }\n\n    fun buttCapStart(\n        p: PathPoint, dx: Double, dy: Double, w: Double,\n        d: Double, aa: Double, offset: Double\n    ) {\n        if (dx == dx && dy == dy && d == d) {\n            val px = p.x - dx * d\n            val py = p.y - dy * d\n            val dly = -dx\n\n            addVertex(px + dy * w - dx * aa, py + dly * w - dy * aa, 0.0, 0.0, offset)\n            addVertex(px - dy * w - dx * aa, py - dly * w - dy * aa, 1.0, 0.0, offset)\n            addVertex(px + dy * w, py + dly * w, 0.0, 1.0, offset)\n            addVertex(px - dy * w, py - dly * w, 1.0, 1.0, offset)\n        }\n    }\n\n\n    fun buttCapEnd(p: PathPoint, dx: Double, dy: Double, w: Double, d: Double, aa: Double, offset: Double) {\n        if (dx == dx && dy == dy && d == d) {\n            val px = p.x - dx * d\n            val py = p.y - dy * d\n            val dly = -dx\n\n            addVertex(px + dy * w, py + dly * w, 0.0, 1.0, offset)\n            addVertex(px - dy * w, py - dly * w, 1.0, 1.0, offset)\n            addVertex(px + dy * w + dx * aa, py + dly * w + dy * aa, 0.0, 0.0, offset)\n            addVertex(px - dy * w + dx * aa, py - dly * w + dy * aa, 1.0, 0.0, offset)\n        }\n    }\n\n    fun roundCapStart(\n        p: PathPoint,\n        dx: Double, dy: Double, w: Double, ncap: Int, offset: Double\n    ) {\n        if (dx == dx && dy == dy) {\n            val px = p.x\n            val py = p.y\n            val dly = -dx\n\n\n            for (i in 0 until ncap) {\n                val a = i / (ncap - 1.0) * PI\n                val ax = cos(a) * w\n                val ay = sin(a) * w\n                addVertex(px - dy * ax - dx * ay, py - dly * ax - dy * ay, 0.0, 1.0, offset)\n                addVertex(px, py, 0.5, 1.0, offset)\n            }\n            addVertex(px + dy * w, py + dly * w, 0.0, 1.0, offset)\n            addVertex(px - dy * w, py - dly * w, 1.0, 1.0, offset)\n        }\n    }\n\n    fun roundCapEnd(\n        p: PathPoint,\n        dx: Double, dy: Double, w: Double, ncap: Int, offset: Double\n    ) {\n        if (dx == dx && dy == dy) {\n            val px = p.x\n            val py = p.y\n            val dly = -dx\n\n            addVertex(px + dy * w, py + dly * w, 0.0, 1.0, offset)\n            addVertex(px - dy * w, py - dly * w, 1.0, 1.0, offset)\n            for (i in 0 until ncap) {\n                val a = i / (ncap - 1).toDouble() * PI\n                val ax = cos(a) * w\n                val ay = sin(a) * w\n                addVertex(px, py, 0.5, 1.0, offset)\n                addVertex(px - dy * ax + dx * ay, py - dly * ax + dy * ay, 0.0, 1.0, offset)\n            }\n        }\n    }\n\n    fun vertex(idx: Int): Vector2 =\n        Vector2(fb[bufferStart + idx * 5].toDouble(), fb[bufferStart + idx * 5 + 1].toDouble())\n\n    fun addVertex(x: Double, y: Double, u: Double, v: Double, offset: Double) {\n        if (x != x || y != y) {\n            return// throw RuntimeException(\"$x $y $u $v\")\n        }\n\n        minx = min(minx, x)\n        maxx = max(maxx, x)\n        miny = min(miny, y)\n        maxy = max(maxy, y)\n\n        fb[bufferPosition++] = x.toFloat()\n        fb[bufferPosition++] = y.toFloat()\n        fb[bufferPosition++] = u.toFloat()\n        fb[bufferPosition++] = v.toFloat()\n        fb[bufferPosition++] = offset.toFloat()\n\n        vertexCount++\n    }\n}\n\n\ninternal class Path {\n    var convex: Boolean = false\n    var closed: Boolean = false\n    private var nbevel: Int = 0\n    val contours = mutableListOf<List<PathPoint>>()\n\n    companion object {\n        fun fromLineStrip(\n            segments: List<Vector2>,\n            corners: List<Boolean>,\n            closed: Boolean\n        ): Path {\n            val sp = Path()\n            if (segments.isEmpty()) {\n                return sp\n            }\n\n            val drop = closed && segments.first().squaredDistanceTo(segments.last()) < 10E-6\n            val path = segments.mapIndexed { index, it ->\n                PathPoint().apply { x = it.x; y = it.y; flags = if (corners[index]) CORNER else 0 }\n            }.dropLast(if (drop) 1 else 0)\n\n            if (path.isNotEmpty()) {\n                if (!closed) {\n                    path[0].flags = 0\n                    path[path.size - 1].flags = 0\n                }\n                sp.contours.add(path)\n            }\n            sp.closed = closed\n            return sp\n        }\n\n        fun fromLineLoops(contours: List<List<Vector2>>, corners: List<List<Boolean>>): Path {\n            val sp = Path()\n            contours.forEachIndexed { contourIndex, contour ->\n                val path = contour.mapIndexed { index, it ->\n                    PathPoint().apply {\n                        x = it.x; y = it.y; flags = if (corners[contourIndex][index]) CORNER else 0\n                    }\n                }.dropLast(1)\n                sp.contours.add(path)\n            }\n            sp.closed = true\n            return sp\n        }\n    }\n\n    private fun calculateJoins(points: List<PathPoint>, w: Double, lineJoin: LineJoin, miterLimit: Double) {\n        if (points.isEmpty()) {\n            return\n        }\n        nbevel = 0\n\n        val iw = if (w > 0.0) 1.0 / w else 0.0\n        var nleft = 0\n\n        var p0 = points[points.size - 1]\n        var p1 = points[0]\n        var p1ptr = 0\n\n        for (j in points.indices) {\n            val dlx0 = p0.dy\n            val dly0 = -p0.dx\n            val dlx1 = p1.dy\n            val dly1 = -p1.dx\n\n            p1.dmx = (dlx0 + dlx1) * 0.5\n            p1.dmy = (dly0 + dly1) * 0.5\n            val dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy\n            if (dmr2 > 0.000001f) {\n                var scale = 1.0 / dmr2\n                if (scale > 600.0) {\n                    scale = 600.0\n                }\n                p1.dmx *= scale\n                p1.dmy *= scale\n            }\n            p1.flags = if (p1.flags and CORNER != 0) CORNER else 0\n            val cross = p1.dx * p0.dy - p0.dx * p1.dy\n            if (cross > 0.0) {\n                nleft += 1\n                p1.flags = p1.flags or LEFT\n            }\n\n            // Calculate if we should use bevel or miter for inner join.\n            val limit = max(1.01, min(p0.length, p1.length) * iw)\n            if (dmr2 * limit * limit < 1.0f) {\n                p1.flags = p1.flags or INNER_BEVEL\n            }\n\n            // Check to see if the corner needs to be beveled.\n            if (p1.flags and CORNER != 0) {\n                if (dmr2 * miterLimit * miterLimit < 1.0f || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) {\n                    p1.flags = p1.flags or BEVEL\n                }\n            }\n\n            if (p1.flags and (BEVEL or INNER_BEVEL) != 0) {\n                nbevel++\n            }\n\n            p0 = p1\n            p1ptr++\n            if (p1ptr < points.size) {\n                p1 = points[p1ptr]\n            }\n        }\n        convex = nleft == points.size\n    }\n\n    fun prepare(points: List<PathPoint>) {\n        if (points.isEmpty()) {\n            return\n        }\n\n        var p0 = points[points.size - 1]\n        var p1 = points[0]\n        var p1ptr = 0\n        for (i in points.indices) {\n            // Calculate segment direction and length\n            p0.dx = p1.x - p0.x\n            p0.dy = p1.y - p0.y\n\n            val distanceSquared = p0.dx * p0.dx + p0.dy * p0.dy\n\n            require(distanceSquared > 0.0 || (i == 0 && !closed)) { \"consecutive point duplication in input geometry at ($i and ${i + 1}) (${p0.x},${p0.y})\" }\n\n            p0.length = sqrt(distanceSquared)\n            if (p0.length > 0) {\n                p0.dx /= p0.length\n                p0.dy /= p0.length\n            } else {\n                p0.dx = 0.0\n                p0.dy = 0.0\n                //throw RuntimeException(\"duplicate points within epsilon\")\n            }\n            p0 = p1\n            p1ptr += 1\n            if (p1ptr < points.size) {\n                p1 = points[p1ptr]\n            }\n        }\n    }\n\n    fun expandStroke(\n        fringeWidth: Double,\n        strokeWeight: Double,\n        lineCap: LineCap,\n        lineJoin: LineJoin,\n        miterLimit: Double\n    ): Expansion {\n        val weight = strokeWeight + fringeWidth * 1.0\n\n        if (contours.isNotEmpty() && contours[0].renderable) {\n            val points = contours[0]\n\n            val tessTol = 0.1 * fringeWidth\n            val capSteps = curveDivs(weight, PI, tessTol)\n\n            prepare(points)\n\n            calculateJoins(points, weight, lineJoin, miterLimit)\n\n            var cverts = 0\n            cverts += if (lineJoin == LineJoin.ROUND) {\n                (points.size + nbevel * (capSteps + 2) + 1) * 2 // plus one for loop\n            } else {\n                (points.size + nbevel * 5 + 1) * 2 // plus one for loop\n            }\n\n            if (!closed) {\n                cverts += if (lineCap == LineCap.ROUND) {\n                    (capSteps * 2 + 2) * 2\n                } else {\n                    (3 + 3) * 2\n                }\n            }\n\n            val expansion = Expansion(ExpansionType.STROKE, FloatArray(cverts * 5), 0)\n\n            var offset = 0.0\n            val aa = fringeWidth\n\n            var p0 = if (closed) points[points.size - 1] else points[0]\n            var p1 = if (closed) points[0] else points[1]\n            val start = if (closed) 0 else 1\n            val end = if (closed) points.size else points.size - 1\n            var p1ptr = if (closed) 0 else 1\n\n            // -- start, optional cap\n            if (!closed) {\n                var dx = p1.x - p0.x\n                var dy = p1.y - p0.y\n                val length = sqrt(dx * dx + dy * dy)\n\n                if (length > 0) {\n                    dx /= length\n                    dy /= length\n                }\n\n                when (lineCap) {\n                    LineCap.BUTT -> expansion.buttCapStart(p0, dx, dy, weight, -aa * 0.5, aa, offset)\n                    LineCap.SQUARE -> expansion.buttCapStart(p0, dx, dy, weight, weight - aa, aa, offset)\n                    LineCap.ROUND -> expansion.roundCapStart(p0, dx, dy, weight, capSteps, offset)\n                }\n            }\n\n\n            // -- middle\n            for (j in start until end) {\n                offset += p0.length\n                if (p1.flags and (BEVEL or INNER_BEVEL) != 0) {\n                    if (lineJoin === LineJoin.ROUND) {\n                        expansion.roundJoin(p0, p1, weight, weight, 0.0, 1.0, capSteps, offset)\n                    } else {\n                        expansion.bevelJoin(p0, p1, weight, weight, 0.0, 1.0, offset)\n                    }\n                } else {\n                    expansion.addVertex(p1.x + p1.dmx * weight, p1.y + p1.dmy * weight, 0.0, 1.0, offset)\n                    expansion.addVertex(p1.x - p1.dmx * weight, p1.y - p1.dmy * weight, 1.0, 1.0, offset)\n                }\n                p0 = p1\n                p1ptr += 1\n                if (p1ptr < points.size) {\n                    p1 = points[p1ptr]\n                }\n            }\n\n            if (points.size == 2) {\n                val dx = p1.x - p0.x\n                val dy = p1.y - p0.y\n                val length = sqrt(dx * dx + dy * dy)\n                offset = length\n            } else {\n                offset += p0.length\n            }\n\n            // -- end\n            if (closed) {\n                // Loop it\n                val v0 = expansion.vertex(0)\n                val v1 = expansion.vertex(1)\n                expansion.addVertex(v0.x, v0.y, 0.0, 1.0, offset)\n                expansion.addVertex(v1.x, v1.y, 1.0, 1.0, offset)\n            } else {\n                // Add cap\n                var dx = p1.x - p0.x\n                var dy = p1.y - p0.y\n                val l = sqrt(dx * dx + dy * dy)\n                if (l > 0) {\n                    dx /= l\n                    dy /= l\n                }\n                when (lineCap) {\n                    LineCap.BUTT -> expansion.buttCapEnd(p1, dx, dy, weight, -aa * 0.5, aa, offset)\n                    LineCap.SQUARE -> expansion.buttCapEnd(p1, dx, dy, weight, weight - aa, aa, offset)\n                    LineCap.ROUND -> expansion.roundCapEnd(p1, dx, dy, weight, capSteps, offset)\n                }\n            }\n            return expansion\n        } else {\n            return Expansion(ExpansionType.SKIP, FloatArray(0), 0)\n        }\n    }\n\n    fun expandFill(\n        fringeWidth: Double,\n        weight: Double,\n        lineJoin: LineJoin,\n        miterLimit: Double\n    ): List<Expansion> {\n        if (contours.isNotEmpty()) {\n            val result = mutableListOf<Expansion>()\n\n            contours.forEach { prepare(it) }\n            contours.forEach { calculateJoins(it, weight, lineJoin, miterLimit) }\n\n            if (contours.size > 1) {\n                convex = false\n            }\n            convex = false\n            val woff = 0.5 * fringeWidth\n            val generateFringe = fringeWidth > 0.0\n            val pathOffset = 0.0\n\n\n            for (points in contours) {\n                if (points.isEmpty())\n                    continue\n\n                var size = 4\n                points.forEach { point ->\n                    size += if ((point.flags and BEVEL) != 0) {\n                        12\n                    } else {\n                        4\n                    }\n                }\n                val fill = Expansion(ExpansionType.FILL, FloatArray(size * 5), 0)\n                if (generateFringe) {\n                    var p0 = points.last()\n                    var p1 = points[0]\n                    var p1ptr = 0\n\n                    for (j in points.indices) {\n                        if (p1.flags and BEVEL != 0) {\n                            if (p1.flags and LEFT != 0) {\n                                fill.addVertex(p1.x + p1.dmx * woff, p1.y + p1.dmy * woff, 0.5, 1.0, pathOffset)\n                            } else {\n                                val dlx0 = p0.dy\n                                val dly0 = -p0.dx\n                                val dlx1 = p1.dy\n                                val dly1 = -p1.dx\n\n                                val lx0 = p1.x + dlx0 * woff\n                                val ly0 = p1.y + dly0 * woff\n                                val lx1 = p1.x + dlx1 * woff\n                                val ly1 = p1.y + dly1 * woff\n\n                                fill.addVertex(lx0, ly0, 0.5, 1.0, pathOffset)\n                                fill.addVertex(lx1, ly1, 0.5, 1.0, pathOffset)\n                            }\n                        } else {\n                            fill.addVertex(p1.x + p1.dmx * woff, p1.y + p1.dmy * woff, 0.5, 1.0, pathOffset)\n                        }\n                        p0 = p1\n                        p1ptr++\n                        if (p1ptr < points.size) {\n                            p1 = points[p1ptr]\n                        }\n                    }\n\n                } else {\n                    for (j in points.indices) {\n                        fill.addVertex(points[j].x, points[j].y, 0.5, 1.0, pathOffset)\n                    }\n                }\n                result.add(fill)\n            }\n\n\n            // Calculate fringe\n            if (generateFringe) {\n                for (points in contours) {\n\n                    if (points.isEmpty()) {\n                        continue\n                    }\n\n                    var size = 2\n                    for (point in points) {\n                        size += if (point.flags and (BEVEL or INNER_BEVEL) != 0) {\n                            10\n                        } else {\n                            4\n                        }\n                    }\n                    val fringe = Expansion(ExpansionType.FRINGE, FloatArray(size * 5), 0)\n\n                    var lw = weight + woff\n                    val rw = weight - woff\n                    var lu = 0.0\n                    val ru = 1.0\n\n                    // Create only half a fringe for convex shapes so that\n                    // the shape can be rendered without stenciling.\n                    if (convex) {\n                        lw = woff    // This should generate the same vertex as fill inset above.\n                        lu = 0.5    // Set outline fade at middle.\n                    }\n\n                    // Looping\n                    var p0 = points[points.size - 1]\n                    var p1 = points[0]\n\n                    var p1ptr = 0\n                    for (j in points.indices) {\n                        if (p1.flags and (BEVEL or INNER_BEVEL) != 0) {\n                            fringe.bevelJoin(p0, p1, lw, rw, lu, ru, offset = pathOffset)\n                        } else {\n                            fringe.addVertex(p1.x + (p1.dmx * lw), p1.y + (p1.dmy * lw), lu, 1.0, pathOffset)\n                            fringe.addVertex(p1.x - (p1.dmx * rw), p1.y - (p1.dmy * rw), ru, 1.0, pathOffset)\n                        }\n                        p0 = p1\n                        p1ptr++\n                        if (p1ptr < points.size) {\n                            p1 = points[p1ptr]\n                        }\n                    }\n                    // Loop it\n                    val v0 = fringe.vertex(0)\n                    val v1 = fringe.vertex(1)\n\n                    fringe.addVertex(v0.x, v0.y, lu, 1.0, pathOffset)\n                    fringe.addVertex(v1.x, v1.y, ru, 1.0, pathOffset)\n                    result.add(fringe)\n                }\n\n            }\n            return result\n\n        } else {\n            return emptyList()\n        }\n    }\n}\n\ninternal class PathPoint {\n    var x: Double = 0.0\n    var y: Double = 0.0\n    var dx: Double = 0.0\n    var dy: Double = 0.0\n    var length: Double = 0.0\n    var dmx: Double = 0.0\n    var dmy: Double = 0.0\n    var flags: Int = 0\n\n    companion object {\n        const val CORNER = 0x01\n        const val LEFT = 0x02\n        const val BEVEL = 0x04\n        const val INNER_BEVEL = 0x08\n    }\n\n    override fun toString(): String {\n        return \"PathPoint(x=$x, y=$y, flags=$flags)\"\n    }\n}\n\ninternal fun curveDivs(r: Double, arc: Double, tol: Double): Int {\n    val da = acos(r / (r + tol)) * 2.0\n    return max(2, ceil(arc / da).toInt())\n}\n","package org.openrndr.internal\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.draw.*\nimport org.openrndr.math.Vector4\n\ninternal data class Command(val vertexBuffer: VertexBuffer, val type: ExpansionType, val vertexOffset: Int, val vertexCount: Int,\n                            val minX: Double, val minY: Double, val maxX: Double, val maxY: Double)\n\ninternal class ExpansionDrawer {\n\n    private val shaderManager = ShadeStyleManager.fromGenerators(\"expansion\",\n            vsGenerator = Driver.instance.shaderGenerators::expansionVertexShader,\n            fsGenerator = Driver.instance.shaderGenerators::expansionFragmentShader)\n\n    val vertexFormat = vertexFormat {\n        position(2)\n        textureCoordinate(2)\n        attribute(\"vertexOffset\", VertexElementType.FLOAT32)\n    }\n\n    val manyVertices = VertexBuffer.createDynamic(vertexFormat, 4 * 1024 * 1024, Session.root)\n    val fewVertices = List(DrawerConfiguration.vertexBufferMultiBufferCount) { vertexBuffer(vertexFormat, 4 * 128, Session.root) }\n\n    val quads = List(DrawerConfiguration.vertexBufferMultiBufferCount) { VertexBuffer.createDynamic(vertexFormat, 6, Session.root) }\n\n    fun renderStrokeCommands(drawContext: DrawContext, drawStyle: DrawStyle, commands: List<Command>, fringeWidth: Double) {\n\n        val shader = shaderManager.shader(drawStyle.shadeStyle, listOf(vertexFormat), emptyList())\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n\n        val localStyle = drawStyle.copy()\n        val fs = fringeWidth\n        shader.uniform(\"strokeMult\", (drawStyle.strokeWeight*0.5 + fs*0.5 ) / (fs) )\n        shader.uniform(\"strokeFillFactor\", 0.0)\n        commands.forEach { command ->\n\n            //shader.uniform(\"bounds\", Vector4(command.minX, command.minY, command.maxX - command.minX, command.maxY - command.minY))\n            localStyle.channelWriteMask = ChannelMask(red = true, green = true, blue = true, alpha = true)\n            // -- pre\n            shader.uniform(\"strokeThr\", 1.0f - 0.5f / 255.0f)\n            localStyle.stencil.stencilFunc(StencilTest.EQUAL, 0x00, 0xff)\n            localStyle.stencil.stencilOp(StencilOperation.KEEP, StencilOperation.KEEP, StencilOperation.INCREASE)\n            Driver.instance.setState(localStyle)\n            Driver.instance.drawVertexBuffer(shader, listOf(command.vertexBuffer), DrawPrimitive.TRIANGLE_STRIP, command.vertexOffset, command.vertexCount, verticesPerPatch = 0)\n\n            // -- anti-aliased\n            shader.uniform(\"strokeThr\", -1.0f)\n            localStyle.stencil.stencilFunc(StencilTest.EQUAL, 0x00, 0xff)\n            localStyle.stencil.stencilOp(StencilOperation.KEEP, StencilOperation.KEEP, StencilOperation.KEEP)\n            Driver.instance.setState(localStyle)\n            Driver.instance.drawVertexBuffer(shader, listOf(command.vertexBuffer), DrawPrimitive.TRIANGLE_STRIP, command.vertexOffset, command.vertexCount, verticesPerPatch = 0)\n\n            // -- reset stencil\n            localStyle.channelWriteMask = ChannelMask(red = false, green = false, blue = false, alpha = false)\n            localStyle.stencil.stencilFunc(StencilTest.ALWAYS, 0x0, 0xff)\n            localStyle.stencil.stencilOp(StencilOperation.ZERO, StencilOperation.ZERO, StencilOperation.ZERO)\n            Driver.instance.setState(localStyle)\n            Driver.instance.drawVertexBuffer(shader, listOf(command.vertexBuffer), DrawPrimitive.TRIANGLE_STRIP, command.vertexOffset, command.vertexCount, verticesPerPatch = 0)\n\n            localStyle.stencil.stencilTest = StencilTest.DISABLED\n            localStyle.channelWriteMask = ChannelMask(red = true, green = true, blue = true, alpha = true)\n            Driver.instance.setState(localStyle)\n        }\n        shader.end()\n    }\n\n    fun renderStrokeCommandsInterleaved(drawContext: DrawContext, drawStyle: DrawStyle, commands: List<Command>, fringeScale: Double) {\n        if (commands.isNotEmpty()) {\n            val shader = shaderManager.shader(drawStyle.shadeStyle, listOf(vertexFormat))\n            shader.begin()\n            drawContext.applyToShader(shader)\n            drawStyle.applyToShader(shader)\n            Driver.instance.setState(drawStyle)\n\n            val localStyle = drawStyle\n            val vertexCount = commands.last().let { it.vertexOffset + it.vertexCount }\n            val fs = fringeScale\n            shader.uniform(\"strokeMult\", (drawStyle.strokeWeight*0.5 + fs*0.5 ) / (fs) )\n            shader.uniform(\"strokeFillFactor\", 0.0)\n\n            shader.uniform(\"bounds\", Vector4(-1000.0, -1000.0, 2000.0, 2000.0))\n            localStyle.channelWriteMask = ChannelMask(true, true, true, true)\n            // -- pre\n            shader.uniform(\"strokeThr\", 1.0f - 0.5f / 255.0f)\n            localStyle.stencil.stencilFunc(StencilTest.EQUAL, 0x00, 0xff)\n            localStyle.stencil.stencilOp(StencilOperation.KEEP, StencilOperation.KEEP, StencilOperation.INCREASE)\n            Driver.instance.setState(localStyle)\n            Driver.instance.drawVertexBuffer(shader, listOf(commands[0].vertexBuffer), DrawPrimitive.TRIANGLE_STRIP, commands[0].vertexOffset, vertexCount, verticesPerPatch = 0)\n\n            // -- anti-aliased\n            shader.uniform(\"strokeThr\", 0.0f)\n            localStyle.stencil.stencilFunc(StencilTest.EQUAL, 0x00, 0xff)\n            localStyle.stencil.stencilOp(StencilOperation.KEEP, StencilOperation.KEEP, StencilOperation.KEEP)\n            Driver.instance.setState(localStyle)\n            Driver.instance.drawVertexBuffer(shader, listOf(commands[0].vertexBuffer), DrawPrimitive.TRIANGLE_STRIP, commands[0].vertexOffset, vertexCount, verticesPerPatch = 0)\n\n            // -- reset stencil\n            localStyle.channelWriteMask = ChannelMask(false, false, false, false)\n            localStyle.stencil.stencilFunc(StencilTest.ALWAYS, 0x0, 0xff)\n            localStyle.stencil.stencilOp(StencilOperation.ZERO, StencilOperation.ZERO, StencilOperation.ZERO)\n            Driver.instance.setState(localStyle)\n            Driver.instance.drawVertexBuffer(shader, listOf(commands[0].vertexBuffer), DrawPrimitive.TRIANGLE_STRIP, commands[0].vertexOffset, vertexCount, verticesPerPatch = 0)\n\n            localStyle.stencil.stencilTest = StencilTest.DISABLED\n            localStyle.channelWriteMask = ChannelMask(true, true, true, true)\n            Driver.instance.setState(localStyle)\n        }\n    }\n\n    fun renderConvexFillCommands(drawContext: DrawContext, drawStyle: DrawStyle, commands: List<Command>, fringeScale: Double) {\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertexFormat)\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n\n        shader.uniform(\"strokeThr\", -1.0f)\n        shader.uniform(\"strokeMult\", 1.0)\n\n        shader.uniform(\"strokeFillFactor\", 1.0)\n        commands.forEach { command ->\n            if (command.type == ExpansionType.FILL) {\n                Driver.instance.drawVertexBuffer(shader, listOf(command.vertexBuffer), DrawPrimitive.TRIANGLE_FAN, command.vertexOffset, command.vertexCount, verticesPerPatch = 0)\n            }\n        }\n        commands.forEach { command ->\n            if (command.type == ExpansionType.FRINGE) {\n                Driver.instance.drawVertexBuffer(shader, listOf(command.vertexBuffer), DrawPrimitive.TRIANGLE_STRIP, command.vertexOffset, command.vertexCount, verticesPerPatch = 0)\n            }\n        }\n    }\n\n    fun renderFillCommands(drawContext: DrawContext, drawStyle: DrawStyle, commands: List<Command>, fringeWidth: Double) {\n        if (commands.isEmpty()) {\n            return\n        }\n\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertexFormat)\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n\n        val localStyle = drawStyle\n\n        // -- pass 1 : draw fill shapes in stencil only\n        shader.uniform(\"strokeThr\", -1.0f)\n        shader.uniform(\"strokeMult\", 1.0)\n\n\n        shader.uniform(\"strokeFillFactor\", 1.0)\n\n        val minX = commands.minByOrNull { it.minX }?.minX ?: error(\"no commands\")\n        val minY = commands.minByOrNull { it.minY }?.minY ?: error(\"no commands\")\n        val maxX = commands.maxByOrNull { it.maxX }?.maxX ?: error(\"no commands\")\n        val maxY = commands.maxByOrNull { it.maxY }?.maxY ?: error(\"no commands\")\n\n        val command = commands[0]\n        shader.uniform(\"bounds\", Vector4(command.minX, command.minY, command.maxX - command.minX, command.maxY - command.minY))\n        localStyle.frontStencil = StencilStyle()\n        localStyle.backStencil = StencilStyle()\n\n        localStyle.frontStencil.stencilWriteMask = 0xff\n        localStyle.backStencil.stencilWriteMask = 0xff\n\n        localStyle.frontStencil.stencilOp(onStencilTestFail = StencilOperation.KEEP, onDepthTestFail = StencilOperation.KEEP, onDepthTestPass = StencilOperation.INCREASE_WRAP)\n        localStyle.backStencil.stencilOp(onStencilTestFail = StencilOperation.KEEP, onDepthTestFail = StencilOperation.KEEP, onDepthTestPass = StencilOperation.DECREASE_WRAP)\n        localStyle.frontStencil.stencilFunc(stencilTest = StencilTest.ALWAYS, testReference = 0, writeMask = 0xff)\n        localStyle.backStencil.stencilFunc(stencilTest = StencilTest.ALWAYS, testReference = 0, writeMask = 0xff)\n\n        localStyle.channelWriteMask = ChannelMask.NONE\n        localStyle.cullTestPass = CullTestPass.ALWAYS\n        Driver.instance.setState(localStyle)\n\n        for (c in commands) {\n            if (c.type == ExpansionType.FILL) {\n                Driver.instance.drawVertexBuffer(shader, listOf(c.vertexBuffer), DrawPrimitive.TRIANGLE_FAN, c.vertexOffset, c.vertexCount, verticesPerPatch = 0)\n            }\n        }\n\n        localStyle.frontStencil = localStyle.stencil\n        localStyle.backStencil = localStyle.stencil\n\n        // -- pass 2: draw anti-aliased fringes\n        localStyle.channelWriteMask = ChannelMask.ALL\n        shader.uniform(\"strokeThr\", 0.0f)\n        shader.uniform(\"strokeMult\", 2.0)\n        localStyle.stencil.stencilFunc(stencilTest = StencilTest.EQUAL, testReference = 0x00, writeMask = 0xff)\n        localStyle.stencil.stencilOp(onStencilTestFail = StencilOperation.KEEP, onDepthTestFail = StencilOperation.KEEP, onDepthTestPass = StencilOperation.KEEP)\n\n        Driver.instance.setState(localStyle)\n        for (c in commands) {\n            if (c.type == ExpansionType.FRINGE) {\n                Driver.instance.drawVertexBuffer(shader, listOf(c.vertexBuffer), DrawPrimitive.TRIANGLE_STRIP, c.vertexOffset, c.vertexCount, verticesPerPatch = 0)\n            }\n        }\n        Driver.instance.setState(localStyle)\n\n        // -- pass 3: fill in stencilled area in pass 1\n        shader.uniform(\"strokeThr\", -1.0f)\n        shader.uniform(\"strokeMult\", 1.0)\n        localStyle.stencil.stencilFunc(stencilTest = StencilTest.NOT_EQUAL, testReference = 0x0, writeMask = 0xff)\n        localStyle.stencil.stencilTestMask = 0x1\n        localStyle.stencil.stencilOp(onStencilTestFail = StencilOperation.ZERO, onDepthTestFail = StencilOperation.ZERO, onDepthTestPass = StencilOperation.ZERO)\n        localStyle.channelWriteMask = ChannelMask.ALL\n        localStyle.cullTestPass = CullTestPass.ALWAYS\n\n        val quad = quads[quadCounter.mod(quads.size)]\n        quad.shadow.writer().apply {\n            rewind()\n            write(minX.toFloat(), minY.toFloat()); write(0.5f, 1.0f, 0.0f)\n            write(minX.toFloat(), maxY.toFloat()); write(0.5f, 1.0f, 0.0f)\n            write(maxX.toFloat(), maxY.toFloat()); write(0.5f, 1.0f, 0.0f)\n\n            write(maxX.toFloat(), maxY.toFloat()); write(0.5f, 1.0f, 0.0f)\n            write(maxX.toFloat(), minY.toFloat()); write(0.5f, 1.0f, 0.0f)\n            write(minX.toFloat(), minY.toFloat()); write(0.5f, 1.0f, 0.0f)\n        }\n        quad.shadow.upload()\n        quadCounter++\n        Driver.instance.setState(localStyle)\n            Driver.instance.drawVertexBuffer(shader, listOf(quad), DrawPrimitive.TRIANGLES, 0, 6, verticesPerPatch = 0)\n\n\n        localStyle.stencil.stencilTest = StencilTest.DISABLED\n        shader.end()\n    }\n\n    fun toCommand(vertices: VertexBuffer, expansion: Expansion, vertexOffset: Int): Command {\n        if (expansion.vertexCount > 0) {\n            val command = Command(vertices, expansion.type, vertexOffset, expansion.vertexCount + 2,\n                    expansion.minx, expansion.miny, expansion.maxx, expansion.maxy)\n            val w = vertices.shadow.writer().apply {\n                positionElements = vertexOffset\n            }\n\n            val vertexSize = (expansion.bufferPosition - expansion.bufferStart) / expansion.vertexCount\n\n            // insert leading degenerate triangles\n            w.write(expansion.fb, expansion.bufferStart, vertexSize)\n\n            w.write(expansion.fb, expansion.bufferStart, expansion.bufferPosition - expansion.bufferStart)\n\n            // insert trailing degenerate triangles\n            w.write(expansion.fb, expansion.bufferStart + vertexSize * (expansion.vertexCount - 1), vertexSize)\n\n            return command\n        } else {\n            return Command(vertices, ExpansionType.SKIP, 0, 0, 0.0, 0.0, 0.0, 0.0)\n        }\n    }\n\n    fun toCommands(vertices: VertexBuffer, expansions: List<Expansion>): List<Command> {\n        var vertexOffset = 0\n        val commands = mutableListOf<Command>()\n        expansions.forEach {\n            val command = toCommand(vertices, it, vertexOffset)\n            if (command.type != ExpansionType.SKIP) {\n                commands.add(command)\n                vertexOffset += it.vertexCount + 2\n            }\n        }\n        vertices.shadow.uploadElements(0, vertexOffset)\n        return commands\n    }\n\n    private var counter = 0\n    private var quadCounter = 0\n\n    private fun vertices(count: Int): VertexBuffer {\n        return if (count < 128) {\n            counter++\n            fewVertices[counter.mod(fewVertices.size)]\n        } else {\n            manyVertices\n        }\n    }\n\n    fun renderStroke(drawContext: DrawContext, drawStyle: DrawStyle, expansion: Expansion, fringeScale: Double) {\n        renderStrokeCommands(drawContext, drawStyle, toCommands(vertices(expansion.vertexCount), listOf(expansion)), fringeScale)\n    }\n\n    fun renderStrokes(drawContext: DrawContext, drawStyle: DrawStyle, expansions: List<Expansion>, fringeScale: Double) {\n        renderStrokeCommandsInterleaved(drawContext, drawStyle, toCommands(vertices(expansions.sumOf { it.vertexCount }), expansions), fringeScale)\n    }\n\n    fun renderFill(drawContext: DrawContext, drawStyle: DrawStyle, expansions: List<Expansion>, convex: Boolean, fringeScale: Double) {\n        if (convex) {\n            renderConvexFillCommands(drawContext, drawStyle, toCommands(vertices(expansions.sumOf { it.vertexCount }), expansions), fringeScale)\n        } else {\n            renderFillCommands(drawContext, drawStyle, toCommands(vertices(expansions.sumOf { it.vertexCount }), expansions), fringeScale)\n        }\n    }\n\n    fun renderFills(drawContext: DrawContext, drawStyle: DrawStyle, expansions: List<Expansion>, fringeScale: Double) {\n        renderFillCommands(drawContext, drawStyle, toCommands(vertices(expansions.sumOf { it.vertexCount }), expansions), fringeScale)\n    }\n}",null,"package org.openrndr.internal\n\nimport org.openrndr.draw.*\nimport org.openrndr.math.Vector2\nimport kotlin.math.floor\n\nclass GlyphRectangle(val character: Char, val x: Double, val y: Double, val width: Double, val height: Double)\n\nclass FontImageMapDrawer {\n\n    private val shaderManager: ShadeStyleManager = ShadeStyleManager.fromGenerators(\n        \"font-image-map\",\n        vsGenerator = Driver.instance.shaderGenerators::fontImageMapVertexShader,\n        fsGenerator = Driver.instance.shaderGenerators::fontImageMapFragmentShader\n    )\n\n    private val maxQuads = 20_000\n\n    private val vertexFormat = VertexFormat().apply {\n        textureCoordinate(2)\n        attribute(\"bounds\", VertexElementType.VECTOR4_FLOAT32)\n        position(3)\n        attribute(\"instance\", VertexElementType.FLOAT32)\n    }\n\n    private val fewQuads = List(DrawerConfiguration.vertexBufferMultiBufferCount) {\n        vertexBuffer(vertexFormat, 6 * 128)\n    }\n\n    private val manyQuads = VertexBuffer.createDynamic(vertexFormat, 6 * maxQuads)\n\n    private var quadCount = 0\n\n    var counter = 0\n\n    fun getQueue(size: Int): VertexBuffer {\n        if (size < 128) {\n            return fewQuads[counter.mod(fewQuads.size)]\n        } else {\n            return manyQuads\n        }\n    }\n\n    fun drawText(\n        context: DrawContext,\n        drawStyle: DrawStyle,\n        text: String,\n        x: Double,\n        y: Double\n    ) = drawTexts(context, drawStyle, listOf(text), listOf(Vector2(x, y)))\n\n\n    fun drawTexts(\n        context: DrawContext,\n        drawStyle: DrawStyle,\n        texts: List<String>,\n        positions: List<Vector2>\n    ): List<List<GlyphRectangle>> {\n        val vertices = if (texts.sumOf { it.length } < 128) fewQuads[counter.mod(fewQuads.size)] else manyQuads\n\n        val fontMap = drawStyle.fontMap as? FontImageMap\n        if (fontMap != null) {\n            var instance = 0\n\n            val textAndPositionPairs = texts.zip(positions)\n            for ((text, position) in textAndPositionPairs) {\n                var cursorX = 0.0\n                val cursorY = 0.0\n\n                val bw = vertices.shadow.writer()\n                bw.position = vertices.vertexFormat.size * quadCount * 6\n\n                var lastChar: Char? = null\n                text.forEach {\n                    val lc = lastChar\n                    if (drawStyle.kerning == KernMode.METRIC) {\n                        cursorX += if (lc != null) fontMap.kerning(lc, it) else 0.0\n                    }\n                    val glyphMetrics = fontMap.glyphMetrics[it] ?: fontMap.glyphMetrics.getValue(' ')\n                    val (dx, _) = insertCharacterQuad(\n                        fontMap,\n                        bw,\n                        it,\n                        position.x + cursorX,\n                        position.y + cursorY,\n                        instance,\n                        drawStyle.textSetting\n                    )\n                    cursorX += glyphMetrics.advanceWidth + dx\n                    lastChar = it\n                }\n                instance++\n            }\n            flush(context, drawStyle, vertices)\n        }\n        return emptyList()\n    }\n\n    var queuedInstances = 0\n    fun queueText(\n        fontMap: FontMap,\n        text: String,\n        x: Double,\n        y: Double,\n        tracking: Double = 0.0,\n        kerning: KernMode, // = KernMode.METRIC,\n        textSetting: TextSettingMode,// = TextSettingMode.PIXEL,\n        vertices: VertexBuffer,\n    ) {\n        val bw = vertices.shadow.writer()\n        bw.position = vertices.vertexFormat.size * quadCount * 6\n        fontMap as FontImageMap\n        var cursorX = 0.0\n        val cursorY = 0.0\n        var lastChar: Char? = null\n        text.forEach {\n            val lc = lastChar\n            val metrics = fontMap.glyphMetrics[it]\n            metrics?.let { m ->\n                if (kerning == KernMode.METRIC) {\n                    cursorX += if (lc != null) fontMap.kerning(lc, it) else 0.0\n                }\n                val (dx, _) = insertCharacterQuad(\n                    fontMap,\n                    bw,\n                    it,\n                    x + cursorX,\n                    y + cursorY,\n                    0,\n                    textSetting\n                )\n                cursorX += m.advanceWidth + tracking + dx\n                lastChar = it\n            }\n        }\n        queuedInstances++\n    }\n\n\n    fun flush(context: DrawContext, drawStyle: DrawStyle, vertices: VertexBuffer) {\n        if (quadCount > 0) {\n            vertices.shadow.uploadElements(0, quadCount * 6)\n            val shader = shaderManager.shader(drawStyle.shadeStyle, vertices.vertexFormat)\n            shader.begin()\n            context.applyToShader(shader)\n\n            Driver.instance.setState(drawStyle)\n            drawStyle.applyToShader(shader)\n            (drawStyle.fontMap as FontImageMap).texture.bind(0)\n            Driver.instance.drawVertexBuffer(\n                shader,\n                listOf(vertices),\n                DrawPrimitive.TRIANGLES,\n                0,\n                quadCount * 6,\n                verticesPerPatch = 0\n            )\n            shader.end()\n            quadCount = 0\n        }\n        queuedInstances = 0\n        if (vertices != manyQuads) {\n            counter++\n        }\n    }\n\n    private fun insertCharacterQuad(\n        fontMap: FontImageMap,\n        bw: BufferWriter,\n        character: Char,\n        cx: Double,\n        cy: Double,\n        instance: Int,\n        textSetting: TextSettingMode\n    ): Pair<Double, GlyphRectangle?> {\n        val rectangle = fontMap.map[character] ?: fontMap.map[' ']\n        val targetContentScale = RenderTarget.active.contentScale\n        val fmcs = fontMap.contentScale.toFloat()\n\n        val metrics =\n            fontMap.glyphMetrics[character] ?: fontMap.glyphMetrics[' '] ?: error(\"glyph or space substitute not found\")\n        val xshift = (metrics.xBitmapShift / fmcs).toFloat()\n        val yshift = (metrics.yBitmapShift / fmcs).toFloat()\n\n\n        val sx = cx + xshift\n        val sy = cy + yshift\n\n        val x = if (textSetting == TextSettingMode.PIXEL) floor(sx * targetContentScale) / targetContentScale else sx\n        val y = if (textSetting == TextSettingMode.PIXEL) floor(sy * targetContentScale) / targetContentScale else sy\n\n\n        val glyphRectangle =\n            if (rectangle != null) {\n                val pad = 2.0f\n                val u0 = (rectangle.x.toFloat() - pad) / fontMap.texture.effectiveWidth\n                val u1 = (rectangle.x.toFloat() + rectangle.width.toFloat() + pad) / fontMap.texture.effectiveWidth\n                val v0 = (rectangle.y.toFloat() - pad) / fontMap.texture.effectiveHeight\n                val v1 = v0 + (pad * 2 + rectangle.height.toFloat()) / fontMap.texture.effectiveHeight\n\n                val x0 = x.toFloat() - pad / fmcs\n                val x1 = x.toFloat() + (rectangle.width.toFloat() / fmcs) + pad / fmcs\n                val y0 = y.toFloat() - pad / fmcs\n                val y1 = y.toFloat() + rectangle.height.toFloat() / fmcs + pad / fmcs\n\n                val s0 = 0.0f\n                val t0 = 0.0f\n                val s1 = 1.0f\n                val t1 = 1.0f\n\n                val w = (x1 - x0)\n                val h = (y1 - y0)\n                val z = quadCount.toFloat()\n\n                val floatInstance = instance.toFloat()\n\n                if (quadCount < maxQuads) {\n                    bw.apply {\n                        write(u0, v0); write(s0, t0, w, h); write(x0, y0, z); write(floatInstance)\n                        write(u1, v0); write(s1, t0, w, h); write(x1, y0, z); write(floatInstance)\n                        write(u1, v1); write(s1, t1, w, h); write(x1, y1, z); write(floatInstance)\n\n                        write(u0, v0); write(s0, t0, w, h); write(x0, y0, z); write(floatInstance)\n                        write(u0, v1); write(s0, t1, w, h); write(x0, y1, z); write(floatInstance)\n                        write(u1, v1); write(s1, t1, w, h); write(x1, y1, z); write(floatInstance)\n                    }\n                    quadCount++\n                }\n                GlyphRectangle(character, x0.toDouble(), y0.toDouble(), (x1 - x0).toDouble(), (y1 - y0).toDouble())\n            } else {\n                null\n            }\n        return Pair(x - sx, glyphRectangle)\n    }\n}","package org.openrndr.internal\n\nimport org.openrndr.math.Vector2\nimport org.openrndr.draw.*\nimport org.openrndr.math.Vector3\nimport org.openrndr.math.Vector4\nimport org.openrndr.platform.Platform\nimport org.openrndr.platform.PlatformType\nimport org.openrndr.shape.Rectangle\n\nclass ImageDrawer {\n    private val vertices: VertexBuffer = VertexBuffer.createDynamic(vertexFormat {\n        position(3)\n        normal(3)\n        textureCoordinate(2)\n    }, 6, Session.root)\n\n    private var count = 0\n    private val instanceFormat = vertexFormat {\n        attribute(\"source\", VertexElementType.VECTOR4_FLOAT32)\n        attribute(\"target\", VertexElementType.VECTOR4_FLOAT32)\n        attribute(\"layer\", VertexElementType.FLOAT32)\n    }\n\n\n    private val singleInstanceAttributes = List(DrawerConfiguration.vertexBufferMultiBufferCount) {\n        vertexBuffer(instanceFormat, 1, Session.root)\n    }\n\n    private var instanceAttributes = vertexBuffer(instanceFormat, 10, Session.root)\n\n    private val shaderManager: ShadeStyleManager = ShadeStyleManager.fromGenerators(\n        \"image\",\n        vsGenerator = Driver.instance.shaderGenerators::imageVertexShader,\n        fsGenerator = Driver.instance.shaderGenerators::imageFragmentShader\n    )\n\n    private val arrayTextureShaderManager: ShadeStyleManager = ShadeStyleManager.fromGenerators(\n        \"array-texture\",\n        vsGenerator = Driver.instance.shaderGenerators::imageArrayTextureVertexShader,\n        fsGenerator = Driver.instance.shaderGenerators::imageArrayTextureFragmentShader\n    )\n\n    init {\n        val w = vertices.shadow.writer()\n\n        w.rewind()\n        val pa = Vector3(0.0, 0.0, 0.0)\n        val pb = Vector3(1.0, 0.0, 0.0)\n        val pc = Vector3(1.0, 1.0, 0.0)\n        val pd = Vector3(0.0, 1.0, 0.0)\n\n        val u0 = 0.0\n        val u1 = 1.0\n        val v0 = 1.0\n        val v1 = 0.0\n\n        val ta = Vector2(u0, v1)\n        val tb = Vector2(u1, v1)\n        val tc = Vector2(u1, v0)\n        val td = Vector2(u0, v0)\n\n        val n = Vector3(0.0, 0.0, -1.0)\n        w.apply {\n            write(pa); write(n); write(ta)\n            write(pd); write(n); write(td)\n            write(pc); write(n); write(tc)\n\n            write(pc); write(n); write(tc)\n            write(pb); write(n); write(tb)\n            write(pa); write(n); write(ta)\n        }\n        vertices.shadow.upload()\n    }\n\n    private fun assertInstanceSize(size: Int) {\n        if (instanceAttributes.vertexCount < size) {\n            Session.root.untrack(instanceAttributes)\n            instanceAttributes.destroy()\n            instanceAttributes = vertexBuffer(instanceFormat, size, Session.root)\n        }\n    }\n\n    fun drawImage(\n        drawContext: DrawContext, drawStyle: DrawStyle, colorBuffer: ColorBuffer,\n        rectangles: List<Pair<Rectangle, Rectangle>>\n    ) {\n        require(colorBuffer.multisample == BufferMultisample.Disabled) {\n            \"\"\"multisample color buffer $colorBuffer needs to be resolved first\"\"\"\n        }\n\n        val instanceAttributes = if (rectangles.size == 1) {\n            singleInstanceAttributes[count.mod(singleInstanceAttributes.size)]\n        } else {\n            instanceAttributes\n        }\n\n        assertInstanceSize(rectangles.size)\n\n        val shader = shaderManager.shader(\n            drawStyle.shadeStyle,\n            listOf(vertices.vertexFormat),\n            listOf(instanceAttributes.vertexFormat)\n        )\n\n        val iw = instanceAttributes.shadow.writer()\n        iw.rewind()\n\n        rectangles.forEach {\n            val (source, target) = it\n            iw.write(\n                Vector4(\n                    source.corner.x / colorBuffer.width,\n                    source.corner.y / colorBuffer.height,\n                    source.width / colorBuffer.width,\n                    source.height / colorBuffer.height\n                )\n            )\n            iw.write(Vector4(target.corner.x, target.corner.y, target.width, target.height))\n            iw.write(0.0f)\n        }\n        instanceAttributes.shadow.uploadElements(0, rectangles.size)\n\n        colorBuffer.bind(0)\n        shader.begin()\n        drawContext.applyToShader(shader)\n        shader.uniform(\"u_flipV\", if (colorBuffer.flipV) 1 else 0)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawInstances(\n            shader,\n            listOf(vertices),\n            listOf(instanceAttributes) + (drawStyle.shadeStyle?.attributes ?: emptyList()),\n            DrawPrimitive.TRIANGLES,\n            0,\n            6,\n            0,\n            rectangles.size,\n            verticesPerPatch = 0\n        )\n        shader.end()\n        count++\n    }\n\n    fun drawImage(\n        drawContext: DrawContext, drawStyle: DrawStyle, arrayTexture: ArrayTexture,\n        layers: List<Int>, rectangles: List<Pair<Rectangle, Rectangle>>\n    ) {\n\n        assertInstanceSize(rectangles.size)\n        val shader = arrayTextureShaderManager.shader(\n            drawStyle.shadeStyle,\n            listOf(vertices.vertexFormat),\n            listOf(instanceAttributes.vertexFormat)\n        )\n\n        val iw = instanceAttributes.shadow.writer()\n        iw.rewind()\n\n        rectangles.forEachIndexed { index, it ->\n            val (source, target) = it\n            iw.write(\n                Vector4(\n                    source.corner.x / arrayTexture.width,\n                    source.corner.y / arrayTexture.height,\n                    source.width / arrayTexture.width,\n                    source.height / arrayTexture.height\n                )\n            )\n            iw.write(Vector4(target.corner.x, target.corner.y, target.width, target.height))\n            iw.write(layers[index].toFloat())\n        }\n        instanceAttributes.shadow.uploadElements(0, rectangles.size)\n\n        arrayTexture.bind(0)\n        shader.begin()\n        drawContext.applyToShader(shader)\n        shader.uniform(\"u_flipV\", if (arrayTexture.flipV) 1 else 0)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawInstances(\n            shader,\n            listOf(vertices),\n            listOf(instanceAttributes) + (drawStyle.shadeStyle?.attributes ?: emptyList()),\n            DrawPrimitive.TRIANGLES,\n            0,\n            6,\n            0,\n            rectangles.size,\n            verticesPerPatch = 0\n        )\n        shader.end()\n    }\n\n    fun drawImage(\n        drawContext: DrawContext,\n        drawStyle: DrawStyle, colorBuffer: ColorBuffer, x: Double, y: Double, width: Double, height: Double\n    ) {\n        drawImage(drawContext, drawStyle, colorBuffer, listOf(colorBuffer.bounds to Rectangle(x, y, width, height)))\n    }\n\n    fun drawImage(\n        drawContext: DrawContext,\n        drawStyle: DrawStyle,\n        arrayTexture: ArrayTexture,\n        layer: Int,\n        x: Double,\n        y: Double,\n        width: Double,\n        height: Double\n    ) {\n        drawImage(\n            drawContext, drawStyle, arrayTexture, listOf(layer), listOf(\n                arrayTexture.bounds to Rectangle(\n                    x,\n                    y,\n                    width,\n                    height\n                )\n            )\n        )\n    }\n}","@file:Suppress(\"Duplicates\")\n\npackage org.openrndr.internal\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.draw.*\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.Vector3\n\nclass MeshLineDrawer {\n    private val shaderManager: ShadeStyleManager = ShadeStyleManager.fromGenerators(\n        \"mesh-line\",\n        vsGenerator = Driver.instance.shaderGenerators::meshLineVertexShader,\n        fsGenerator = Driver.instance.shaderGenerators::meshLineFragmentShader\n    )\n\n    private val vertexFormat = VertexFormat().apply {\n        attribute(\"previous\", VertexElementType.VECTOR3_FLOAT32)\n        position(3)\n        attribute(\"next\", VertexElementType.VECTOR3_FLOAT32)\n        attribute(\"side\", VertexElementType.FLOAT32)\n        attribute(\"width\", VertexElementType.FLOAT32)\n        attribute(\"uv\", VertexElementType.VECTOR2_FLOAT32)\n        attribute(\"element\", VertexElementType.FLOAT32)\n        color(4)\n    }\n\n    private val manyVertices = vertexBuffer(vertexFormat, 1024 * 1024, Session.root)\n    private val fewVerticesCount = 1024\n    private val fewVertices = List(DrawerConfiguration.vertexBufferMultiBufferCount) {\n        vertexBuffer(\n            vertexFormat,\n            fewVerticesCount,\n            Session.root\n        )\n    }\n    private var counter = 0\n\n    private fun vertices(count: Int): VertexBuffer {\n        return if (count < fewVerticesCount) {\n            counter++\n            fewVertices[counter.mod(fewVertices.size)]\n        } else {\n            manyVertices\n        }\n    }\n\n    fun drawLineSegments(\n        drawContext: DrawContext, drawStyle: DrawStyle, segments: List<Vector3>,\n        weights: List<Double> = emptyList(),\n        colors: List<ColorRGBa> = emptyList()\n    ) {\n        val vertices = vertices(segments.size * 2)\n\n        val colorCount = colors.size\n        val defaultColor = colors.lastOrNull() ?: drawStyle.stroke ?: ColorRGBa.TRANSPARENT\n\n        val vertexCount = vertices.put {\n            for (i in 0 until segments.size step 2) {\n                val width = weights.getOrElse(i) { drawStyle.strokeWeight }.toFloat()\n                val element = (i / 2).toFloat()\n\n                val color = if (i < colorCount) colors[i] else defaultColor\n\n                write(segments[i])\n                write(segments[i])\n                write(segments[i + 1])\n                write(-1.0f)\n                write(width)\n                write(Vector2.ZERO)\n                write(element)\n                write(color)\n\n                write(segments[i])\n                write(segments[i])\n                write(segments[i + 1])\n                write(+1.0f)\n                write(width)\n                write(Vector2.ZERO)\n                write(element)\n                write(color)\n\n                write(segments[i])\n                write(segments[i + 1])\n                write(segments[i + 1])\n                write(+1.0f)\n                write(width)\n                write(Vector2.ZERO)\n                write(element)\n                write(color)\n\n                // --\n                write(segments[i])\n                write(segments[i + 1])\n                write(segments[i + 1])\n                write(+1.0f)\n                write(width)\n                write(Vector2.ZERO)\n                write(element)\n                write(color)\n\n                write(segments[i])\n                write(segments[i + 1])\n                write(segments[i + 1])\n                write(-1.0f)\n                write(width)\n                write(Vector2.ZERO)\n                write(element)\n                write(color)\n\n                write(segments[i])\n                write(segments[i])\n                write(segments[i + 1])\n                write(-1.0f)\n                write(width)\n                write(Vector2.ZERO)\n                write(element)\n                write(color)\n            }\n        }\n\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertices.vertexFormat)\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawVertexBuffer(\n            shader,\n            listOf(vertices),\n            DrawPrimitive.TRIANGLES,\n            0,\n            vertexCount,\n            verticesPerPatch = 0\n        )\n        shader.end()\n    }\n\n    fun drawLineStrips(\n        drawContext: DrawContext,\n        drawStyle: DrawStyle,\n        strips: List<List<Vector3>>,\n        weights: List<Double> = emptyList(),\n        colors: List<ColorRGBa> = emptyList(),\n        closed: List<Boolean> = emptyList()\n    ) {\n        val vertices = vertices(strips.sumOf { it.size + 4 })\n\n        val colorCount = colors.size\n        val defaultColor = colors.lastOrNull() ?: drawStyle.stroke ?: ColorRGBa.TRANSPARENT\n        val vertexCount = vertices.put {\n            for ((element, strip) in strips.withIndex()) {\n                val stripClosed = closed.getOrNull(element) ?: false\n                val color = if (element < colorCount) colors[element] else defaultColor\n\n                if (strip.size >= 2) {\n                    val width = weights.getOrElse(element) { drawStyle.strokeWeight }.toFloat()\n                    val elementF = element.toFloat()\n\n                    var previous = if (stripClosed) strip.last() else strip[0]\n                    // leading degenerate\n                    write(strip[0])\n                    write(strip[0])\n                    write(strip[1])\n                    write(-1.0f)\n                    write(width)\n                    write(Vector2.ZERO)\n                    write(elementF)\n                    write(color)\n\n                    for ((current, next) in strip.zipWithNext()) {\n                        write(previous)\n                        write(current)\n                        write(next)\n                        write(-1.0f)\n                        write(width)\n                        write(Vector2.ZERO)\n                        write(elementF)\n                        write(color)\n\n                        write(previous)\n                        write(current)\n                        write(next)\n                        write(1.0f)\n                        write(width)\n                        write(Vector2.ZERO)\n                        write(elementF)\n                        write(color)\n                        previous = current\n                    }\n\n                    // last point\n                    write(previous)\n                    write(strip.last())\n                    write(strip.last())\n                    write(-1.0f)\n                    write(width)\n                    write(Vector2.ZERO)\n                    write(elementF)\n                    write(color)\n\n                    write(previous)\n                    write(strip.last())\n                    write(strip.last())\n                    write(1.0f)\n                    write(width)\n                    write(Vector2.ZERO)\n                    write(elementF)\n                    write(color)\n\n                    // -- degenerate\n                    write(previous)\n                    write(strip.last())\n                    write(strip.last())\n                    write(1.0f)\n                    write(width)\n                    write(Vector2.ZERO)\n                    write(elementF)\n                    write(color)\n                }\n            }\n        }\n\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertices.vertexFormat)\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawVertexBuffer(\n            shader,\n            listOf(vertices),\n            DrawPrimitive.TRIANGLE_STRIP,\n            0,\n            vertexCount,\n            verticesPerPatch = 0\n        )\n        shader.end()\n    }\n}","package org.openrndr.internal\n\nimport org.openrndr.draw.*\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.Vector3\nimport kotlin.jvm.JvmName\n\nclass PerformanceLineDrawer {\n\n    val vertexFormat = vertexFormat {\n        position(3)\n        attribute(\"instance\", VertexElementType.FLOAT32)\n        attribute(\"vertexOffset\", VertexElementType.FLOAT32)\n    }\n    private val manyVertices = vertexBuffer(vertexFormat, 1024 * 1024, Session.root)\n    private val fewVertices = List(DrawerConfiguration.vertexBufferMultiBufferCount) { vertexBuffer(vertexFormat, 128, Session.root) }\n\n    private var counter = 0\n\n    private val shaderManager: ShadeStyleManager = ShadeStyleManager.fromGenerators(\"performance-line\",\n            vsGenerator = Driver.instance.shaderGenerators::fastLineVertexShader,\n            fsGenerator = Driver.instance.shaderGenerators::fastLineFragmentShader)\n\n    @JvmName(\"drawLineSegments3d\")\n    fun drawLineSegments(drawContext: DrawContext,\n                         drawStyle: DrawStyle, segments: List<Vector3>) {\n        val vertices = vertices(segments.size)\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertexFormat)\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        val w = vertices.shadow.writer()\n\n        w.rewind()\n        var vertexCount = 0\n        segments.forEachIndexed { index, it ->\n            w.write(it)\n            w.write((index / 2).toFloat())\n            w.write((index % 2).toFloat())\n            vertexCount++\n        }\n        vertices.shadow.uploadElements(0, vertexCount)\n\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawVertexBuffer(shader, listOf(vertices), DrawPrimitive.LINES, 0, vertexCount, verticesPerPatch = 0)\n        shader.end()\n    }\n\n    private fun vertices(count: Int): VertexBuffer {\n        return if (count < 64) {\n            counter++\n            fewVertices[counter.mod(fewVertices.size)]\n        } else {\n            manyVertices\n        }\n    }\n\n    fun drawLineSegments(drawContext: DrawContext,\n                         drawStyle: DrawStyle, segments: List<Vector2>) {\n\n        val vertices = vertices(segments.size)\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertexFormat)\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        val w = vertices.shadow.writer()\n\n        w.rewind()\n\n        var vertexCount = 0\n        segments.forEachIndexed { index, it ->\n            w.write(it); w.write(0.0f)\n            w.write((index / 2).toFloat())\n            w.write((index % 2).toFloat())\n            vertexCount++\n        }\n        vertices.shadow.uploadElements(0, vertexCount)\n\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawVertexBuffer(shader, listOf(vertices), DrawPrimitive.LINES, 0, vertexCount, verticesPerPatch = 0)\n        shader.end()\n    }\n\n    fun drawLineLoops(drawContext: DrawContext,\n                      drawStyle: DrawStyle, loops: List<List<Vector2>>) {\n\n        val vertices = vertices(loops.sumOf { it.size })\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertexFormat)\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        val w = vertices.shadow.writer()\n        w.rewind()\n        var vertexCount = 0\n\n        loops.forEachIndexed { loopIndex, loop ->\n            //loop.forEachIndexed { index, it ->\n            for (i in 0 until loop.size - 1) {\n                w.write(loop[i]); w.write(0.0f)\n                w.write(loopIndex.toFloat())\n                w.write(1.0f)\n                w.write(loop[i + 1]); w.write(0.0f)\n                w.write(loopIndex.toFloat())\n                w.write(1.0f)\n\n                vertexCount += 2\n            }\n            //}\n        }\n        vertices.shadow.uploadElements(0, vertexCount)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawVertexBuffer(shader, listOf(vertices), DrawPrimitive.LINES, 0, vertexCount, verticesPerPatch = 0)\n        shader.end()\n    }\n\n    @JvmName(\"drawLineLoops3d\")\n    fun drawLineLoops(drawContext: DrawContext,\n                      drawStyle: DrawStyle, loops: List<List<Vector3>>) {\n        val vertices = vertices(loops.sumOf { it.size })\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertices.vertexFormat)\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        val w = vertices.shadow.writer()\n        w.rewind()\n        var vertexCount = 0\n\n        loops.forEachIndexed { loopIndex, loop ->\n            for (i in 0 until loop.size - 1) {\n                w.write(loop[i])\n                w.write(loopIndex.toFloat())\n                w.write(1.0f)\n                w.write(loop[i + 1])\n                w.write(loopIndex.toFloat())\n                w.write(1.0f)\n                vertexCount += 2\n            }\n        }\n        vertices.shadow.uploadElements(0, vertexCount)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawVertexBuffer(shader, listOf(vertices), DrawPrimitive.LINES, 0, vertexCount, verticesPerPatch = 0)\n        shader.end()\n    }\n}","package org.openrndr.internal\n\nimport org.openrndr.draw.*\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.Vector3\nimport org.openrndr.platform.Platform\nimport org.openrndr.platform.PlatformType\nimport kotlin.jvm.JvmName\n\nclass PointDrawer {\n    val vertices: VertexBuffer = VertexBuffer.createDynamic(VertexFormat().apply {\n        position(3)\n        normal(3)\n    }, 1)\n\n    internal var batch = PointBatch.create(10_000, session = Session.root)\n    private var count = 0\n\n\n    private val singleBatches = (0 until DrawerConfiguration.vertexBufferMultiBufferCount).map { PointBatch.create(1) }\n\n\n    private val shaderManager: ShadeStyleManager = ShadeStyleManager.fromGenerators(\"point\",\n            vsGenerator = Driver.instance.shaderGenerators::pointVertexShader,\n            fsGenerator = Driver.instance.shaderGenerators::pointFragmentShader)\n\n    internal fun ensureBatchSize(size: Int) {\n        if (batch.size < size) {\n            batch.destroy()\n            batch = PointBatch.create(size, session = Session.root)\n        }\n    }\n\n    init {\n        val w = vertices.shadow.writer()\n        w.rewind()\n        val x = 0.0\n        val y = 0.0\n        val pa = Vector3(x, y, 0.0)\n\n        val n = Vector3(0.0, 0.0, -1.0)\n        w.apply {\n            write(pa)\n            write(n)\n\n        }\n        vertices.shadow.upload()\n    }\n\n    @JvmName(\"drawPoints2D\")\n    fun drawPoints(drawContext: DrawContext, drawStyle: DrawStyle, positions: List<Vector2>) {\n        ensureBatchSize(positions.size)\n        batch.geometry.put {\n            for (i in positions.indices) {\n                write(Vector3(positions[i].x, positions[i].y, 0.0))\n            }\n        }\n        batch.drawStyle.put {\n            for (i in positions.indices) {\n                write(drawStyle)\n            }\n        }\n        drawPoints(drawContext, drawStyle, batch, positions.size)\n    }\n\n    @JvmName(\"drawPoints3D\")\n    fun drawPoints(drawContext: DrawContext, drawStyle: DrawStyle, positions: List<Vector3>) {\n        ensureBatchSize(positions.size)\n        batch.geometry.put {\n            for (i in positions.indices) {\n                write(positions[i])\n            }\n        }\n        batch.drawStyle.put {\n            for (i in positions.indices) {\n                write(drawStyle)\n            }\n        }\n        drawPoints(drawContext, drawStyle, batch, positions.size)\n    }\n\n    fun drawPoint(drawContext: DrawContext,\n                  drawStyle: DrawStyle, x: Double, y: Double, z: Double) {\n        ensureBatchSize(1)\n\n        val batch = singleBatches[count.mod(singleBatches.size)]\n\n        batch.geometry.put {\n            write(Vector3(x, y, z))\n        }\n        batch.drawStyle.put {\n            write(drawStyle)\n        }\n        drawPoints(drawContext, drawStyle, batch, 1)\n    }\n\n\n    fun drawPoints(drawContext: DrawContext, drawStyle: DrawStyle, batch: PointBatch, count: Int) {\n        val shader = shaderManager.shader(drawStyle.shadeStyle, listOf(vertices.vertexFormat), listOf(batch.geometry.vertexFormat, batch.drawStyle.vertexFormat))\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawInstances(shader, listOf(vertices), listOf(batch.drawStyle, batch.geometry) + (drawStyle.shadeStyle?.attributes\n                ?: emptyList()), DrawPrimitive.POINTS, 0, 1, 0, count)\n        shader.end()\n    }\n}","package org.openrndr.internal\n\nimport org.openrndr.draw.DrawContext\nimport org.openrndr.draw.DrawStyle\nimport org.openrndr.math.Vector2\n\nclass QualityLineDrawer {\n    private val expansionDrawer = ExpansionDrawer()\n\n    fun drawLineStrips(drawContext: DrawContext,\n                       drawStyle: DrawStyle,\n                       strips: List<List<Vector2>>,\n                       corners: List<List<Boolean>>,\n                       fringeWidth: Double) {\n        val fw = if (drawStyle.smooth) fringeWidth else 0.0\n        if (drawStyle.stroke != null && drawStyle.strokeWeight > 0.0) {\n            val expansions = strips.mapIndexed { index, it ->\n                val path = Path.fromLineStrip(it, corners[index], false)\n                path.expandStroke(\n                    fw,\n                    drawStyle.strokeWeight / 2.0,\n                    drawStyle.lineCap,\n                    drawStyle.lineJoin,\n                    drawStyle.miterLimit\n                )\n            }\n            expansionDrawer.renderStrokes(drawContext, drawStyle, expansions, fw)\n        }\n    }\n\n    fun drawLineStrips(drawContext: DrawContext,\n                       drawStyle: DrawStyle,\n                       strips: List<List<Vector2>>,\n                       corners: List<List<Boolean>>,\n                       weights: List<Double>,\n                       fringeWidth: Double) {\n        val fw = if (drawStyle.smooth) fringeWidth else 0.0\n        if (drawStyle.stroke != null && drawStyle.strokeWeight > 0.0) {\n            val expansions = strips.mapIndexed { index, it ->\n                val path = Path.fromLineStrip(it, corners[index], false)\n                path.expandStroke(fw, weights[index] / 2.0, drawStyle.lineCap, drawStyle.lineJoin, drawStyle.miterLimit)\n            }\n            expansionDrawer.renderStrokes(drawContext, drawStyle, expansions, fw)\n        }\n    }\n\n    fun drawLineLoops(drawContext: DrawContext,\n                      drawStyle: DrawStyle,\n                      strips: List<List<Vector2>>,\n                      corners: List<List<Boolean>>,\n                      fringeWidth: Double = 1.0) {\n        val effectiveFringeWidth = if (drawStyle.smooth) fringeWidth else 0.0\n        if (drawStyle.stroke != null && drawStyle.strokeWeight > 0) {\n            val expansions = strips.mapIndexed { index, it ->\n                val path = Path.fromLineStrip(it, corners[index], true)\n                path.expandStroke(\n                    effectiveFringeWidth,\n                    drawStyle.strokeWeight / 2.0,\n                    drawStyle.lineCap,\n                    drawStyle.lineJoin,\n                    drawStyle.miterLimit\n                )\n            }\n            expansionDrawer.renderStrokes(drawContext, drawStyle, expansions, effectiveFringeWidth)\n        }\n    }\n\n    fun drawLineLoops(drawContext: DrawContext,\n                      drawStyle: DrawStyle,\n                      strips: List<List<Vector2>>,\n                      corners: List<List<Boolean>>,\n                      weights: List<Double>, fringeWidth: Double = 1.0) {\n        val fw = if (drawStyle.smooth) fringeWidth else 0.0\n        if (drawStyle.stroke != null && drawStyle.strokeWeight > 0.0) {\n            val expansions = strips.mapIndexed { index, it ->\n                val path = Path.fromLineStrip(it, corners[index], true)\n                path.expandStroke(fw, weights[index] / 2.0, drawStyle.lineCap, drawStyle.lineJoin, drawStyle.miterLimit)\n            }\n            expansionDrawer.renderStrokes(drawContext, drawStyle, expansions, fw)\n        }\n    }\n}","package org.openrndr.internal\n\nimport org.openrndr.draw.DrawContext\nimport org.openrndr.draw.DrawStyle\nimport org.openrndr.draw.LineJoin\nimport org.openrndr.math.Vector2\n\nclass QualityPolygonDrawer {\n    private val expansionDrawer = ExpansionDrawer()\n\n    fun drawPolygon(drawContext: DrawContext,\n                    drawStyle: DrawStyle,\n                    loops: List<List<Vector2>>,\n                    corners: List<List<Boolean>>,\n                    fringeWidth: Double) {\n\n        if (drawStyle.fill != null && loops.isNotEmpty()) {\n            val path = Path.fromLineLoops(loops, corners)\n            val alpha = drawStyle.stroke?.alpha ?: 0.0\n            val fw = if (drawStyle.smooth) {\n                fringeWidth * (1.0 - alpha)\n            } else 0.0\n            val fillExpansions = path.expandFill(fw, fw, LineJoin.BEVEL, 2.4)\n            expansionDrawer.renderFill(drawContext, drawStyle, fillExpansions, path.convex, fw)\n        }\n    }\n\n//    fun drawPolygons(drawContext: DrawContext,\n//                     drawStyle: DrawStyle,\n//                     loops: List<List<List<Vector2>>>,\n//                     corners: List<List<List<Boolean>>>,\n//                     fringeWidth: Double = 1.0) {\n//\n//        val fw = if (drawStyle.smooth) fringeWidth / 2.0 else 0.0\n//        if (drawStyle.fill != null) {\n//            val paths =\n//                    loops.mapIndexed { loopIndex, loop ->\n//                        Path.fromLineLoops(loop.mapIndexed { index, it ->\n//                            it.let { it.subList(0, it.size) }\n//                                .let { if (index == 0) it else it.reversed() }\n//                        }, corners[loopIndex])\n//                    }\n//            val fillExpansions = paths.flatMap { path -> path.expandFill(fw, 0.25, drawStyle.lineJoin, 2.4) }\n//            expansionDrawer.renderFills(drawContext, drawStyle, fillExpansions, fw)\n//        }\n//    }\n\n}\n","package org.openrndr.internal\n\nimport org.openrndr.draw.*\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.Vector3\nimport org.openrndr.platform.Platform\nimport org.openrndr.platform.PlatformType\nimport org.openrndr.shape.Rectangle\nimport kotlin.math.abs\nimport kotlin.math.min\n\nclass RectangleDrawer {\n    private val vertices: VertexBuffer = VertexBuffer.createDynamic(VertexFormat().apply {\n        position(3)\n        normal(3)\n        textureCoordinate(2)\n    }, 6, Session.root)\n\n    private var count = 0\n\n    private val singleBatches = (0 until DrawerConfiguration.vertexBufferMultiBufferCount).map { RectangleBatch.create(1) }\n\n    internal var batch = RectangleBatch.create(10_000, Session.root)\n\n    private val shaderManager: ShadeStyleManager = ShadeStyleManager.fromGenerators(\"rectangle\",\n            vsGenerator = Driver.instance.shaderGenerators::rectangleVertexShader,\n            fsGenerator = Driver.instance.shaderGenerators::rectangleFragmentShader)\n\n    init {\n        val w = vertices.shadow.writer()\n\n        w.rewind()\n        val x = 0.0\n        val y = 0.0\n        val radius = 1.0\n        val pa = Vector3(x, y, 0.0)\n        val pb = Vector3(x + radius, y, 0.0)\n        val pc = Vector3(x + radius, y + radius, 0.0)\n        val pd = Vector3(x, y + radius, 0.0)\n\n        val ta = Vector2(0.0, 0.0)\n        val tb = Vector2(1.0, 0.0)\n        val tc = Vector2(1.0, 1.0)\n        val td = Vector2(0.0, 1.0)\n\n        val n = Vector3(0.0, 0.0, -1.0)\n        w.apply {\n            write(pa); write(n); write(ta)\n            write(pd); write(n); write(td)\n            write(pc); write(n); write(tc)\n\n            write(pc); write(n); write(tc)\n            write(pb); write(n); write(tb)\n            write(pa); write(n); write(ta)\n        }\n        vertices.shadow.upload()\n    }\n\n    internal fun ensureBatchSize(size: Int) {\n        if (batch.size < size) {\n            batch.destroy()\n            batch = RectangleBatch.create(size, Session.root)\n        }\n    }\n\n    fun drawRectangles(drawContext: DrawContext, drawStyle: DrawStyle, positions: List<Vector2>, dimensions: List<Vector2>) {\n        ensureBatchSize(positions.size)\n        require(positions.size == dimensions.size) {\n            \"`positions.size` and `dimensions.size` must be equal in drawRectangles()\"\n        }\n        batch.geometry.put {\n            dimensions.forEachIndexed { i, sz ->\n                write(Vector3(\n                        positions[i].x + min(0.0, sz.x),\n                        positions[i].y + min(0.0, sz.y), 0.0))\n                write(Vector3(abs(sz.x), abs(sz.y), 0.0))\n\n            }\n        }\n        batch.drawStyle.put {\n            for (i in positions.indices) {\n                write(drawStyle)\n            }\n        }\n        drawRectangles(drawContext, drawStyle, batch, positions.size)\n    }\n\n    fun drawRectangles(drawContext: DrawContext, drawStyle: DrawStyle, positions: List<Vector2>, width: Double, height: Double) {\n        ensureBatchSize(positions.size)\n        batch.geometry.put {\n            positions.forEach {\n                write(Vector3(\n                        it.x + min(0.0, width),\n                        it.y + min(0.0, height), 0.0))\n                write(Vector3(abs(width), abs(height), 0.0))\n            }\n        }\n        batch.drawStyle.put {\n            for (i in positions.indices) {\n                write(drawStyle)\n            }\n        }\n        drawRectangles(drawContext, drawStyle, batch, positions.size)\n    }\n\n    fun drawRectangles(drawContext: DrawContext, drawStyle: DrawStyle, rectangles: List<Rectangle>) {\n        ensureBatchSize(rectangles.size)\n        batch.geometry.put {\n            rectangles.forEach {\n                write(Vector3(\n                        it.x + min(0.0, it.width),\n                        it.y + min(0.0, it.height), 0.0))\n                write(Vector3(abs(it.width), abs(it.height), 0.0))\n            }\n        }\n        batch.drawStyle.put {\n            for (i in rectangles.indices) {\n                write(drawStyle)\n            }\n        }\n        drawRectangles(drawContext, drawStyle, batch, rectangles.size)\n    }\n\n    fun drawRectangle(drawContext: DrawContext,\n                      drawStyle: DrawStyle, x: Double, y: Double, width: Double, height: Double) {\n        ensureBatchSize(1)\n\n        val batch = singleBatches[count.mod(singleBatches.size)]\n\n        batch.geometry.put {\n            write(\n                (x + min(0.0, width)).toFloat(),\n                (y + min(0.0, height)).toFloat(), 0.0f)\n            write(abs(width).toFloat(), abs(height).toFloat(), 0.0f)\n        }\n        batch.drawStyle.put {\n            write(drawStyle)\n        }\n        drawRectangles(drawContext, drawStyle, batch, 1)\n        count++\n    }\n\n    fun drawRectangles(drawContext: DrawContext, drawStyle: DrawStyle, batch: RectangleBatch, count: Int) {\n        val shader = shaderManager.shader(drawStyle.shadeStyle, listOf(vertices.vertexFormat), listOf(batch.geometry.vertexFormat, batch.drawStyle.vertexFormat))\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawInstances(shader, listOf(vertices), listOf(batch.drawStyle, batch.geometry) + (drawStyle.shadeStyle?.attributes\n                ?: emptyList()), DrawPrimitive.TRIANGLES, 0, 6, 0, count)\n        shader.end()\n    }\n}","package org.openrndr.internal\n\nimport org.openrndr.draw.*\n\nclass VertexBufferDrawer {\n\n    private val shaderManager: ShadeStyleManager = ShadeStyleManager.fromGenerators(\"vertex-buffer\",\n            vsGenerator = Driver.instance.shaderGenerators::vertexBufferVertexShader,\n            fsGenerator = Driver.instance.shaderGenerators::vertexBufferFragmentShader)\n\n    fun drawVertexBuffer(drawContext: DrawContext, drawStyle: DrawStyle, primitive: DrawPrimitive, vertexBuffers:List<VertexBuffer>, offset:Int, vertexCount:Int) {\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertexBuffers.map { it.vertexFormat })\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawVertexBuffer(shader, vertexBuffers, primitive, offset, vertexCount)\n        shader.end()\n    }\n\n    fun drawVertexBuffer(drawContext: DrawContext, drawStyle: DrawStyle, primitive: DrawPrimitive, indexBuffer: IndexBuffer, vertexBuffers:List<VertexBuffer>, offset:Int, indexCount:Int) {\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertexBuffers.map { it.vertexFormat })\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawIndexedVertexBuffer(shader, indexBuffer, vertexBuffers, primitive, offset, indexCount)\n        shader.end()\n    }\n\n    fun drawVertexBufferInstances(drawContext: DrawContext, drawStyle: DrawStyle, primitive: DrawPrimitive, vertexBuffers:List<VertexBuffer>, instanceAttributes:List<VertexBuffer>,  offset:Int, vertexCount:Int, instanceCount:Int) {\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertexBuffers.map { it.vertexFormat }, instanceAttributes.map { it.vertexFormat })\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawInstances(shader, vertexBuffers, instanceAttributes + (drawStyle.shadeStyle?.attributes?: emptyList()), primitive, offset, vertexCount, 0, instanceCount)\n        shader.end()\n    }\n\n\n    fun drawVertexBufferInstances(drawContext: DrawContext, drawStyle: DrawStyle, primitive: DrawPrimitive, indexBuffer: IndexBuffer, vertexBuffers:List<VertexBuffer>, instanceAttributes:List<VertexBuffer>,  offset:Int, indexCount:Int, instanceCount:Int) {\n        val shader = shaderManager.shader(drawStyle.shadeStyle, vertexBuffers.map { it.vertexFormat }, instanceAttributes.map { it.vertexFormat })\n        shader.begin()\n        drawContext.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawIndexedInstances(shader, indexBuffer, vertexBuffers, instanceAttributes + (drawStyle.shadeStyle?.attributes?: emptyList()), primitive, offset, indexCount, 0, instanceCount)\n        shader.end()\n    }\n}","package org.openrndr.draw\n\nactual val defaultFontMap: FontImageMap? by lazy {\n    null\n}\n","package org.openrndr.draw\n\n/**\n * A collection of granules, or template functions for writing stylable shaders in GLSL. ShadeStyleGLSL\n * is used in OPENRNDR's shader generators but is exposed to the user such that they too can write shader generators.\n */\nactual class ShadeStyleGLSL {\n    actual companion object {\n        /**\n         * This granule is used inside the main() function of fragment shaders to set up\n         * constants that are part of the shade style language.\n         * It sets up:\n         * - c_instance\n         * - c_element\n         * - c_screenPosition\n         * - c_contourPosition\n         * - c_boundsPosition\n         * - c_boundsSize\n         */\n        actual fun fragmentMainConstants(\n            instance: String,\n            element: String,\n            screenPosition: String,\n            contourPosition: String,\n            boundsPosition: String,\n            boundsSize: String\n        ) = \"\"\"\n        |    // -- fragmentConstants\n        |    #define c_instance ($instance)\n        |    #define c_element ($element)\n        |    #define c_screenPosition ($screenPosition)\n        |    #define c_contourPosition ($contourPosition)\n        |    #define c_boundsPosition ($boundsPosition)\n        |    #define c_boundsSize ($boundsSize)\"\"\".trimMargin()\n\n\n        /**\n         * This granule is used inside the main() function of vertex shaders to set up\n         * constants that are part of the shade style language.\n         */\n        actual fun vertexMainConstants(\n            instance: String,\n            element: String\n        ) = \"\"\"\n        |#define c_instance $instance\n        |int c_element = $element;\"\"\".trimMargin()\n\n        /**\n         * This granule is used in the preamble of a fragment shader. It sets up the declarations of\n         * in-varyings holding transformations of position and normal.\n         */\n        actual val transformVaryingIn = \"\"\"\n            // <transform-varying-in> (ShadeStyleGLSL.kt)\n            in vec3 v_worldNormal;\n            in vec3 v_viewNormal;\n            in vec3 v_worldPosition;\n            in vec3 v_viewPosition;\n            in vec4 v_clipPosition;\n            in mat4 v_modelNormalMatrix;\n            // </transform-varying-in>\"\"\".trimIndent()\n\n        /**\n         * This granule is used in the preamble of a vertex shader. It sets up the declarations of\n         * out-varyings holding transformations of position and normal.\n         */\n        actual val transformVaryingOut = \"\"\"\n            // <transform-varying-out> (ShadeStyleGLSL.kt)\n            out vec3 v_worldNormal;\n            out vec3 v_viewNormal;\n            out vec3 v_worldPosition;\n            out vec3 v_viewPosition;\n            out vec4 v_clipPosition;\n            \n            out mat4 v_modelNormalMatrix;\n            // </transform-varying-out>\"\"\".trimIndent()\n\n        /**\n         * This granule is used in the main function of a vertex shader. It sets up declarations\n         * of transformable variables in the shade style language. It is used right before [ShadeStructure.vertexTransform]\n         * is inserted into the shader template.\n         */\n        actual val preVertexTransform = \"\"\"\n            // <pre-Transform> (ShadeStyleGLSL.kt)\n            mat4 x_modelMatrix = u_modelMatrix;\n            mat4 x_viewMatrix = u_viewMatrix;\n            mat4 x_modelNormalMatrix = u_modelNormalMatrix;\n            mat4 x_viewNormalMatrix = u_viewNormalMatrix;\n            mat4 x_projectionMatrix = u_projectionMatrix;\n            // </pre-transform>\"\"\".trimIndent()\n\n        /**\n         * This granule is used in the main function of a vertex shader. It assigns values\n         * to out-varyings declared in [transformVaryingOut]. It is used right after [ShadeStructure.vertexTransform]\n         * is inserted into the shader template.\n         */\n        actual val postVertexTransform = \"\"\"\n            // <post-transform> (ShadeStyleGLSL.kt)\n            v_worldNormal = (x_modelNormalMatrix * vec4(x_normal,0.0)).xyz;\n            v_viewNormal = (x_viewNormalMatrix * vec4(v_worldNormal,0.0)).xyz;\n            v_worldPosition = (x_modelMatrix * vec4(x_position, 1.0)).xyz;\n            v_viewPosition = (x_viewMatrix * vec4(v_worldPosition, 1.0)).xyz;\n            v_clipPosition = x_projectionMatrix * vec4(v_viewPosition, 1.0);\n            v_modelNormalMatrix = x_modelNormalMatrix;\n            // </post-transform>\"\"\".trimIndent()\n\n        /**\n         * This granule is to set up definitions for primitive types.\n         * @param type type of the primitive, users would pass in \"d_custom\"\n         */\n        actual fun primitiveTypes(type: String) = \"\"\"\n            // <primitive-types> (ShadeStyleGLSL.kt)\n            #define d_vertex_buffer 0\n            #define d_image 1\n            #define d_circle 2\n            #define d_rectangle 3\n            #define d_font_image_map 4\n            #define d_expansion 5\n            #define d_fast_line 6\n            #define d_mesh_line 7\n            #define d_point 8\n            #define d_custom 9\n            #define d_primitive $type\n            // </primitive-types>\n            \"\"\".trimIndent()\n\n\n        /**\n         * This granule is used to set up [Drawer] uniform declarations. It declares uniforms for\n         * transformations and [DrawStyle]. This is used in fragment and vertex shaders.\n         */\n        actual fun drawerUniforms(contextBlock: Boolean, styleBlock: Boolean) = \"\"\"\n            |// <drawer-uniforms($contextBlock, $styleBlock)> (ShadeStyleGLSL.kt)\n            ${contextBlock.trueOrEmpty {\n            \"\"\"\n                |    uniform highp mat4 u_modelNormalMatrix;\n                |    uniform highp mat4 u_modelMatrix;\n                |    uniform highp mat4 u_viewNormalMatrix;\n                |    uniform highp mat4 u_viewMatrix;\n                |    uniform highp mat4 u_projectionMatrix;\n                |    uniform highp float u_contentScale;\n                |    uniform highp float u_modelViewScalingFactor;\n                |    uniform highp vec2 u_viewDimensions;\n                |\"\"\"\n            }\n        }\n            ${styleBlock.trueOrEmpty {\n            \"\"\"\n                |    uniform highp vec4 u_fill;\n                |    uniform highp vec4 u_stroke;\n                |    uniform highp float u_strokeWeight;\n                |    uniform highp float u_colorMatrix[25];\"\"\"\n            }\n        }\n            |// </drawer-uniforms>\n            \"\"\".trimMargin()\n    }\n}\n\nprivate fun Boolean.trueOrEmpty(f: () -> String): String {\n    return if (this) f() else \"\"\n}\n","package org.openrndr.draw\n\nimport org.khronos.webgl.Float32Array\nimport org.openrndr.internal.Driver\nimport org.openrndr.utils.buffer.MPPBuffer\n\nactual abstract class VertexBuffer {\n    actual abstract val session: Session?\n    actual abstract val vertexFormat: VertexFormat\n    actual abstract val vertexCount: Int\n\n    /**\n     * Gives a read/write shadow for the vertex buffer\n     */\n    actual abstract val shadow: VertexBufferShadow\n\n    /**\n     * Destroy the vertex buffer\n     */\n    actual abstract fun destroy()\n    actual fun put(elementOffset: Int, putter: BufferWriter.() -> Unit): Int {\n        val w = shadow.writer()\n        w.positionElements = elementOffset\n        w.putter()\n        // *4 is because the underlying buffer is 4-byte floats\n        if (w.position*4 % vertexFormat.size != 0) {\n            throw RuntimeException(\"incomplete vertices written at ${w.position}. likely violating the specified vertex format $vertexFormat\")\n        }\n        val count = w.positionElements - elementOffset\n        shadow.uploadElements(elementOffset, count)\n        return count\n    }\n\n    actual companion object {\n        actual fun createDynamic(\n            format: VertexFormat,\n            vertexCount: Int,\n            session: Session?\n        ): VertexBuffer {\n            return Driver.instance.createDynamicVertexBuffer(format, vertexCount, session)\n        }\n\n        actual fun createFromFloats(\n            format: VertexFormat,\n            data: FloatArray,\n            session: Session?\n        ): VertexBuffer {\n            TODO(\"Not yet implemented\")\n        }\n    }\n\n    abstract fun write(data: FloatArray, offsetBytes:Int, floatCount: Int)\n    abstract fun write(data: Float32Array, offsetBytes:Int, floatCount : Int)\n    actual abstract fun write(\n        source: MPPBuffer,\n        targetByteOffset: Int,\n        sourceByteOffset: Int,\n        byteLength: Int\n    )\n\n}","package org.openrndr.internal\n\nimport org.openrndr.draw.*\n\n/**\n * Driver interface. This is the internal interface\n */\nactual interface Driver {\n\n    //    fun createColorBufferFromStream(\n//        stream: InputStream,\n//        name: String? = null,\n//        formatHint: ImageFileFormat? = null,\n//        session: Session? = Session.active\n//    ): ColorBuffer\n\n    //    fun createColorBufferFromBuffer(\n//        buffer: ByteBuffer,\n//        name: String? = null,\n//        formatHint: ImageFileFormat? = null,\n//        session: Session? = Session.active\n//    ): ColorBuffer\n\n    //    fun createResourceThread(session: Session? = Session.active, f: () -> Unit): ResourceThread\n//    fun createDrawThread(session: Session? = Session.active): DrawThread\n\n    //    fun clear(color: ColorRGBa) {\n//        clear(color.r, color.g, color.b, color.a)\n//    }\n\n    //    fun createStaticVertexBuffer(format: VertexFormat, buffer: Buffer, session: Session? = Session.active): VertexBuffer\n    actual val contextID: Long\n\n    /**\n     * Create a shader from code\n     * @param vsCode vertex shader code\n     * @param gsCode optional geometry shader code\n     * @param fsCode fragment shader code\n     */\n    actual fun createShader(\n        vsCode: String,\n        tcsCode: String?,\n        tesCode: String?,\n        gsCode: String?,\n        fsCode: String,\n        name: String,\n        session: Session?\n    ): Shader\n\n    actual fun createComputeShader(\n        code: String,\n        name: String,\n        session: Session?\n    ): ComputeShader\n\n    actual fun createShadeStyleManager(\n        name: String,\n        vsGenerator: (ShadeStructure) -> String,\n        tcsGenerator: ((ShadeStructure) -> String)?,\n        tesGenerator: ((ShadeStructure) -> String)?,\n        gsGenerator: ((ShadeStructure) -> String)?,\n        fsGenerator: (ShadeStructure) -> String,\n        session: Session?\n    ): ShadeStyleManager\n\n    actual fun createRenderTarget(\n        width: Int,\n        height: Int,\n        contentScale: Double,\n        multisample: BufferMultisample,\n        session: Session?\n    ): RenderTarget\n\n    actual fun createArrayCubemap(\n        width: Int,\n        layers: Int,\n        format: ColorFormat,\n        type: ColorType,\n        levels: Int,\n        session: Session?\n    ): ArrayCubemap\n\n    actual fun createArrayTexture(\n        width: Int,\n        height: Int,\n        layers: Int,\n        format: ColorFormat,\n        type: ColorType,\n        levels: Int,\n        session: Session?\n    ): ArrayTexture\n\n    actual fun createAtomicCounterBuffer(\n        counterCount: Int,\n        session: Session?\n    ): AtomicCounterBuffer\n\n    actual fun createColorBuffer(\n        width: Int,\n        height: Int,\n        contentScale: Double,\n        format: ColorFormat,\n        type: ColorType,\n        multisample: BufferMultisample,\n        levels: Int,\n        session: Session?\n    ): ColorBuffer\n\n    actual fun createDepthBuffer(\n        width: Int,\n        height: Int,\n        format: DepthFormat,\n        multisample: BufferMultisample,\n        session: Session?\n    ): DepthBuffer\n\n    actual fun createBufferTexture(\n        elementCount: Int,\n        format: ColorFormat,\n        type: ColorType,\n        session: Session?\n    ): BufferTexture\n\n    actual fun createCubemap(\n        width: Int,\n        format: ColorFormat,\n        type: ColorType,\n        levels: Int,\n        session: Session?\n    ): Cubemap\n\n    actual fun createVolumeTexture(\n        width: Int,\n        height: Int,\n        depth: Int,\n        format: ColorFormat,\n        type: ColorType,\n        levels: Int,\n        session: Session?\n    ): VolumeTexture\n\n    actual fun clear(r: Double, g: Double, b: Double, a: Double)\n    actual fun createDynamicVertexBuffer(\n        format: VertexFormat,\n        vertexCount: Int,\n        session: Session?\n    ): VertexBuffer\n\n    actual fun createDynamicIndexBuffer(\n        elementCount: Int,\n        type: IndexType,\n        session: Session?\n    ): IndexBuffer\n\n    actual fun createShaderStorageBuffer(\n        format: ShaderStorageFormat,\n        session: Session?\n    ): ShaderStorageBuffer\n\n    actual fun drawVertexBuffer(\n        shader: Shader,\n        vertexBuffers: List<VertexBuffer>,\n        drawPrimitive: DrawPrimitive,\n        vertexOffset: Int,\n        vertexCount: Int,\n        verticesPerPatch: Int\n    )\n\n    actual fun drawIndexedVertexBuffer(\n        shader: Shader,\n        indexBuffer: IndexBuffer,\n        vertexBuffers: List<VertexBuffer>,\n        drawPrimitive: DrawPrimitive,\n        indexOffset: Int,\n        indexCount: Int,\n        verticesPerPatch: Int\n    )\n\n    actual fun drawInstances(\n        shader: Shader,\n        vertexBuffers: List<VertexBuffer>,\n        instanceAttributes: List<VertexBuffer>,\n        drawPrimitive: DrawPrimitive,\n        vertexOffset: Int,\n        vertexCount: Int,\n        instanceOffset: Int,\n        instanceCount: Int,\n        verticesPerPatch: Int\n    )\n\n    actual fun drawIndexedInstances(\n        shader: Shader,\n        indexBuffer: IndexBuffer,\n        vertexBuffers: List<VertexBuffer>,\n        instanceAttributes: List<VertexBuffer>,\n        drawPrimitive: DrawPrimitive,\n        indexOffset: Int,\n        indexCount: Int,\n        instanceOffset: Int,\n        instanceCount: Int,\n        verticesPerPatch: Int\n    )\n\n    actual fun setState(drawStyle: DrawStyle)\n    actual fun destroyContext(context: Long)\n    actual val fontImageMapManager: FontMapManager\n    actual val fontVectorMapManager: FontMapManager\n    actual val shaderGenerators: ShaderGenerators\n    actual val activeRenderTarget: RenderTarget\n\n    /**\n     * waits for all drawing to complete\n     */\n    actual fun finish()\n    actual fun internalShaderResource(resourceId: String): String\n\n    actual fun shaderConfiguration(): String\n\n    actual companion object {\n        actual var driver: Driver? = null\n        actual val instance: Driver\n            get() {\n                return driver ?: error(\"no active driver\")\n            }\n    }\n\n    actual val shaderLanguage: ShaderLanguage\n    actual fun createComputeStyleManager(session: Session?): ComputeStyleManager\n    actual val properties: DriverProperties\n\n\n}","package org.openrndr.draw\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.internal.Driver\nimport org.openrndr.math.*\n\n\nenum class ShaderType {\n    VERTEX,\n    GEOMETRY,\n    FRAGMENT\n}\n\ninterface Shader : ShaderImageBindings, ShaderUniforms, ShaderBufferBindings {\n    val session: Session?\n    val types: Set<ShaderType>\n\n    @Suppress(\"unused\")\n    companion object {\n        fun createFromCode(\n            vsCode: String,\n            tcsCode: String? = null,\n            tesCode: String? = null,\n            gsCode: String? = null,\n            fsCode: String,\n            name: String,\n            session: Session? = Session.active\n        ): Shader {\n            val shader = Driver.instance.createShader(vsCode, tcsCode, tesCode, gsCode, fsCode, name, session)\n            session?.track(shader)\n            return shader\n        }\n    }\n\n    fun begin()\n    fun end()\n\n    fun hasUniform(name: String): Boolean\n\n    fun createBlock(blockName: String): UniformBlock?\n    fun blockLayout(blockName: String): UniformBlockLayout?\n    fun block(blockName: String, block: UniformBlock)\n\n\n\n\n    fun destroy()\n}\n","package org.openrndr.draw\n\nimport org.openrndr.internal.Driver\n\ninterface AtomicCounterBuffer {\n    companion object {\n        fun create(counterCount: Int) = Driver.instance.createAtomicCounterBuffer(counterCount)\n    }\n\n    fun write(data: IntArray)\n    fun read(): IntArray\n\n    /**\n     * Reset all the counters to 0\n     */\n    fun reset()\n\n    fun destroy()\n\n    /**\n     * The number of counters\n     */\n    val size: Int\n}","package org.openrndr.draw\n\nimport org.openrndr.internal.Driver\nimport org.openrndr.math.*\n\ninterface ComputeShader : ShaderImageBindings, ShaderBufferBindings, ShaderUniforms {\n    companion object {\n        /**\n         * Create a compute shader from (GLSL) code as a String\n         */\n        fun fromCode(code: String, name: String): ComputeShader = Driver.instance.createComputeShader(code, name)\n    }\n\n\n    /**\n     * Execute the compute shader\n     * @param width the global width\n     * @param height the global height\n     * @param depth the global depth\n     */\n    fun execute(width: Int = 1, height: Int = 1, depth: Int = 1)\n\n    fun execute(dimensions: IntVector3) = execute(dimensions.x, dimensions.y, dimensions.z)\n\n    /**\n     * Destroy the compute shader\n     */\n    fun destroy()\n\n}","package org.openrndr.draw\n\nactual val useContextBlock: Boolean = false\n","package org.openrndr.draw \n\nactual val useStyleBlock : Boolean = false","package org.openrndr.internal\n\nimport org.openrndr.draw.FontImageMap\n\nabstract class FontMapManager {\n    abstract fun fontMapFromUrl(url:String, size:Double, characterSet: Set<Char>, contentScale:Double=1.0): FontImageMap\n}","package org.openrndr.draw\n\nimport org.openrndr.shape.Rectangle\n\nactual abstract class ArrayTexture {\n    actual abstract val session: Session?\n    actual abstract val width: Int\n    actual abstract val height: Int\n    actual abstract val layers: Int\n    actual abstract val format: ColorFormat\n    actual abstract val type: ColorType\n    actual abstract val levels: Int\n    actual abstract fun destroy()\n    actual abstract fun bind(unit: Int)\n\n    /**\n     * Copy contents in layer to target ColorBuffer\n     * @param layer the layer to copy contents from\n     * @param target the target to copy contents to\n     */\n    actual abstract fun copyTo(\n        layer: Int,\n        target: ColorBuffer,\n        fromLevel: Int,\n        toLevel: Int\n    )\n\n    /**\n     * Copy contents in layer to target ColorBuffer\n     * @param layer the layer to copy contents from\n     * @param target the layer array texture to copy contents to\n     * @param targetLayer the layer of the target array texture to copy contents to\n     */\n    actual abstract fun copyTo(\n        layer: Int,\n        target: ArrayTexture,\n        targetLayer: Int,\n        fromLevel: Int,\n        toLevel: Int\n    )\n\n    /** generates mipmaps from the top-level mipmap */\n    actual abstract fun generateMipmaps()\n\n    /** the wrapping mode to use in the horizontal direction */\n    actual abstract var wrapU: WrapMode\n\n    /** the wrapping mode to use in the vertical direction */\n    actual abstract var wrapV: WrapMode\n\n    /** the filter to use when displaying at sizes smaller than the original */\n    actual abstract var filterMin: MinifyingFilter\n\n    /** the filter to use when displaying at sizes larger than the original */\n    actual abstract var filterMag: MagnifyingFilter\n    actual abstract var flipV: Boolean\n    actual val bounds: Rectangle\n        get() = TODO(\"Not yet implemented\")\n\n\n}","package org.openrndr.draw\n\nactual abstract class BufferTextureShadow {\n    actual abstract val bufferTexture: BufferTexture\n    actual abstract fun upload(offset: Int, sizeInBytes: Int)\n    actual abstract fun download()\n    actual abstract fun destroy()\n\n}","package org.openrndr.draw\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.math.*\n\nactual abstract class BufferWriter {\n    actual abstract fun write(vararg v: Vector3)\n    actual abstract fun write(v: Byte)\n    actual abstract fun write(v: Short)\n    actual abstract fun write(v: Vector3)\n    actual abstract fun write(v: Vector2)\n    actual abstract fun write(v: Vector4)\n    actual abstract fun write(v: Int)\n    actual abstract fun write(v: IntVector2)\n    actual abstract fun write(v: IntVector3)\n    actual abstract fun write(v: IntVector4)\n    actual abstract fun write(v: Matrix33)\n    actual abstract fun write(v: Matrix44)\n    actual abstract fun write(v: Float)\n    actual abstract fun write(x: Float, y: Float)\n    actual abstract fun write(x: Float, y: Float, z: Float)\n    actual abstract fun write(x: Float, y: Float, z: Float, w: Float)\n    actual abstract fun write(v: ColorRGBa)\n    actual abstract fun write(a: FloatArray, offset: Int, size: Int)\n\n    /**\n     * rewind the underlying buffer\n     */\n    actual abstract fun rewind()\n\n    /**\n     * Set the raw position of the underlying buffer, in 4-byte strides\n     */\n    actual abstract var position: Int\n\n    /**\n     * Set the position of the underlying buffer to accommodate the given number of elements\n     * according to the format size\n     */\n    actual abstract var positionElements: Int\n}","package org.openrndr.draw\n\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\nimport org.khronos.webgl.ArrayBufferView\nimport org.khronos.webgl.TexImageSource\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.internal.Driver\nimport org.openrndr.internal.ImageDriver\nimport org.openrndr.shape.IntRectangle\nimport org.openrndr.shape.Rectangle\nimport org.openrndr.utils.buffer.MPPBuffer\nimport org.w3c.dom.CanvasRenderingContext2D\n\nactual abstract class ColorBuffer {\n\n\n    /**\n     * write the contents from [sourceBuffer] to the [ColorBuffer], potentially with format and type conversions\n     *\n     * The [sourceBuffer] should be allocated using [ByteBuffer.allocateDirect] and have an amount of remaining bytes\n     * that matches with the dimensions, [sourceFormat] and [sourceType].\n     * @param sourceBuffer a [ByteBuffer] holding raw image data\n     * @param sourceFormat the [ColorFormat] that is used for the image data stored in [sourceBuffer], default is [ColorBuffer.format]\n     * @param sourceType the [ColorType] that is used for the image data stored in [sourceBuffer], default is [ColorBuffer.type]\n     * @param level the mipmap-level of [ColorBuffer] to write to\n     */\n    actual abstract val session: Session?\n\n    /** the width of the [ColorBuffer] in device units */\n    actual abstract val width: Int\n\n    /** the height of the [ColorBuffer] in device units */\n    actual abstract val height: Int\n\n    /** the content scale of the [ColorBuffer] */\n    actual abstract val contentScale: Double\n\n    /**\n     * the [ColorFormat] of the image stored in the [ColorBuffer]\n     */\n    actual abstract val format: ColorFormat\n\n    /**\n     * the [ColorType] of the image stored in the [ColorBuffer]\n     */\n    actual abstract val type: ColorType\n\n    /** the number of mipmap levels */\n    actual abstract val levels: Int\n\n    /** the multisampling method used for this [ColorBuffer] */\n    actual abstract val multisample: BufferMultisample\n\n    /** the width of the [ColorBuffer] in pixels */\n    actual val effectiveWidth: Int\n        get() = (width * contentScale).toInt()\n\n    /** the height of the [ColorBuffer] in pixels */\n    actual val effectiveHeight: Int\n        get() = (height * contentScale).toInt()\n\n    actual val bounds: Rectangle\n        get() = Rectangle(0.0, 0.0, width.toDouble(), height.toDouble())\n\n    /** permanently destroy the underlying [ColorBuffer] resources, [ColorBuffer] can not be used after it is destroyed */\n    actual abstract fun destroy()\n\n    /** bind the colorbuffer to a texture unit, internal API */\n    actual abstract fun bind(unit: Int)\n\n    /** generates mipmaps from the top-level mipmap */\n    actual abstract fun generateMipmaps()\n\n    /** the (unitless?) degree of anisotropy to be used in filtering */\n    actual abstract var anisotropy: Double\n\n    /**\n     * should the v coordinate be flipped because the [ColorBuffer] contents are stored upside-down?\n     */\n    actual abstract var flipV: Boolean\n    actual abstract fun copyTo(\n        target: ColorBuffer,\n        fromLevel: Int,\n        toLevel: Int,\n        sourceRectangle: IntRectangle,\n        targetRectangle: IntRectangle,\n        filter: MagnifyingFilter\n    )\n\n    actual abstract fun copyTo(\n        target: ColorBuffer,\n        fromLevel: Int,\n        toLevel: Int,\n        filter: MagnifyingFilter\n    )\n\n    /**\n     * copies contents to a target array texture\n     * @param target the color buffer to which contents will be copied\n     * @param layer the array layer from which will be copied\n     * @param fromLevel the mip-map level from which will be copied\n     * @param toLevel the mip-map level of [target] to which will be copied\n     */\n    actual abstract fun copyTo(\n        target: ArrayTexture,\n        layer: Int,\n        fromLevel: Int,\n        toLevel: Int\n    )\n\n    abstract fun write(\n        source: TexImageSource,\n        x: Int = 0,\n        y: Int = 0,\n        width: Int = this.effectiveWidth,\n        height: Int = this.effectiveHeight,\n        level: Int = 0\n    )\n\n    abstract fun write(\n        source: ArrayBufferView,\n        sourceFormat: ColorFormat,\n        sourceType: ColorType,\n        x: Int = 0,\n        y: Int = 0,\n        width: Int = this.effectiveWidth,\n        height: Int = this.effectiveHeight,\n        level: Int = 0\n    )\n\n    abstract fun read(\n        target: ArrayBufferView,\n        x: Int,\n        y: Int,\n        width: Int = this.effectiveWidth,\n        height: Int = this.effectiveHeight,\n        level: Int = 0\n    )\n\n    actual abstract fun write(\n        sourceBuffer: MPPBuffer,\n        sourceFormat: ColorFormat,\n        sourceType: ColorType,\n        x: Int,\n        y: Int,\n        width: Int,\n        height: Int,\n        level: Int\n    )\n\n    actual abstract fun filter(\n        filterMin: MinifyingFilter,\n        filterMag: MagnifyingFilter\n    )\n\n    /** the wrapping mode to use in the horizontal direction */\n    actual abstract var wrapU: WrapMode\n\n    /** the wrapping mode to use in the vertical direction */\n    actual abstract var wrapV: WrapMode\n\n    /**\n     * sets all pixels in the color buffer to [color]\n     * @param color the color used for filling\n     */\n    actual abstract fun fill(color: ColorRGBa)\n\n}\n\n/**\n * load an image from a file or url encoded as [String], also accepts base64 encoded data urls\n */\nactual fun loadImage(\n    fileOrUrl: String,\n    formatHint: ImageFileFormat?,\n    session: Session?\n): ColorBuffer {\n    val data = ImageDriver.instance.loadImage(fileOrUrl, formatHint)\n    return try {\n        val cb = colorBuffer(\n            data.width,\n            data.height,\n            1.0,\n            data.format,\n            data.type,\n            BufferMultisample.Disabled,\n            data.mipmapData.size + 1,\n            session\n        )\n\n        cb\n    } finally {\n        data.close()\n    }\n}\n\nactual suspend fun loadImageSuspend(\n    fileOrUrl: String,\n    formatHint: ImageFileFormat?,\n    session: Session?\n): ColorBuffer {\n    return loadImage(fileOrUrl, formatHint, session)\n}","package org.openrndr.draw\n\nactual interface IndexBuffer {\n    actual companion object {\n        actual fun createDynamic(\n            elementCount: Int,\n            type: IndexType\n        ): IndexBuffer {\n            TODO(\"Not yet implemented\")\n        }\n    }\n\n    actual val indexCount: Int\n    actual val type: IndexType\n    actual fun destroy()\n\n}","package org.openrndr.draw\n\nactual class ShaderWatcher {\n    actual val shader: Shader?\n        get() = TODO(\"Not yet implemented\")\n}","package org.openrndr.events\n\nimport io.github.oshai.kotlinlogging.KotlinLogging\n\n\nprivate val logger = KotlinLogging.logger {}\n\nactual class Event<T> actual constructor(val name: String, val postpone: Boolean) {\n    actual val listeners: MutableList<(T) -> Unit> = mutableListOf()\n    private val oneShotListeners: MutableList<(T) -> Unit> = mutableListOf()\n    private val messages = mutableListOf<T>()\n\n    actual fun trigger(message: T) {\n        messages.add(message)\n        deliver()\n    }\n\n    actual fun deliver() {\n        run {\n            if (messages.size > 0) {\n                val copy = mutableListOf<T>()\n                copy.addAll(messages)\n                messages.clear()\n\n                copy.forEach { m ->\n                    this.listeners.forEach { l ->\n                        try {\n                            l(m)\n                        } catch (e: Exception) {\n                            logger.error { \"Exception thrown in listener ('${name}'): ${e::class.simpleName}; '${e.message}'\" }\n                            throw e\n                        }\n                    }\n                    this.oneShotListeners.forEach { l ->\n                        try {\n                            l(m)\n                        } catch (e: Exception) {\n                            logger.error { \"Exception thrown in one-shot listener ('${name}'): ${e::class.simpleName}; '${e.message}'\" }\n                            throw e\n                        }\n                    }\n                    this.oneShotListeners.clear()\n                }\n            }\n        }\n    }\n\n    /**\n     * add an event message listener\n     * @param listener a function to be invoked when an event message is received\n     * @return the [listener] that was passed in\n     */\n    actual fun listen(listener: (T) -> Unit): (T) -> Unit {\n        listeners.add(listener)\n        return listener\n    }\n\n    actual fun listen(listener: Event<T>): (T) -> Unit {\n        val listenFunction = { m: T -> listener.trigger(m) }\n        listeners.add(listenFunction)\n        return listenFunction\n    }\n\n    /**\n     * cancel a listener\n     */\n    actual fun cancel(listener: (T) -> Unit) {\n        listeners.remove(listener)\n    }\n\n    actual fun listenOnce(listener: (T) -> Unit) {\n        oneShotListeners.add(listener)\n    }\n\n    actual fun listenOnce(listener: Event<T>) {\n        oneShotListeners.add { v1 -> listener.trigger(v1) }\n    }\n\n}\n","package org.openrndr.kartifex\n\nimport org.openrndr.kartifex.utils.Intersections\n\ninterface Curve2 {\n    /**\n     * @param t a parametric point on the curve, not necessarily within [0, 1]\n     * @return the interpolated position on the curve\n     */\n    fun position(t: Double): Vec2\n\n    /**\n     * Given a ring of curves, the sum of area() will be the are enclosed by that ring. For clockwise rings, the sum will\n     * be negative, for counter-clockwise rings it will be positive.\n     *\n     * @return the signed area of the curve\n     */\n    fun signedArea(): Double\n    fun length(): Double\n    fun start() = position(0.0)\n\n    fun end() = position(1.0)\n\n    /**\n     * @return an updated curve with the specified endpoints.\n     */\n    fun endpoints(start: Vec2, end: Vec2): Curve2\n\n    /**\n     * @param t a parametric point on the curve, not necessarily within [0, 1]\n     * @return the tangent at the interpolated position on the curve, which is not normalized\n     */\n    fun direction(t: Double): Vec2\n\n    /**\n     * @param t a parametric point within the curve, which must be within (0, 1)\n     * @return an array representing the lower and upper regions of the curve, split at `t`\n     */\n    fun split(t: Double): Array<Curve2>\n    fun isFlat(epsilon: Double): Boolean\n\n    /**\n     * @param interval the parametric range\n     * @return the curve within [interval.lo, interval.hi]\n     */\n    fun range(interval: Interval) = range(interval.lo, interval.hi)\n\n    /**\n     * @param tMin the lower parametric bound\n     * @param tMax the upper parametric bound\n     * @return the curve within [tMin, tMax]\n     */\n    fun range(tMin: Double, tMax: Double): Curve2 {\n        require(tMin != tMax) { \"range must be non-zero\" }\n        require(tMax >= tMin) { \"tMin must be less than tMax\" }\n\n        return when {\n            tMin == 0.0 && tMax == 1.0 -> this\n            tMin == 0.0 -> split(tMax)[0]\n            tMax == 1.0 -> split(tMin)[1]\n            else -> split(tMin)[1].split((tMax - tMin) / (1 - tMin))[0].endpoints(position(tMin), position(tMax))\n        }\n    }\n\n    /**\n     * @param unsafeTs an array of parametric split points\n     * @return an array of curves, split at the specified points.\n     */\n    fun split(unsafeTs: DoubleArray): Array<Curve2> {\n        var previous = Double.POSITIVE_INFINITY\n        var tCount = 0\n        for (i in unsafeTs.indices) {\n            if (unsafeTs[i] != previous) {\n                tCount++\n            }\n            previous = unsafeTs[i]\n        }\n        var ts = DoubleArray(tCount)\n        tCount = 0\n        previous = Double.POSITIVE_INFINITY\n        for (i in unsafeTs.indices) {\n            if (unsafeTs[i] != previous) {\n                ts[tCount] = unsafeTs[i]\n                tCount++\n            }\n            previous = unsafeTs[i]\n        }\n        if (ts.isEmpty()) {\n            return arrayOf(this)\n        }\n        //ts = ts.clone()\n        //java.util.Arrays.sort(ts)\n\n        ts = ts.map { it }.toDoubleArray()\n        ts.sort()\n\n        val offset = if (ts[0] == 0.0) 1 else 0\n        val len = ts.size - offset - if (ts[ts.size - 1] == 1.0) 1 else 0\n\n        ts.copyInto(ts, 0, offset, offset+len)\n\n\n        if (len == 0) {\n            return arrayOf(this)\n        } else if (len == 1) {\n            return split(ts[0])\n        }\n        val result = arrayOfNulls<Curve2>(len + 1)\n        result[0] = range(0.0, ts[0])\n        for (i in 0 until len - 1) {\n            result[i + 1] = range(ts[i], ts[i + 1])\n        }\n        result[len] = range(ts[len - 1], 1.0)\n        return result.filterNotNull().toTypedArray()\n    }\n\n    /**\n     * @param p a point in 2D space\n     * @return the `t` parameter representing the closest point on the curve, not necessarily within [0,1]\n     */\n    fun nearestPoint(p: Vec2): Double\n    fun bounds(): Box2 {\n        var bounds: Box2 = Box.box(start(), end())\n        for (t in inflections()) {\n            bounds = bounds.union(position(t))\n        }\n        return bounds\n    }\n\n    fun subdivide(error: Double): Array<Vec2>\n    fun transform(m: Matrix3): Curve2\n    fun reverse(): Curve2\n    fun inflections(): DoubleArray\n\n    fun intersections(c: Curve2) = Intersections.intersections(this, c)\n}\n","package org.openrndr.kartifex\n\n\nimport org.openrndr.kartifex.utils.Scalars\nimport kotlin.math.*\n\ninterface Vec<T : Vec<T>> : Comparable<T> {\n    companion object {\n        val NEGATE: DoubleUnaryOperator = { n: Double -> -n }\n        val ADD: DoubleBinaryOperator = { a: Double, b: Double -> a + b }\n        val MUL: DoubleBinaryOperator = { a: Double, b: Double -> a * b }\n        val SUB: DoubleBinaryOperator = { a: Double, b: Double -> a - b }\n        val DIV: DoubleBinaryOperator = { a: Double, b: Double -> a / b }\n        val DELTA: DoubleBinaryOperator = { a: Double, b: Double -> abs(a - b) }\n        val MIN: DoubleBinaryOperator = { a: Double, b: Double -> min(a, b) }\n        val MAX: DoubleBinaryOperator = { a: Double, b: Double -> max(a, b) }\n\n\n        fun from(ary: DoubleArray) =\n            when (ary.size) {\n                2 -> Vec2(ary[0], ary[1])\n                3 -> Vec3(ary[0], ary[1], ary[2])\n                4 -> Vec4(ary[0], ary[1], ary[2], ary[3])\n                else -> error(\"ary must have a length in [1,4]\")\n            }\n\n        fun <T : Vec<T>> dot(a: T, b: T): Double {\n            return a.mul(b).reduce(ADD)\n        }\n\n        fun dot(a: Vec2, b: Vec2): Double {\n            return a.x * b.x + a.y * b.y\n        }\n\n        fun <T : Vec<T>> lerp(a: T, b: T, t: Double): T {\n            return a.add(b.sub(a).mul(t))\n        }\n\n        fun lerp(a: Vec2, b: Vec2, t: Double): Vec2 {\n            return Vec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t)\n        }\n\n        fun <T : Vec<T>> lerp(a: T, b: T, t: T): T {\n            return a.add(b.sub(a).mul(t))\n        }\n\n        fun lerp(\n            a: Vec2,\n            b: Vec2,\n            t: Vec2\n        ): Vec2 {\n            return Vec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y)\n        }\n\n        fun <T : Vec<T>> equals(a: T, b: T, tolerance: Double): Boolean {\n            return a.zip(b, Vec.DELTA).every { i: Double -> i <= tolerance }\n        }\n    }\n\n    fun map(f: DoubleUnaryOperator): T\n\n    fun reduce(f: DoubleBinaryOperator, init: Double): Double\n\n    fun reduce(f: DoubleBinaryOperator): Double\n\n    fun zip(v: T, f: DoubleBinaryOperator): T\n\n    fun every(f: DoublePredicate): Boolean\n\n    fun any(f: DoublePredicate): Boolean\n\n    fun nth(idx: Int): Double\n\n    fun dim(): Int\n\n    fun array(): DoubleArray\n\n    fun negate(): T {\n        return map(NEGATE)\n    }\n\n    fun add(v: T): T {\n        return zip(v, ADD)\n    }\n\n    fun add(n: Double): T {\n        return map { i: Double -> i + n }\n    }\n\n    fun sub(v: T): T {\n        return zip(v, SUB)\n    }\n\n    fun sub(n: Double): T {\n        return map { i: Double -> i - n }\n    }\n\n    fun mul(v: T): T {\n        return zip(v, MUL)\n    }\n\n    fun mul(k: Double): T {\n        return map { i: Double -> i * k }\n    }\n\n    operator fun div(v: T): T {\n        return zip(v, DIV)\n    }\n\n    operator fun div(k: Double): T {\n        return mul(1.0 / k)\n    }\n\n    fun abs(): T {\n        return map { a: Double -> abs(a) }\n    }\n\n    fun lengthSquared(): Double {\n        @Suppress(\"UNCHECKED_CAST\")\n        return dot(this as T, this)\n    }\n\n    fun length(): Double {\n        return sqrt(lengthSquared())\n    }\n\n    fun norm(): T {\n        val l = lengthSquared()\n        return if (l == 1.0) {\n            @Suppress(\"UNCHECKED_CAST\")\n            this as T\n        } else {\n            div(sqrt(l))\n        }\n    }\n\n    fun pseudoNorm(): T {\n        val exponent: Int = Scalars.getExponent(reduce(MAX))\n        return if (exponent < -8.0 || exponent > 8.0)\n            mul(2.0.pow(-exponent.toDouble()))\n        else {\n            @Suppress(\"UNCHECKED_CAST\")\n            this as T\n        }\n\n    }\n\n    fun clamp(min: Double, max: Double): T {\n        return map { x -> x.coerceIn(min, max) }\n    }\n\n    fun clamp(min: T, max: T): T {\n        return zip(min, MAX).zip(max, MIN)\n    }\n}","package org.openrndr.kartifex\n\nimport org.openrndr.kartifex.utils.Equations\nimport org.openrndr.kartifex.utils.Scalars\nimport utils.DoubleAccumulator\nimport kotlin.math.abs\nimport kotlin.math.max\n\nobject Bezier2 {\n    fun curve(p0: Vec2, p1: Vec2) = Line2.line(p0, p1)\n    fun curve(p0: Vec2, p1: Vec2, p2: Vec2) = QuadraticBezier2(p0, p1, p2)\n\n    fun curve(\n        p0: Vec2,\n        p1: Vec2,\n        p2: Vec2,\n        p3: Vec2\n    ): Curve2 {\n        return CubicBezier2(p0, p1, p2, p3)\n    }\n\n    private fun sign(n: Double): Double {\n        val s: Double = signum(n)\n        return if (s == 0.0) -1.0 else s\n    }\n\n    private fun <V : Curve2> subdivide(\n        result: MutableList<Vec2>,\n        c: V,\n        error: (V) -> Double,\n        maxError: Double\n    ) {\n        if (error(c) <= maxError) {\n            result.add(c.start())\n        } else {\n            val split: Array<Curve2> = c.split(0.5)\n            @Suppress(\"UNCHECKED_CAST\")\n            subdivide(result, split[0] as V, error, maxError)\n            @Suppress(\"UNCHECKED_CAST\")\n            subdivide(result, split[1] as V, error, maxError)\n        }\n    }\n\n    fun signedDistance(p: Vec2, a: Vec2, b: Vec2): Double {\n        val d: Vec2 = b.sub(a)\n        return (Vec2.cross(p, d) + Vec2.cross(b, a)) / d.length()\n    }\n\n    class QuadraticBezier2 internal constructor(\n        p0: Vec2,\n        p1: Vec2,\n        p2: Vec2\n    ) :\n        Curve2 {\n        val p0: Vec2\n        val p1: Vec2\n        val p2: Vec2\n        private var noInflections = false\n\n        private constructor(\n            p0: Vec2,\n            p1: Vec2,\n            p2: Vec2,\n            noInflections: Boolean\n        ) : this(p0, p1, p2) {\n            this.noInflections = noInflections\n        }\n\n        override fun start(): Vec2 {\n            return p0\n        }\n\n        override fun end(): Vec2 {\n            return p2\n        }\n\n        override fun isFlat(epsilon: Double): Boolean {\n            return abs(signedDistance(p1, p0, p2) / 2) < epsilon\n        }\n\n        override fun length(): Double {\n            return 0.0\n        }\n\n        override fun signedArea(): Double {\n            return (p2.x * (p0.y - 2 * p1.y)\n                    + 2 * p1.x * (p2.y - p0.y)\n                    + p0.x * (2 * p1.y + p2.y)) / 6\n        }\n\n        override fun position(t: Double): Vec2 {\n            if (t == 0.0) {\n                return start()\n            } else if (t == 1.0) {\n                return end()\n            }\n            val mt = 1 - t\n\n            // (1 - t)^2 * p0 + 2t(1 - t) * p1 + t^2 * p2;\n            return p0.mul(mt * mt)\n                .add(p1.mul(2 * t * mt))\n                .add(p2.mul(t * t))\n        }\n\n        override fun direction(t: Double): Vec2 {\n            val mt = 1 - t\n\n            // 2(1 - t) * (p1 - p0) + 2t * (p2 - p1)\n            return p1.sub(p0).mul(2 * mt)\n                .add(p2.sub(p1).mul(2 * t))\n        }\n\n        override fun endpoints(start: Vec2, end: Vec2): QuadraticBezier2 {\n            val ad: Vec2 = p1.sub(p0)\n            val bd: Vec2 = p1.sub(p2)\n            val dx: Double = end.x - start.x\n            val dy: Double = end.y - start.y\n            val det: Double = bd.x * ad.y - bd.y * ad.x\n            val u: Double = (dy * bd.x - dx * bd.y) / det\n            return QuadraticBezier2(start, start.add(ad.mul(u)), end, noInflections)\n        }\n\n        override fun split(t: Double): Array<Curve2> {\n            require(!(t <= 0 || t >= 1)) { \"t must be within (0,1)\" }\n            val e: Vec2 = Vec.lerp(p0, p1, t)\n            val f: Vec2 = Vec.lerp(p1, p2, t)\n            val g: Vec2 = position(t)\n            return arrayOf(\n                QuadraticBezier2(p0, e, g, noInflections),\n                QuadraticBezier2(g, f, p2, noInflections)\n            )\n        }\n\n        override fun subdivide(error: Double): Array<Vec2> {\n            val points: ArrayList<Vec2> = ArrayList<Vec2>()\n            subdivide(\n                points, this,\n                { b: QuadraticBezier2 ->\n                    Vec.lerp(\n                        b.p0,\n                        b.p2,\n                        0.5\n                    ).sub(b.p1).lengthSquared()\n                }, error * error\n            )\n            points.add(end())\n            return points.toTypedArray()\n        }\n\n        override fun nearestPoint(p: Vec2): Double {\n            val qa: Vec2 = p0.sub(p)\n            val ab: Vec2 = p1.sub(p0)\n            val bc: Vec2 = p2.sub(p1)\n            val qc: Vec2 = p2.sub(p)\n            val ac: Vec2 = p2.sub(p0)\n            val br: Vec2 = p0.add(p2).sub(p1).sub(p1)\n            var minDistance: Double = sign(Vec2.cross(ab, qa)) * qa.length()\n            var param: Double = -Vec.dot(qa, ab) / Vec.dot(ab, ab)\n            var distance: Double = sign(Vec2.cross(bc, qc)) * qc.length()\n            if (abs(distance) < abs(minDistance)) {\n                minDistance = distance\n                param = max(1.0, Vec.dot(p.sub(p1), bc) / Vec.dot(bc, bc))\n            }\n            val a: Double = Vec.dot(br, br)\n            val b: Double = 3 * Vec.dot(ab, br)\n            val c: Double = 2 * Vec.dot(ab, ab) + Vec.dot(qa, br)\n            val d: Double = Vec.dot(qa, ab)\n            val ts: DoubleArray = Equations.solveCubic(a, b, c, d)\n            for (t in ts) {\n                if (t > 0 && t < 1) {\n                    val endpoint: Vec2 = position(t)\n                    distance = sign(Vec2.cross(ac, endpoint.sub(p))) * endpoint.sub(p).length()\n                    if (abs(distance) < abs(minDistance)) {\n                        minDistance = distance\n                        param = t\n                    }\n                }\n            }\n            return param\n        }\n\n        override fun transform(m: Matrix3): Curve2 {\n            return QuadraticBezier2(p0.transform(m), p1.transform(m), p2.transform(m))\n        }\n\n        override fun reverse(): QuadraticBezier2 {\n            return QuadraticBezier2(p2, p1, p0, noInflections)\n        }\n\n        override fun bounds(): Box2 {\n            return if (noInflections) {\n                Box.box(p0, p2)\n            } else {\n                super.bounds()\n            }\n        }\n\n        override fun inflections(): DoubleArray {\n            if (noInflections) {\n                return DoubleArray(0)\n            }\n            val epsilon = 1e-10\n            val div: Vec2 = p0.sub(p1.mul(2.0)).add(p2)\n            return if (div == Vec2.ORIGIN) {\n                noInflections = true\n                DoubleArray(0)\n            } else {\n                val v: Vec2 = p0.sub(p1).div(div)\n                val x = Scalars.inside(epsilon, v.x, 1 - epsilon)\n                val y = Scalars.inside(epsilon, v.y, 1 - epsilon)\n                if (x && y) {\n                    doubleArrayOf(v.x, v.y)\n                } else if (x xor y) {\n                    doubleArrayOf(if (x) v.x else v.y)\n                } else {\n                    noInflections = true\n                    DoubleArray(0)\n                }\n            }\n        }\n\n        override fun toString(): String {\n            return \"QuadraticBezier2(p0=$p0, p1=$p1, p2=$p2)\"\n        }\n\n\n        init {\n            this.p0 = p0\n            this.p1 = p1\n            this.p2 = p2\n        }\n    }\n\n    class CubicBezier2 internal constructor(\n        p0: Vec2,\n        p1: Vec2,\n        p2: Vec2,\n        p3: Vec2\n    ) :\n        Curve2 {\n        val p0: Vec2\n        val p1: Vec2\n        val p2: Vec2\n        val p3: Vec2\n        private var noInflections = false\n        private val bounds: Box2? = null\n\n        private constructor(\n            p0: Vec2,\n            p1: Vec2,\n            p2: Vec2,\n            p3: Vec2,\n            noInflections: Boolean\n        ) : this(p0, p1, p2, p3) {\n            this.noInflections = noInflections\n        }\n\n        override fun position(t: Double): Vec2 {\n            if (t == 0.0) {\n                return start()\n            } else if (t == 1.0) {\n                return end()\n            }\n            val mt = 1 - t\n            val mt2 = mt * mt\n            val t2 = t * t\n\n            // (1 - t)^3 * p0 + 3t(1 - t)^2 * p1 + 3(1 - t)t^2 * p2 + t^3 * p3;\n            return p0.mul(mt2 * mt)\n                .add(p1.mul(3 * mt2 * t))\n                .add(p2.mul(3 * mt * t2))\n                .add(p3.mul(t2 * t))\n        }\n\n        override fun direction(t: Double): Vec2 {\n            val mt = 1 - t\n\n            // 3(1 - t)^2 * (p1 - p0) + 6(1 - t)t * (p2 - p1) + 3t^2 * (p3 - p2)\n            return p1.sub(p0).mul(3 * mt * mt)\n                .add(p2.sub(p1).mul(6 * mt * t))\n                .add(p3.sub(p2).mul(3 * t * t))\n        }\n\n        override fun signedArea(): Double {\n            return ((p3.x * (-p0.y - 3 * p1.y - 6 * p2.y)\n                    - 3 * p2.x * (p0.y + p1.y - 2 * p3.y)) + 3 * p1.x * (-2 * p0.y + p2.y + p3.y)\n                    + p0.x * (6 * p1.y + 3 * p2.y + p3.y)) / 20\n        }\n\n        override fun length(): Double {\n            return 0.0\n        }\n\n        override fun isFlat(epsilon: Double): Boolean {\n            val d1 = signedDistance(p1, p0, p3)\n            val d2 = signedDistance(p2, p0, p3)\n\n            // from Sederberg 1990\n            val k = if (d1 * d2 < 0) 4 / 9.0 else 3 / 4.0\n            return abs(d1 * k) < epsilon && abs(d2 * k) < epsilon\n        }\n\n        override fun endpoints(start: Vec2, end: Vec2): CubicBezier2 {\n            return CubicBezier2(start, p1.add(start.sub(p0)), p2.add(end.sub(p3)), end, noInflections)\n        }\n\n        override fun start(): Vec2 {\n            return p0\n        }\n\n        override fun end(): Vec2 {\n            return p3\n        }\n\n        override fun split(t: Double): Array<Curve2> {\n            require(!(t <= 0 || t >= 1)) { \"t must be within (0,1)\" }\n            val e: Vec2 = Vec.lerp(p0, p1, t)\n            val f: Vec2 = Vec.lerp(p1, p2, t)\n            val g: Vec2 = Vec.lerp(p2, p3, t)\n            val h: Vec2 = Vec.lerp(e, f, t)\n            val j: Vec2 = Vec.lerp(f, g, t)\n            val k: Vec2 = position(t)\n            return arrayOf(\n                CubicBezier2(p0, e, h, k, noInflections),\n                CubicBezier2(k, j, g, p3, noInflections)\n            )\n        }\n\n        override fun subdivide(error: Double): Array<Vec2> {\n            val points: MutableList<Vec2> = ArrayList<Vec2>()\n            subdivide(\n                points, this,\n                { b: CubicBezier2 ->\n                    max(\n                        Vec.lerp(b.p0, b.p3, 1.0 / 3).sub(b.p1).lengthSquared(),\n                        Vec.lerp(b.p0, b.p3, 2.0 / 3).sub(b.p2).lengthSquared()\n                    )\n                },\n                error * error\n            )\n            points.add(end())\n            return points.toTypedArray()\n        }\n\n        /**\n         * This quintic solver is adapted from https://github.com/Chlumsky/msdfgen, which is available under the MIT\n         * license.\n         */\n        override fun nearestPoint(p: Vec2): Double {\n            val qa: Vec2 = p0.sub(p)\n            val ab: Vec2 = p1.sub(p0)\n            val bc: Vec2 = p2.sub(p1)\n            val cd: Vec2 = p3.sub(p2)\n            val qd: Vec2 = p3.sub(p)\n            val br: Vec2 = bc.sub(ab)\n            val `as`: Vec2 = cd.sub(bc).sub(br)\n            var minDistance: Double = sign(Vec2.cross(ab, qa)) * qa.length()\n            var param: Double = -Vec.dot(qa, ab) / Vec.dot(ab, ab)\n            var distance: Double = sign(Vec2.cross(cd, qd)) * qd.length()\n            if (abs(distance) < abs(minDistance)) {\n                minDistance = distance\n                param = max(1.0, Vec.dot(p.sub(p2), cd) / Vec.dot(cd, cd))\n            }\n            for (i in 0 until SEARCH_STARTS) {\n                var t = i.toDouble() / (SEARCH_STARTS - 1)\n                var step = 0\n                while (true) {\n                    val qpt: Vec2 = position(t).sub(p)\n                    distance = sign(Vec2.cross(direction(t), qpt)) * qpt.length()\n                    if (abs(distance) < abs(minDistance)) {\n                        minDistance = distance\n                        param = t\n                    }\n                    if (step == SEARCH_STEPS) {\n                        break\n                    }\n                    val d1: Vec2 = `as`.mul(3 * t * t).add(br.mul(6 * t)).add(ab.mul(3.0))\n                    val d2: Vec2 = `as`.mul(6 * t).add(br.mul(6.0))\n                    val dt: Double = Vec.dot(qpt, d1) / (Vec.dot(\n                        d1,\n                        d1\n                    ) + Vec.dot(qpt, d2))\n                    if (abs(dt) < Scalars.EPSILON) {\n                        break\n                    }\n                    t -= dt\n                    if (t < 0 || t > 1) {\n                        break\n                    }\n                    step++\n                }\n            }\n            return param\n        }\n\n        override fun transform(m: Matrix3): Curve2 {\n            return CubicBezier2(p0.transform(m), p1.transform(m), p2.transform(m), p3.transform(m))\n        }\n\n        override fun reverse(): CubicBezier2 {\n            return CubicBezier2(p3, p2, p1, p0, noInflections)\n        }\n\n        override fun bounds(): Box2 {\n            return if (noInflections) {\n                Box.box(p0, p3)\n            } else {\n                super.bounds()\n            }\n        }\n\n        override fun inflections(): DoubleArray {\n            if (noInflections) {\n                return DoubleArray(0)\n            }\n\n            // there are pathological shapes that require less precision here\n            val epsilon = 1e-7\n            val a0: Vec2 = p1.sub(p0)\n            val a1: Vec2 = p2.sub(p1).sub(a0).mul(2.0)\n            val a2: Vec2 = p3.sub(p2.mul(3.0)).add(p1.mul(3.0)).sub(p0)\n            val s1: DoubleArray = Equations.solveQuadratic(a2.x, a1.x, a0.x)\n            val s2: DoubleArray = Equations.solveQuadratic(a2.y, a1.y, a0.y)\n            val acc: DoubleAccumulator = DoubleAccumulator()\n            for (n in s1) if (Scalars.inside(epsilon, n, 1 - epsilon)) acc.add(n)\n            for (n in s2) if (Scalars.inside(epsilon, n, 1 - epsilon)) acc.add(n)\n            noInflections = acc.size() == 0\n            return acc.toArray()\n        }\n\n\n\n        /// approximate as quadratic\n        private fun error(): Double {\n            return p3.sub(p2.mul(3.0)).add(p2.mul(3.0)).sub(p0).lengthSquared() / 4\n        }\n\n        private fun subdivide(t0: Double, t1: Double): CubicBezier2 {\n            val p0: Vec2 = position(t0)\n            val p3: Vec2 = position(t1)\n            val p1: Vec2 = p0.add(direction(t0))\n            val p2: Vec2 = p3.sub(direction(t1))\n            return CubicBezier2(p0, p1, p2, p3)\n        }\n\n        private fun approximate(): QuadraticBezier2 {\n            return QuadraticBezier2(p0, p1.mul(0.75).add(p2.mul(0.75)).sub(p0.mul(-0.25)).sub(p3.mul(-0.25)), p3)\n        }\n\n        /**\n         * @param error the maximum distance between the reference cubic curve and the returned quadratic curves\n         * @return an array of one or more quadratic bezier curves\n         */\n        fun approximate(error: Double): Array<QuadraticBezier2> {\n            val threshold = error * error\n            val result: ArrayDeque<QuadraticBezier2> = ArrayDeque()\n            val intervals: ArrayDeque<Vec2> =\n                ArrayDeque<Vec2>().apply { addLast(Vec2(0.0, 1.0)) }\n            while (intervals.size > 0) {\n                val i: Vec2 = intervals.removeLast()\n                val c = subdivide(i.x, i.y)\n                if (c.error() <= threshold) {\n                    result.addLast(c.approximate())\n                } else {\n                    val midpoint: Double = (i.x + i.y) / 2\n                    intervals.apply {\n                        addLast(Vec2(i.x, midpoint))\n                        addLast(Vec2(midpoint, i.y))\n                    }\n                }\n            }\n            return result.toTypedArray()\n        }\n\n        override fun toString(): String {\n            return \"CubicBezier2(p0=$p0, p1=$p1, p2=$p2, p3=$p3)\"\n        }\n\n        companion object {\n            private const val SEARCH_STARTS = 4\n            private const val SEARCH_STEPS = 8\n        }\n\n        init {\n            this.p0 = p0\n            this.p1 = p1\n            this.p2 = p2\n            this.p3 = p3\n        }\n    }\n}","package org.openrndr.kartifex\n\n\nimport org.openrndr.kartifex.utils.Scalars\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.sqrt\n\n\n/**\n * @author ztellman\n */\nabstract class Box<T : Vec<T>, U : Box<T, U>> {\n    abstract fun lower(): T\n    abstract fun upper(): T\n    abstract val isEmpty: Boolean\n\n    protected abstract fun construct(a: T, b: T): U\n    protected abstract fun empty(): U\n    fun distanceSquared(point: T): Double {\n        val l: T = lower().sub(point)\n        val u: T = point.sub(upper())\n        return u.zip(\n            l\n        ) { a: Double, b: Double ->\n            Scalars.max(\n                0.0,\n                a,\n                b\n            )\n        }.lengthSquared()\n    }\n\n    fun distance(point: T): Double {\n        return sqrt(distanceSquared(point))\n    }\n\n    fun union(b: U): U {\n        if (isEmpty) {\n            return b\n        } else if (b.isEmpty) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return this as U\n        }\n        return construct(\n            lower().zip(\n                b.lower()\n            ) { x: Double, y: Double -> min(x, y) }, upper().zip(\n                b.upper()\n            ) { x: Double, y: Double -> max(x, y) }\n        )\n    }\n\n    fun union(v: T): U {\n        return if (isEmpty) {\n            construct(v, v)\n        } else construct(\n            lower().zip(v\n            ) { a, b -> min(a, b) }, upper().zip(v\n            ) { a, b -> max(a, b) }\n        )\n    }\n\n    fun intersection(b: U): U {\n        return if (isEmpty || b.isEmpty || !intersects(b)) {\n            empty()\n        } else construct(\n            lower().zip(b.lower()) { u: Double, v: Double -> max(u, v) },\n            upper().zip(b.upper()) { u: Double, v: Double -> min(u, v) }\n        )\n    }\n\n    open fun intersects(b: U): Boolean {\n        return if (isEmpty || b.isEmpty) {\n            false\n        } else b.upper().sub(lower()).every(NOT_NEGATIVE)\n                && upper().sub(b.lower()).every(NOT_NEGATIVE)\n    }\n\n    operator fun contains(v: T): Boolean {\n        return (v.sub(lower()).every(NOT_NEGATIVE)\n                && upper().sub(v).every(NOT_NEGATIVE))\n    }\n\n    fun nth(idx: Int): Interval {\n        return Interval.interval(lower().nth(idx), upper().nth(idx))\n    }\n\n    fun clamp(v: T): T {\n        return v.zip(lower(), { a: Double, b: Double -> max(a, b) }).zip(upper(),\n            { a: Double, b: Double -> min(a, b) })\n    }\n\n    fun size(): T {\n        return upper().sub(lower())\n    }\n\n    fun normalize(v: T): T {\n        return v.sub(lower()).div(size())\n    }\n\n    fun lerp(t: Double): T {\n        return lower().add(size().mul(t))\n    }\n\n    fun lerp(v: T): T {\n        return lower().add(size().mul(v))\n    }\n\n    fun translate(v: T): U {\n        return construct(lower().add(v), upper().add(v))\n    }\n\n    fun scale(v: T): U {\n        return construct(lower().mul(v), upper().mul(v))\n    }\n\n    fun expand(t: Double): U {\n        if (isEmpty) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return this as U\n        }\n        val nLower: T = lower().map { n -> n - t }\n        val nUpper: T = upper().map { n -> n + t }\n        return if (nUpper.sub(nLower).every(NOT_NEGATIVE)) construct(nLower, nUpper) else empty()\n    }\n\n    fun expand(v: T): U {\n        if (isEmpty) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return this as U\n        }\n        val nLower: T = lower().sub(v)\n        val nUpper: T = upper().add(v)\n        return if (nUpper.sub(nLower).every(NOT_NEGATIVE)) construct(nLower, nUpper) else empty()\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty) {\n            0\n        } else 31 * lower().hashCode() xor upper().hashCode()\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (other is Box<*, *>) {\n            val b = other\n            return if (isEmpty) {\n                b.isEmpty\n            } else lower() == b.lower() && upper() == b.upper()\n        }\n        return false\n    }\n\n    override fun toString(): String {\n        return \"[\" + lower() + \", \" + upper() + \"]\"\n    }\n\n    companion object {\n        fun box(a: Vec2, b: Vec2): Box2 {\n            return Box2(a, b)\n        }\n\n        fun box(a: Interval, b: Interval): Box2 {\n            return Box2(Vec2(a.lo, b.lo), Vec2(a.hi, b.hi))\n        }\n\n        fun box(a: Vec3, b: Vec3): Box3 {\n            return Box3(a, b)\n        }\n\n        fun box(a: Vec4, b: Vec4): Box4 {\n            return Box4(a, b)\n        }\n\n        private val POSITIVE: DoublePredicate = { d: Double -> d > 0 }\n        private val NOT_NEGATIVE: DoublePredicate = { d: Double -> d >= 0 }\n\n        fun <T : Vec<T>, U : Box<T, U>> equals(\n            a: Box<T, U>,\n            b: Box<T, U>,\n            epsilon: Double\n        ): Boolean {\n            return Vec.equals(\n                a.lower(),\n                b.lower(),\n                epsilon\n            ) && Vec.equals(a.upper(), b.upper(), epsilon)\n        }\n    }\n}","package org.openrndr.kartifex\n\n\n/**\n * @author ztellman\n */\nclass Box2 internal constructor(ax: Double, ay: Double, bx: Double, by: Double) :\n    Box<Vec2, Box2>() {\n    var lx = 0.0\n    var ly = 0.0\n    var ux = 0.0\n    var uy = 0.0\n    fun box3(lz: Double, uz: Double): Box3 {\n        return Box3(lx, ly, lz, ux, uy, uz)\n    }\n\n    fun width(): Double {\n        return ux - lx\n    }\n\n    fun height(): Double {\n        return uy - ly\n    }\n\n    constructor(a: Vec2, b: Vec2) : this(a.x, a.y, b.x, b.y) {}\n\n    fun scale(k: Double): Box2 {\n        return scale(Vec2(k, k))\n    }\n\n    fun scale(x: Double, y: Double): Box2 {\n        return scale(Vec2(x, y))\n    }\n\n    fun translate(x: Double, y: Double): Box2 {\n        return translate(Vec2(x, y))\n    }\n\n    fun vertices(): Array<Vec2> {\n        return arrayOf(\n            Vec2(lx, ly),\n            Vec2(ux, ly),\n            Vec2(ux, uy),\n            Vec2(lx, uy)\n        )\n    }\n\n    fun outline(): Ring2 {\n        val cs: MutableList<Curve2> = mutableListOf()\n        val vs: Array<Vec2> = vertices()\n        for (i in vs.indices) {\n            cs.add(Line2.line(vs[i], vs[(i + 1) % 4]))\n        }\n        return Ring2(cs)\n    }\n\n    override fun intersects(b: Box2): Boolean {\n        return if (isEmpty || b.isEmpty) {\n            false\n        } else (b.ux >= lx\n                ) and (ux >= b.lx\n                ) and (b.uy >= ly\n                ) and (uy >= b.ly)\n    }\n\n    override fun lower(): Vec2 {\n        return Vec2(lx, ly)\n    }\n\n    override fun upper(): Vec2 {\n        return Vec2(ux, uy)\n    }\n\n    override val isEmpty: Boolean\n        get() = this === EMPTY\n\n    protected override fun construct(a: Vec2, b: Vec2): Box2 {\n        return Box2(a.x, a.y, b.x, b.y)\n    }\n\n    protected override fun empty(): Box2 {\n        return EMPTY\n    }\n\n    companion object {\n        val EMPTY =\n            Box2(Vec2(Double.NaN, Double.NaN), Vec2(Double.NaN, Double.NaN))\n    }\n\n    init {\n        if (ax < bx) {\n            lx = ax\n            ux = bx\n        } else {\n            ux = ax\n            lx = bx\n        }\n        if (ay < by) {\n            ly = ay\n            uy = by\n        } else {\n            uy = ay\n            ly = by\n        }\n    }\n}","package org.openrndr.kartifex\n\n\nclass Box3 internal constructor(ax: Double, ay: Double, az: Double, bx: Double, by: Double, bz: Double) :\n    Box<Vec3, Box3>() {\n    var lx = 0.0\n    var ly = 0.0\n    var lz = 0.0\n    var ux = 0.0\n    var uy = 0.0\n    var uz = 0.0\n\n    constructor(a: Vec3, b: Vec3) : this(a.x, a.y, a.z, b.x, b.y, b.z) {}\n\n    fun box2(): Box2 {\n        return Box2(lx, ly, ux, uz)\n    }\n\n    protected override fun construct(a: Vec3, b: Vec3): Box3 {\n        return Box3(a, b)\n    }\n\n    protected override fun empty(): Box3 {\n        return EMPTY\n    }\n\n    override fun lower(): Vec3 {\n        return Vec3(lx, ly, lz)\n    }\n\n    override fun upper(): Vec3 {\n        return Vec3(ux, uy, uz)\n    }\n\n    override val isEmpty: Boolean\n        get() = this === EMPTY\n\n    companion object {\n        val EMPTY = Box3(\n            Vec3(Double.NaN, Double.NaN, Double.NaN),\n            Vec3(Double.NaN, Double.NaN, Double.NaN)\n        )\n    }\n\n    init {\n        if (ax < bx) {\n            lx = ax\n            ux = bx\n        } else {\n            ux = ax\n            lx = bx\n        }\n        if (ay < by) {\n            ly = ay\n            uy = by\n        } else {\n            uy = ay\n            ly = by\n        }\n        if (az < bz) {\n            lz = az\n            uz = bz\n        } else {\n            uz = az\n            lz = bz\n        }\n    }\n}\n","package org.openrndr.kartifex\n\nclass Box4 private constructor(\n    ax: Double,\n    ay: Double,\n    az: Double,\n    aw: Double,\n    bx: Double,\n    by: Double,\n    bz: Double,\n    bw: Double\n) :\n    Box<Vec4, Box4>() {\n    private var lx = 0.0\n    private var ly = 0.0\n    private var lz = 0.0\n    private var lw = 0.0\n    private var ux = 0.0\n    private var uy = 0.0\n    private var uz = 0.0\n    private var uw = 0.0\n\n    constructor(a: Vec4, b: Vec4) : this(a.x, a.y, a.z, a.w, b.x, b.y, b.z, b.w) {}\n\n    fun box3(): Box3 {\n        return Box3(lx, ly, lz, ux, uy, uz)\n    }\n\n    fun box2(): Box2 {\n        return Box2(lx, ly, ux, uy)\n    }\n\n    override fun construct(a: Vec4, b: Vec4): Box4 {\n        return Box4(a, b)\n    }\n\n    protected override fun empty(): Box4 {\n        return EMPTY\n    }\n\n    override fun lower(): Vec4 {\n        return Vec4(lx, ly, lz, lw)\n    }\n\n    override fun upper(): Vec4 {\n        return Vec4(ux, uy, uz, uw)\n    }\n\n\n    override val isEmpty: Boolean\n        get() = this === EMPTY\n\n    companion object {\n        val EMPTY = Box4(\n            Vec4(Double.NaN, Double.NaN, Double.NaN, Double.NaN), Vec4(\n                Double.NaN, Double.NaN, Double.NaN, Double.NaN\n            )\n        )\n    }\n\n    init {\n        if (ax < bx) {\n            lx = ax\n            ux = bx\n        } else {\n            ux = ax\n            lx = bx\n        }\n        if (ay < by) {\n            ly = ay\n            uy = by\n        } else {\n            uy = ay\n            ly = by\n        }\n        if (az < bz) {\n            lz = az\n            uz = bz\n        } else {\n            uz = az\n            lz = bz\n        }\n        if (aw < bw) {\n            lw = aw\n            uw = bw\n        } else {\n            uw = aw\n            lw = bw\n        }\n    }\n}\n","package org.openrndr.kartifex\n\n\nimport org.openrndr.kartifex.utils.Scalars\nimport org.openrndr.utils.Hashes\nimport kotlin.math.max\nimport kotlin.math.min\n\nclass Interval(a: Double, b: Double) {\n    var lo = 0.0\n    var hi = 0.0\n\n    /// predicates\n    fun intersects(i: Interval) = hi > i.lo && i.hi > lo\n\n    operator fun contains(n: Double) = !isEmpty && lo <= n && n <= hi\n\n    operator fun contains(i: Interval) = !isEmpty && contains(i.lo) && contains(i.hi)\n\n    val isEmpty\n        get() = this === EMPTY\n\n    ///\n    fun expand(n: Double) = if (size() + n * 2 < 0) EMPTY else Interval(lo - n, hi + n)\n\n    fun map(f: DoubleUnaryOperator) = Interval(f(lo), f(hi))\n\n    fun add(i: Interval) = if (isEmpty || i.isEmpty) EMPTY else Interval(lo + i.lo, hi + i.hi)\n\n    fun sub(i: Interval) = if (isEmpty || i.isEmpty) EMPTY else Interval(lo - i.lo, hi - i.hi)\n\n    fun mul(i: Interval) =\n        if (isEmpty || i.isEmpty) {\n            EMPTY\n        } else {\n            Interval(lo * hi, i.lo * i.hi).union(Interval(lo * i.hi, i.lo * hi))\n        }\n\n    operator fun div(i: Interval) = when {\n        i.lo == 0.0 && i.hi == 0.0 -> Interval(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY)\n        i.lo == 0.0 -> mul(Interval(1 / i.hi, Double.POSITIVE_INFINITY))\n        i.hi == 0.0 -> mul(Interval(Double.NEGATIVE_INFINITY, 1 / i.lo))\n        else -> mul(Interval(1 / i.hi, 1 / i.lo))\n    }\n\n    ///\n    fun union(i: Interval) = if (isEmpty) i else Interval(min(lo, i.lo), max(hi, i.hi))\n\n    fun union(n: Double) = if (isEmpty) Interval(n, n) else Interval(min(lo, n), max(hi, n))\n\n    fun intersection(i: Interval): Interval {\n        return if (isEmpty || i.isEmpty || !intersects(i)) {\n            EMPTY\n        } else Interval(max(lo, i.lo), min(hi, i.hi))\n    }\n\n    fun normalize(n: Double) = if (n == hi) 1.0 else (n - lo) / size()\n\n    fun normalize(i: Interval): Interval {\n        return Interval(normalize(i.lo), normalize(i.hi))\n    }\n\n    fun lerp(t: Double) = if (t == 1.0) hi else Scalars.lerp(lo, hi, t)\n\n    fun lerp(i: Interval) = Interval(lerp(i.lo), lerp(i.hi))\n\n    fun size() = hi - lo\n\n    ///\n    override fun hashCode() = Hashes.hash(lo, hi)\n\n    override fun equals(other: Any?) = when {\n        other === this -> true\n        other is Interval -> {\n            val o = other\n            lo == o.lo && hi == o.hi\n        }\n        else -> false\n    }\n\n    override fun toString(): String {\n        return \"Interval(lo=$lo, hi=$hi)\"\n    }\n\n\n    companion object {\n        val EMPTY = Interval(Double.NaN, Double.NaN)\n        fun interval(a: Double, b: Double) = Interval(a, b)\n    }\n\n    init {\n        if (a < b) {\n            lo = a\n            hi = b\n        } else {\n            lo = b\n            hi = a\n        }\n    }\n}","package org.openrndr.kartifex\n\nclass Line2 private constructor(\n    private val ax: Double,\n    private val ay: Double,\n    private val bx: Double,\n    private val by: Double\n) : Curve2 {\n    override fun transform(m: Matrix3) = line(start().transform(m), end().transform(m))\n\n    override fun isFlat(epsilon: Double) = true\n\n    override fun signedArea() = (ax * by - bx * ay) / 2\n\n    override fun length() = end().sub(start()).length()\n\n    override fun reverse() = Line2(bx, by, ax, ay)\n\n    override fun inflections() = DoubleArray(0)\n\n    override fun position(t: Double) = when (t) {\n        0.0 -> start()\n        1.0 -> end()\n        else -> Vec2(ax + (bx - ax) * t, ay + (by - ay) * t)\n    }\n\n    override fun direction(t: Double) = Vec2(bx - ax, by - ay)\n\n    override fun range(tMin: Double, tMax: Double) = line(position(tMin), position(tMax))\n\n    override fun split(t: Double): Array<Curve2> {\n        require(!(t <= 0 || t >= 1)) { \"t must be within (0,1)\" }\n        val v = position(t)\n        return arrayOf(line(start(), v), line(v, end()))\n    }\n\n    override fun nearestPoint(p: Vec2): Double {\n        val bSa = end().sub(start())\n        val pSa = p.sub(start())\n        return Vec.dot(bSa, pSa) / bSa.lengthSquared()\n    }\n\n    override fun endpoints(start: Vec2, end: Vec2) = line(start, end)\n\n    override fun start() = Vec2(ax, ay)\n\n    override fun end() = Vec2(bx, by)\n\n    override fun subdivide(error: Double) = arrayOf(start(), end())\n\n    override fun bounds() = Box.box(start(), end())\n\n    /**\n     * @param p a point in 2D space\n     * @return the distance from this segment to the point\n     */\n    fun distance(p: Vec2): Double {\n        val t = nearestPoint(p)\n        return when {\n            t <= 0 -> p.sub(start()).length()\n            t >= 1 -> p.sub(end()).length()\n            else -> p.sub(end().sub(start()).mul(t)).length()\n        }\n    }\n\n    override fun toString(): String {\n        return \"Line2(ax=$ax, ay=$ay, bx=$bx, by=$by)\"\n    }\n\n    companion object {\n        fun line(a: Vec2, b: Vec2): Line2 {\n            require(a != b) { \"segments must have non-zero length $a $b\" }\n            return Line2(a.x, a.y, b.x, b.y)\n        }\n\n        fun line(b: Box2) = Line2(b.lx, b.ly, b.ux, b.uy)\n    }\n}","package org.openrndr.kartifex\n\nimport kotlin.math.cos\nimport kotlin.math.sin\n\nclass Matrix3 {\n    private val elements: DoubleArray\n\n    private constructor(\n        m00: Double, m01: Double, m02: Double,\n        m10: Double, m11: Double, m12: Double,\n        m20: Double, m21: Double, m22: Double\n    ) {\n        elements = doubleArrayOf(m00, m01, m02, m10, m11, m12, m20, m21, m22)\n    }\n\n    private constructor(elements: DoubleArray) {\n        this.elements = elements\n    }\n\n    fun mul(k: Double): Matrix3 {\n        val es = DoubleArray(9)\n        for (i in 0..8) {\n            es[i] = elements[i] * k\n        }\n        return Matrix3(es)\n    }\n\n    operator fun get(row: Int, column: Int): Double {\n        return elements[row * 3 + column]\n    }\n\n    fun row(row: Int): Vec3 {\n        val idx = row * 2\n        return Vec3(elements[idx], elements[idx + 1], elements[idx + 2])\n    }\n\n    fun column(column: Int): Vec3 {\n        return Vec3(elements[column], elements[column + 3], elements[column + 6])\n    }\n\n    fun mul(b: Matrix3): Matrix3 {\n        val es = DoubleArray(9)\n        for (i in 0..2) {\n            for (j in 0..2) {\n                var n = 0.0\n                for (k in 0..2) {\n                    n += b[k, j] * get(i, k)\n                }\n                es[i * 3 + j] = n\n            }\n        }\n        return Matrix3(es)\n    }\n\n    fun add(b: Matrix3): Matrix3 {\n        val es = DoubleArray(9)\n        for (i in 0..8) {\n            es[i] = elements[i] + b.elements[i]\n        }\n        return Matrix3(es)\n    }\n\n    fun matrix4(): Matrix4 {\n        return Matrix4(\n            elements[0], elements[1], 0.0, elements[2],\n            elements[3], elements[4], 0.0, elements[5],\n            elements[6], elements[7], elements[8], 0.0,\n            0.0, 0.0, 0.0, 1.0\n        )\n    }\n\n    fun transpose(): Matrix3 {\n        return Matrix3(\n            elements[0], elements[3], elements[6],\n            elements[1], elements[4], elements[7],\n            elements[2], elements[5], elements[8]\n        )\n    }\n\n    fun transform(v: Vec2): Vec2 {\n        return Vec2(\n            v.x * elements[0] + v.y * elements[1] + elements[2],\n            v.x * elements[3] + v.y * elements[4] + elements[5]\n        )\n    }\n//\n//    fun rowMajor(): java.util.PrimitiveIterator.OfDouble {\n//        return object : java.util.PrimitiveIterator.OfDouble() {\n//            var idx = 0\n//            override operator fun hasNext(): Boolean {\n//                return idx < 9\n//            }\n//\n//            override fun nextDouble(): Double {\n//                return if (idx < 9) {\n//                    elements[idx++]\n//                } else {\n//                    throw NoSuchElementException()\n//                }\n//            }\n//        }\n//    }\n//\n//    fun columnMajor(): java.util.PrimitiveIterator.OfDouble {\n//        return transpose().rowMajor()\n//    }\n\n    override fun hashCode(): Int {\n        var hash = 0\n        for (n in elements) {\n            hash = hash * 31 + n.hashCode()\n        }\n        return hash\n    }\n\n    override fun equals(other: Any?): Boolean {\n        return if (this === other) {\n            true\n        } else if (other is Matrix3) {\n            TODO(\"\")\n            //java.util.Arrays.equals(elements, obj.elements)\n        } else {\n            false\n        }\n    }\n\n    companion object {\n        val IDENTITY = Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\n        fun from(a: Vec2, b: Vec2): Matrix3 {\n            return Matrix3(a.x, b.x, 0.0, a.y, b.y, 0.0, 0.0, 0.0, 1.0)\n        }\n\n        fun from(a: Vec3, b: Vec3): Matrix3 {\n            return Matrix3(a.x, a.x, 0.0, a.y, b.y, 0.0, a.z, b.z, 1.0)\n        }\n\n        fun from(a: Vec3, b: Vec3, c: Vec3): Matrix3 {\n            return Matrix3(a.x, b.x, c.x, a.y, b.y, c.y, a.z, b.z, c.z)\n        }\n\n        fun translate(x: Double, y: Double): Matrix3 {\n            return Matrix3(\n                1.0, 0.0, x,\n                0.0, 1.0, y,\n                0.0, 0.0, 1.0\n            )\n        }\n\n        fun translate(v: Vec2): Matrix3 {\n            return translate(v.x, v.y)\n        }\n\n        fun scale(x: Double, y: Double): Matrix3 {\n            return Matrix3(x, 0.0, 0.0, 0.0, y, 0.0, 0.0, 0.0, 1.0)\n        }\n\n        fun scale(v: Vec2): Matrix3 {\n            return scale(v.x, v.y)\n        }\n\n        fun scale(k: Double): Matrix3 {\n            return scale(k, k)\n        }\n\n        fun rotate(radians: Double): Matrix3 {\n            val c: Double = cos(radians)\n            val s: Double = sin(radians)\n            return Matrix3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0)\n        }\n\n        fun mul(vararg matrices: Matrix3): Matrix3 {\n            var m = matrices[0]\n            for (i in 1 until matrices.size) {\n                m = m.mul(matrices[i])\n            }\n            return m\n        }\n    }\n}","package org.openrndr.kartifex\n\nimport kotlin.math.cos\nimport kotlin.math.sin\n\n\n/**\n *\n */\nclass Matrix4 {\n    private val elements: DoubleArray\n\n    internal constructor(\n        m00: Double, m01: Double, m02: Double, m03: Double,\n        m10: Double, m11: Double, m12: Double, m13: Double,\n        m20: Double, m21: Double, m22: Double, m23: Double,\n        m30: Double, m31: Double, m32: Double, m33: Double\n    ) {\n        elements = doubleArrayOf(\n            m00, m01, m02, m03,\n            m10, m11, m12, m13,\n            m20, m21, m22, m23,\n            m30, m31, m32, m33\n        )\n    }\n\n    private constructor(elements: DoubleArray) {\n        this.elements = elements\n    }\n\n    fun mul(k: Double): Matrix4 {\n        val es = DoubleArray(16)\n        for (i in 0..15) {\n            es[i] = elements[i] * k\n        }\n        return Matrix4(es)\n    }\n\n    operator fun get(row: Int, column: Int): Double {\n        return elements[(row shl 2) + column]\n    }\n\n    fun row(row: Int): Vec4 {\n        val idx = row shl 2\n        return Vec4(elements[idx], elements[idx + 1], elements[idx + 2], elements[idx + 3])\n    }\n\n    fun column(column: Int): Vec4 {\n        return Vec4(\n            elements[column], elements[column + 4],\n            elements[column + 8], elements[column + 12]\n        )\n    }\n\n    fun mul(b: Matrix4): Matrix4 {\n        val es = DoubleArray(16)\n        for (i in 0..3) {\n            for (j in 0..3) {\n                var n = 0.0\n                for (k in 0..3) {\n                    n += b[k, j] * get(i, k)\n                }\n                es[(i shl 2) + j] = n\n            }\n        }\n        return Matrix4(es)\n    }\n\n    fun add(b: Matrix4): Matrix4 {\n        val es = DoubleArray(16)\n        for (i in 0..15) {\n            es[i] = elements[i] + b.elements[i]\n        }\n        return Matrix4(es)\n    }\n\n    fun transpose(): Matrix4 {\n        return Matrix4(\n            elements[0], elements[4], elements[8], elements[12],\n            elements[1], elements[5], elements[9], elements[13],\n            elements[2], elements[6], elements[10], elements[14],\n            elements[3], elements[7], elements[11], elements[15]\n        )\n    }\n\n    fun transform(v: Vec3): Vec3 {\n        return Vec3(\n            v.x * elements[0] + v.y * elements[1] + v.z * elements[2] + elements[3],\n            v.x * elements[4] + v.y * elements[5] + v.z * elements[6] + elements[7],\n            v.x * elements[8] + v.y * elements[9] + v.z * elements[10] + elements[11]\n        )\n    }\n\n    /*\n    fun rowMajor(): java.util.PrimitiveIterator.OfDouble {\n        return object : java.util.PrimitiveIterator.OfDouble() {\n            var idx = 0\n            override operator fun hasNext(): Boolean {\n                return idx < 16\n            }\n\n            override fun nextDouble(): Double {\n                return if (idx < 16) {\n                    elements[idx++]\n                } else {\n                    throw NoSuchElementException()\n                }\n            }\n        }\n    }\n\n    fun columnMajor(): java.util.PrimitiveIterator.OfDouble {\n        return transpose().rowMajor()\n    }\n*/\n    /*\n    override fun hashCode(): Int {\n        var hash = 0\n        for (n in elements) {\n            hash = hash * 31 + Hashes.hash(n)\n        }\n        return hash\n    }\n\n    override fun equals(obj: Any?): Boolean {\n        return if (this === obj) {\n            true\n        } else if (obj is Matrix4) {\n            java.util.Arrays.equals(elements, obj.elements)\n        } else {\n            false\n        }\n    }\n    */\n\n\n    /*\n    override fun toString(): String {\n        val s = StringBuffer()\n        rowMajor().forEachRemaining(DoubleConsumer { n: Double -> s.append(n).append(\", \") })\n        return s.toString()\n    }\n*/\n    companion object {\n        val IDENTITY = Matrix4(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        )\n\n        fun from(a: Vec3, b: Vec3, c: Vec3): Matrix4 {\n            return Matrix4(a.x, b.x, c.x, 0.0, a.y, b.y, c.y, 0.0, a.z, b.z, c.z, 0.0, 0.0, 0.0, 0.0, 1.0)\n        }\n\n        fun from(\n            a: Vec4,\n            b: Vec4,\n            c: Vec4,\n            d: Vec4\n        ): Matrix4 {\n            return Matrix4(a.x, b.x, c.x, d.x, a.y, b.y, c.y, d.y, a.z, b.z, c.z, d.z, a.w, b.w, c.w, d.w)\n        }\n\n        fun translate(x: Double, y: Double, z: Double): Matrix4 {\n            return Matrix4(\n                1.0, 0.0, 0.0, x,\n                0.0, 1.0, 0.0, y,\n                0.0, 0.0, 1.0, z,\n                0.0, 0.0, 0.0, 1.0\n            )\n        }\n\n        fun translate(v: Vec3): Matrix4 {\n            return translate(v.x, v.y, v.z)\n        }\n\n        fun scale(x: Double, y: Double, z: Double): Matrix4 {\n            return Matrix4(\n                x, 0.0, 0.0, 0.0,\n                0.0, y, 0.0, 0.0,\n                0.0, 0.0, z, 0.0,\n                0.0, 0.0, 0.0, 1.0\n            )\n        }\n\n        fun scale(v: Vec3): Matrix4 {\n            return scale(v.x, v.y, v.z)\n        }\n\n        fun scale(k: Double): Matrix4 {\n            return scale(k, k, k)\n        }\n\n        fun rotateX(radians: Double): Matrix4 {\n            val c: Double = cos(radians)\n            val s: Double = sin(radians)\n            return Matrix4(\n                1.0, 0.0, 0.0, 0.0,\n                0.0, c, -s, 0.0,\n                0.0, s, c, 0.0,\n                0.0, 0.0, 0.0, 1.0\n            )\n        }\n\n        fun rotateY(radians: Double): Matrix4 {\n            val c: Double = cos(radians)\n            val s: Double = sin(radians)\n            return Matrix4(\n                c, 0.0, s, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                -s, 0.0, c, 0.0,\n                0.0, 0.0, 0.0, 1.0,\n            )\n        }\n\n        fun rotateZ(radians: Double): Matrix4 {\n            val c: Double = cos(radians)\n            val s: Double = sin(radians)\n            return Matrix4(\n                c, -s, 0.0, 0.0,\n                s, c, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0\n            )\n        }\n\n        fun mul(vararg matrices: Matrix4): Matrix4 {\n            var m = matrices[0]\n            for (i in 1 until matrices.size) {\n                m = m.mul(matrices[i])\n            }\n            return m\n        }\n    }\n}\n","package org.openrndr.kartifex\n\ntypealias DoubleUnaryOperator = (Double) -> Double\ntypealias DoublePredicate = (Double) -> Boolean\ntypealias DoubleBinaryOperator = (Double, Double) -> Double\n\nfun signum(d: Double): Double {\n    return if (d == 0.0 || d.isNaN()) d else if (d < 0) -1.0 else 1.0\n}","package org.openrndr.kartifex\n\nimport org.openrndr.kartifex.utils.Scalars\n\n\nclass Path2 {\n    private val curves: Array<Curve2>\n    private val bounds: Box2\n    val isRing: Boolean\n\n    internal constructor(ring: Ring2) {\n        curves = ring.curves\n        bounds = ring.bounds\n        isRing = true\n    }\n\n    constructor(cs: Iterable<Curve2>) {\n        val l = ArrayDeque<Curve2>()\n        var bounds = Box2.EMPTY\n        for (a in cs) {\n            for (b in a.split(a.inflections())) {\n                l.addLast(b)\n                bounds = bounds.union(b.start()).union(b.end())\n            }\n        }\n        this.bounds = bounds\n        isRing = Vec.equals(l.first().start(), l.last().end(), Scalars.EPSILON)\n        curves = l.toTypedArray()\n        for (i in 0 until curves.size - 1) {\n            curves[i] = curves[i].endpoints(curves[i].start(), curves[i + 1].start())\n        }\n        if (isRing) {\n            val lastIdx = curves.size - 1\n            curves[lastIdx] = curves[lastIdx].endpoints(curves[lastIdx].start(), curves[0].start())\n        }\n    }\n\n    fun reverse() = Path2(curves.map {\n        it.reverse()\n    }.reversed())\n\n    fun curves(): Array<Curve2> = curves\n\n    fun bounds(): Box2 = bounds\n\n    fun vertices(error: Double): Iterable<Vec2> {\n        val result = mutableListOf<Vec2>()\n        for (c in curves) {\n            val segments = c.subdivide(error)\n            if (result.isEmpty()) {\n                result.addAll(segments)\n            } else {\n                val t1 = result[result.size - 1].sub(result[result.size - 2]).norm()\n                val t2 = segments[1].sub(segments[0]).norm()\n                if (Vec.equals(t1, t2, Scalars.EPSILON)) {\n                    result.removeAt(result.size - 1)\n                }\n                for (i in 1 until segments.size) {\n                    result.add(segments[i])\n                }\n            }\n        }\n        return result\n    }\n\n    companion object {\n        fun of(vararg curves: Curve2) = Path2(curves.toList())\n\n        fun linear(vararg vertices: Vec2): Path2 {\n            val segments = mutableListOf<Curve2>()\n            for (i in 0 until vertices.size - 1) {\n                val a = vertices[i]\n                val b = vertices[i + 1]\n                if (!Vec.equals(a, b, Scalars.EPSILON)) {\n                    segments.add(Line2.line(vertices[i], vertices[i + 1]))\n                }\n            }\n            return Path2(segments)\n        }\n    }\n}\n","package org.openrndr.kartifex\n\nimport kotlin.math.cos\nimport kotlin.math.sin\n\nclass Polar2(val theta: Double, val r: Double) {\n    fun rotate(theta: Double) = Polar2(this.theta + theta, r)\n\n    fun vec2(): Vec2 {\n        val x = cos(theta)\n        val y = sin(theta)\n        return Vec2(x * r, y * r)\n    }\n}\n","package org.openrndr.kartifex\n\nimport org.openrndr.kartifex.utils.regions.Clip\n\nclass Region2(val rings: Array<Ring2>) {\n    val bounds: Box2\n\n    constructor(rings: Iterable<Ring2>) : this(\n        rings.toList().toTypedArray()\n    )\n\n    fun test(p: Vec2): Ring2.Result {\n        for (r in rings) {\n            val result: Ring2.Result = r.test(p)\n            if (result.inside) {\n                return if (result.curve == null && r.isClockwise) Ring2.Result.OUTSIDE else result\n            }\n        }\n        return Ring2.Result.OUTSIDE\n    }\n\n    operator fun contains(p: Vec2): Boolean {\n        return test(p).inside\n    }\n\n    /// transforms and set operations\n    fun transform(m: Matrix3): Region2 {\n        return Region2(\n            rings\n                .map { r: Ring2 ->\n                    r.transform(\n                        m\n                    )\n                }.toTypedArray()\n        )\n    }\n\n    fun intersection(region: Region2): Region2 {\n        return Clip.intersection(this, region)\n    }\n\n    fun union(region: Region2): Region2 {\n        return Clip.union(this, region)\n    }\n\n    fun difference(region: Region2): Region2 {\n        return Clip.difference(this, region)\n    }\n\n    companion object {\n        fun of(vararg rings: Ring2): Region2 {\n            return Region2(rings.toList())\n        }\n    }\n\n    init {\n        rings.sortBy { it.area }\n\n        bounds = rings.\n            map { r: Ring2 -> r.bounds }\n            .fold(Box2.EMPTY) { obj, b -> obj.union(b) }\n    }\n}\n","package org.openrndr.kartifex\n\nimport org.openrndr.kartifex.utils.Intersections\nimport kotlin.math.abs\nimport kotlin.math.sqrt\n\n\nclass Ring2 {\n    class Result private constructor(val inside: Boolean, curve: Curve2?) {\n        val curve: Curve2? = curve\n\n        constructor(curve: Curve2) : this(true, curve) {}\n\n        override fun toString(): String {\n            return if (inside) {\n                if (curve == null) \"INSIDE\" else \"EDGE: $curve\"\n            } else {\n                \"OUTSIDE\"\n            }\n        }\n\n        companion object {\n            val INSIDE: Ring2.Result = Ring2.Result(true, null)\n            val OUTSIDE: Ring2.Result = Ring2.Result(false, null)\n        }\n    }\n\n    val curves: Array<Curve2>\n    val bounds: Box2\n    val isClockwise: Boolean\n    val area: Double\n\n    private constructor(\n        curves: Array<Curve2>,\n        bounds: Box2,\n        isClockwise: Boolean,\n        area: Double\n    ) {\n        this.curves = curves\n        this.bounds = bounds\n        this.isClockwise = isClockwise\n        this.area = area\n    }\n\n    constructor(cs: Iterable<Curve2>) {\n        // TODO: dedupe collinear adjacent lines\n        var bounds: Box2 = Box2.EMPTY\n        var signedArea = 0.0\n        val list: ArrayDeque<Curve2> = ArrayDeque()\n        for (a in cs) {\n            for (b in a.split(a.inflections())) {\n                list.addLast(b)\n                bounds = bounds.union(b.start()).union(b.end())\n                signedArea += b.signedArea()\n            }\n        }\n        isClockwise = signedArea < 0\n        area = abs(signedArea)\n        this.bounds = bounds\n        curves = list.toTypedArray()\n        for (i in 0 until curves.size - 1) {\n            curves[i] = curves[i].endpoints(curves[i].start(), curves[i + 1].start())\n        }\n        val lastIdx = curves.size - 1\n        curves[lastIdx] = curves[lastIdx].endpoints(curves[lastIdx].start(), curves[0].start())\n    }\n\n    fun region(): Region2 {\n        return Region2(listOf(this))\n    }\n\n    fun path(): Path2 {\n        return Path2(this)\n    }\n\n//    fun reverse(): Ring2 {\n//        return Ring2(\n//            LinearList.from<Curve2>(\n//                io.lacuna.bifurcan.Lists.reverse<Curve2>(\n//                    io.lacuna.bifurcan.Lists.lazyMap<Curve2, Curve2>(io.lacuna.bifurcan.Lists.from<Curve2>(\n//                        curves\n//                    ),\n//                        java.util.function.Function<Curve2, Curve2> { obj: Curve2 -> obj.reverse() })\n//                )\n//            ).toArray(\n//                IntFunction<Array<Curve2>> { _Dummy_.__Array__() }),\n//            bounds,\n//            !isClockwise,\n//            area\n//        )\n//    }\n\n    fun test(p: Vec2): Ring2.Result {\n        if (!bounds.expand(Intersections.SPATIAL_EPSILON).contains(p)) {\n            return Ring2.Result.Companion.OUTSIDE\n        }\n        val ray: Line2 = Line2.line(p, Vec2(bounds.ux + 1, p.y))\n        var count = 0\n\n        // since our curves have been split at inflection points, there can only\n        // be a single ray/curve intersection unless the curve is collinear\n        for (c in curves) {\n            val b: Box2 = c.bounds()\n            val flat = b.height() == 0.0\n\n            //System.out.println(p + \" \" + b + \" \" + c);\n\n            // it's to our right\n            if (p.x < b.lx) {\n                // check if we intersect within [bottom, top)\n                if (p.y >= b.ly && p.y < b.uy) {\n                    //System.out.println(\"right, incrementing\");\n                    count++\n                }\n\n                // we're inside the bounding box\n            } else if (b.expand(Vec2(Intersections.SPATIAL_EPSILON, 0.0))\n                    .contains(p)\n            ) {\n                val i: Vec2? =\n                    Intersections.lineCurve(ray, c)\n                        .map { v: Vec2 ->\n                            v.map { n: Double ->\n                                Intersections.round(\n                                    n,\n                                    Intersections.PARAMETRIC_EPSILON\n                                )\n                            }\n                        }\n                        .filter { v ->  Intersections.PARAMETRIC_BOUNDS.contains(v) }\n                        .minByOrNull { v: Vec2 -> v.x }\n\n                if (i != null) {\n                    //System.out.println(i);\n                    if (i.x == 0.0) {\n                        return Ring2.Result(c)\n                    } else if (!flat && p.y < b.uy) {\n                        //System.out.println(\"intersected, incrementing\");\n                        count++\n                    }\n                } else {\n                    //System.out.println(\"no intersection\");\n                }\n            }\n        }\n\n        //System.out.println(count);\n        return if (count % 2 == 1) Ring2.Result.Companion.INSIDE else Ring2.Result.Companion.OUTSIDE\n    }\n\n    fun transform(m: Matrix3): Ring2 = Ring2(curves.map { c -> c.transform(m) })\n\n    companion object {\n        fun of(vararg cs: Curve2): Ring2 {\n            return Ring2(cs.toList())\n        }\n\n        /**\n         * @return a unit square from [0, 0] to [1, 1]\n         */\n        fun square(): Ring2 {\n            return Box.box(Vec2(0.0, 0.0), Vec2(1.0, 1.0))\n                .outline()\n        }\n\n        /**\n         * @return a unit circle with radius of 1, centered at [0, 0]\n         */\n        fun circle(): Ring2 {\n            // taken from http://whizkidtech.redprince.net/bezier/circle/kappa/\n            val k: Double = 4.0 / 3.0 * (sqrt(2.0) - 1)\n            return Ring2.Companion.of(\n                Bezier2.curve(\n                    Vec2(1.0, 0.0),\n                    Vec2(1.0, k),\n                    Vec2(k, 1.0),\n                    Vec2(0.0, 1.0)\n                ),\n                Bezier2.curve(\n                    Vec2(0.0, 1.0),\n                    Vec2(-k, 1.0),\n                    Vec2(-1.0, k),\n                    Vec2(-1.0, 0.0)\n                ),\n                Bezier2.curve(\n                    Vec2(-1.0, 0.0),\n                    Vec2(-1.0, -k),\n                    Vec2(-k, -1.0),\n                    Vec2(0.0, -1.0)\n                ),\n                Bezier2.curve(\n                    Vec2(0.0, -1.0),\n                    Vec2(k, -1.0),\n                    Vec2(1.0, -k),\n                    Vec2(1.0, 0.0)\n                )\n            )\n        }\n    }\n}","package org.openrndr.kartifex\n\nimport org.openrndr.utils.Hashes\nimport kotlin.math.PI\nimport kotlin.math.atan2\nimport kotlin.math.cos\nimport kotlin.math.sin\n\nclass Vec2(val x: Double, val y: Double) : Vec<Vec2> {\n\n\n    override fun map(f: DoubleUnaryOperator): Vec2 {\n        return Vec2(f(x), f(y))\n    }\n\n    override fun reduce(f: DoubleBinaryOperator, init: Double): Double {\n        return f(f(x, y), init)\n    }\n\n    override fun reduce(f: DoubleBinaryOperator): Double {\n        return f(x, y)\n    }\n\n    override fun zip(v: Vec2, f: DoubleBinaryOperator): Vec2 {\n        return Vec2(f(x, v.x), f(y, v.y))\n    }\n\n    override fun every(f: DoublePredicate): Boolean {\n        return f(x) && f(y)\n    }\n\n    override fun any(f: DoublePredicate): Boolean {\n        return f(x) || f(y)\n    }\n\n    override fun nth(idx: Int): Double {\n        return when (idx) {\n            0 -> x\n            1 -> y\n            else -> throw IndexOutOfBoundsException()\n        }\n    }\n\n    override fun dim(): Int {\n        return 2\n    }\n\n    override fun array(): DoubleArray {\n        return doubleArrayOf(x, y)\n    }\n\n    fun add(x: Double, y: Double): Vec2 {\n        return Vec2(this.x + x, this.y + y)\n    }\n\n    fun sub(x: Double, y: Double): Vec2 {\n        return Vec2(this.x - x, this.y - y)\n    }\n\n    fun swap(): Vec2 {\n        return Vec2(y, x)\n    }\n\n    fun vec3(z: Double): Vec3 {\n        return Vec3(x, y, z)\n    }\n\n    fun vec4(z: Double, w: Double): Vec4 {\n        return Vec4(x, y, z, w)\n    }\n\n    fun vec4(v: Vec2): Vec4 {\n        return Vec4(x, y, v.x, v.y)\n    }\n\n    fun transform(m: Matrix3): Vec2 {\n        return m.transform(this)\n    }\n\n    /**\n     * @return a rotated vector\n     */\n    fun rotate(radians: Double): Vec2 {\n        val s: Double = sin(radians)\n        val c: Double = cos(radians)\n        return Vec2(c * x + -s * y, s * x + c * y)\n    }\n\n    fun polar2(): Polar2 {\n        return Polar2(atan2(y, x), length())\n    }\n\n    override fun hashCode(): Int {\n        return Hashes.hash(x, y)\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (other is Vec2) {\n            val v = other\n            return v.x == x && v.y == y\n        }\n        return false\n    }\n\n    override operator fun compareTo(other: Vec2): Int {\n        return COMPARATOR.compare(this, other)\n    }\n\n    override fun add(v: Vec2): Vec2 {\n        return Vec2(x + v.x, y + v.y)\n    }\n\n    override fun add(n: Double): Vec2 {\n        return Vec2(x + n, y + n)\n    }\n\n    override fun negate(): Vec2 {\n        return Vec2(-x, -y)\n    }\n\n    override fun sub(v: Vec2): Vec2 {\n        return Vec2(x - v.x, y - v.y)\n    }\n\n    override fun sub(n: Double): Vec2 {\n        return Vec2(x - n, y - n)\n    }\n\n    override fun mul(v: Vec2): Vec2 {\n        return Vec2(x * v.x, y * v.y)\n    }\n\n    override fun mul(k: Double): Vec2 {\n        return Vec2(x * k, y * k)\n    }\n\n    override operator fun div(v: Vec2): Vec2 {\n        return Vec2(x / v.x, y / v.y)\n    }\n\n    override fun toString(): String {\n        return \"Vec2(x=$x, y=$y)\"\n    }\n\n    companion object {\n        val COMPARATOR = compareBy<Vec2>({ v -> v.x }, { v -> v.y })\n\n        val ORIGIN = Vec2(0.0, 0.0)\n        val X_AXIS = Vec2(1.0, 0.0)\n        val Y_AXIS = Vec2(0.0, 1.0)\n\n        fun cross(a: Vec2, b: Vec2): Double {\n            return a.x * b.y - a.y * b.x\n        }\n\n        /**\n         * @return the clockwise angle between the two vectors\n         */\n        fun angleBetween(oa: Vec2, ob: Vec2): Double {\n\n            val a = oa.pseudoNorm()\n            val b = ob.pseudoNorm()\n\n            // from section 12 of https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf\n            var theta: Double = atan2(cross(a, b), Vec.dot(a, b))\n            if (theta > 0) {\n                theta -= PI * 2\n            }\n            return theta\n        }\n\n        /**\n         * @return whether `b` sits between the vectors `a` and `b`\n         */\n        fun between(a: Vec2, b: Vec2, c: Vec2): Boolean {\n            return cross(a, b) * cross(c, b) < 0\n        }\n    }\n}","package org.openrndr.kartifex\n\nimport org.openrndr.utils.Hashes\n\nclass Vec3(val x: Double, val y: Double, val z: Double) : Vec<Vec3> {\n    override fun map(f: DoubleUnaryOperator): Vec3 {\n        return Vec3(f(x), f(y), f(z))\n    }\n\n    override fun reduce(f: DoubleBinaryOperator, init: Double): Double {\n        return f(f(init, x), f(y, z))\n    }\n\n    override fun reduce(f: DoubleBinaryOperator): Double {\n        return f(f(x, y), z)\n    }\n\n    override fun zip(v: Vec3, f: DoubleBinaryOperator): Vec3 {\n        return Vec3(f(x, v.x), f(y, v.y), f(z, v.z))\n    }\n\n    override fun every(f: DoublePredicate): Boolean {\n        return f(x) && f(y) && f(z)\n    }\n\n    override fun any(f: DoublePredicate): Boolean {\n        return f(x) || f(y) || f(z)\n    }\n\n    override fun nth(idx: Int): Double {\n        return when (idx) {\n            0 -> x\n            1 -> y\n            2 -> z\n            else -> throw IndexOutOfBoundsException()\n        }\n    }\n\n    override fun dim(): Int {\n        return 3\n    }\n\n    override fun array(): DoubleArray {\n        return doubleArrayOf(x, y, z)\n    }\n\n    fun vec2(): Vec2 {\n        return Vec2(x, y)\n    }\n\n    fun vec4(w: Double): Vec4 {\n        return Vec4(x, y, z, w)\n    }\n\n    override fun hashCode(): Int {\n        return Hashes.hash(x, y, z)\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (other is Vec3) {\n            val v = other\n            return v.x == x && v.y == y && v.z == z\n        }\n        return false\n    }\n\n    override fun toString(): String {\n        return \"[x=$x, y=$y, z=$z]\"\n    }\n\n    override operator fun compareTo(other: Vec3): Int {\n        return COMPARATOR.compare(this, other)\n    }\n\n    companion object {\n        val ORIGIN = Vec3(0.0, 0.0, 0.0)\n        val X_AXIS = Vec3(1.0, 0.0, 0.0)\n        val Y_AXIS = Vec3(0.0, 1.0, 0.0)\n        val Z_AXIS = Vec3(0.0, 0.0, 1.0)\n        val COMPARATOR = compareBy<Vec3>({ v -> v.x }, { v -> v.y }, { v -> v.z })\n        fun cross(a: Vec3, b: Vec3): Vec3 {\n            return Vec3(\n                a.y * b.z - a.z * b.y,\n                a.x * b.x - a.x * b.z,\n                a.x * b.y - a.y * b.x\n            )\n        }\n    }\n}","package org.openrndr.kartifex\n\nimport org.openrndr.utils.Hashes\n\nclass Vec4(val x: Double, val y: Double, val z: Double, val w: Double) :\n    Vec<Vec4> {\n    override fun map(f: DoubleUnaryOperator): Vec4 {\n        return Vec4(f(x), f(y), f(z), f(w))\n    }\n\n    override fun reduce(f: DoubleBinaryOperator, init: Double): Double {\n        return f(f(f(f(init, x), y), z), w)\n    }\n\n    override fun reduce(f: DoubleBinaryOperator): Double {\n        return f(f(f(x, y), z), w)\n    }\n\n    override fun zip(v: Vec4, f: DoubleBinaryOperator): Vec4 {\n        return Vec4(f(x, v.x), f(y, v.y), f(z, v.z), f(w, v.w))\n    }\n\n    override fun every(f: DoublePredicate): Boolean {\n        return f(x) && f(y) && f(z) && f(w)\n    }\n\n    override fun any(f: DoublePredicate): Boolean {\n        return f(x) || f(y) || f(z) || f(w)\n    }\n\n    override fun nth(idx: Int): Double {\n        return when (idx) {\n            0 -> x\n            1 -> y\n            2 -> z\n            3 -> w\n            else -> throw IndexOutOfBoundsException()\n        }\n    }\n\n    override fun dim(): Int {\n        return 4\n    }\n\n    override fun array(): DoubleArray {\n        return doubleArrayOf(x, y, z, w)\n    }\n\n    fun vec3(): Vec3 {\n        return Vec3(x, y, z)\n    }\n\n    fun vec2(): Vec2 {\n        return Vec2(x, y)\n    }\n\n    override fun hashCode(): Int {\n        return Hashes.hash(x, y, z, w)\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (other is Vec4) {\n            val v = other\n            return v.x == x && v.y == y && v.z == z && v.w == w\n        }\n        return false\n    }\n\n    override fun toString(): String {\n        return \"[x=$x, y=$y, z=$z, w=$w]\"\n    }\n\n    override operator fun compareTo(other: Vec4): Int {\n        return COMPARATOR.compare(this, other)\n    }\n\n    companion object {\n        val ORIGIN = Vec4(0.0, 0.0, 0.0, 0.0)\n        val X_AXIS = Vec4(1.0, 0.0, 0.0, 0.0)\n        val Y_AXIS = Vec4(0.0, 1.0, 0.0, 0.0)\n        val Z_AXIS = Vec4(0.0, 0.0, 1.0, 0.0)\n        val W_AXIS = Vec4(0.0, 0.0, 0.0, 1.0)\n        val COMPARATOR = compareBy<Vec4>({ v -> v.x }, { v -> v.y }, { v -> v.z }, { v -> v.w })\n    }\n}","package org.openrndr.kartifex.utils\n\nobject Combinatorics {\n    val MAX_RESULTS = 32\n    inline fun <reified V> permutations(values: List<V>): List<List<V>> {\n        // if exhaustive searching is out of the question, put your trust in the RNG\n        if (values.size > 4) {\n            List(MAX_RESULTS) {\n                values.shuffled()\n            }\n        }\n        val result: MutableList<List<V>> = mutableListOf()\n        val ary: Array<V> = values.toTypedArray()\n        val c = IntArray(ary.size)\n        var i = 0\n        result.add(values)\n        while (i < ary.size) {\n            if (c[i] < i) {\n                swap(ary, if (i % 2 == 0) 0 else c[i], i)\n                result.add(ary.toList())\n                c[i]++\n                i = 0\n            } else {\n                c[i] = 0\n                i++\n            }\n        }\n        return result\n    }\n\n    fun <V> swap(ary: Array<V>, i: Int, j: Int) {\n        val tmp = ary[i]\n        ary[i] = ary[j]\n        ary[j] = tmp\n    }\n\n\n    /**\n     * Given a list of potential values at each index in a list, returns all possible combinations of those values.\n     */\n    fun <V> combinations(paths: List<List<V>>): List<List<V>> {\n        val count = paths.map { obj -> obj.size }\n            .fold(1) { a, b -> a * b }\n        if (count == 0) {\n            return emptyList()\n        } else if (count == 1) {\n            return listOf(paths\n                .map { obj -> obj.first() }\n            )\n        } else if (count > MAX_RESULTS) {\n            return (0 until MAX_RESULTS)\n                .map { _ ->\n                    paths\n                        .map { list ->\n                            list.random()\n                        }\n                }\n        }\n        val indices = IntArray(paths.size)\n        val result = mutableListOf<List<V>>()\n        while (indices[0] < paths.first().size) {\n            val path = mutableListOf<V>()\n            for (i in indices.indices) {\n                path.add(paths[i][indices[i]])\n            }\n            result.add(path)\n            for (i in indices.indices.reversed()) {\n                if (++indices[i] < paths[i].size) {\n                    break\n                } else if (i > 0) {\n                    indices[i] = 0\n                }\n            }\n        }\n        return result\n    }\n\n}","package utils\n\nclass DoubleAccumulator {\n    private var values = DoubleArray(2)\n    private var index = 0\n    private fun expand() {\n        val values = DoubleArray(values.size shl 1)\n        //System.arraycopy(this.values, 0, values, 0, this.values.size)\n        this.values.copyInto(values, 0)\n\n        this.values = values\n    }\n\n    fun add(ns: DoubleArray): DoubleAccumulator {\n        while (index > values.size - ns.size) {\n            expand()\n        }\n        //java.lang.System.arraycopy(ns, 0, values, index, ns.size)\n        ns.copyInto(values, index, 0, ns.size)\n\n        index += ns.size\n        return this\n    }\n\n    fun add(n: Double): DoubleAccumulator {\n        if (index > values.size - 1) {\n            expand()\n        }\n        values[index++] = n\n        return this\n    }\n\n    fun add(a: Double, b: Double): DoubleAccumulator {\n        if (index > values.size - 2) {\n            expand()\n        }\n        values[index++] = a\n        values[index++] = b\n        return this\n    }\n\n    fun pop(num: Int) {\n        index -= num\n    }\n\n    fun clear() {\n        index = 0\n    }\n\n    fun size(): Int {\n        return index\n    }\n\n    operator fun get(index: Int): Double {\n        return values[index]\n    }\n\n    fun last(): Double {\n        return values[index - 1]\n    }\n\n    operator fun set(index: Int, n: Double) {\n        values[index] = n\n    }\n\n    fun toArray(): DoubleArray {\n        val result = DoubleArray(size())\n        values.copyInto(result, 0, 0, size())\n        return result\n    }\n\n    override fun toString(): String {\n        val b = StringBuilder()\n        b.append(\"[\")\n        for (i in 0 until index) {\n            if (i != 0) {\n                b.append(\", \")\n            }\n            b.append(values[i])\n        }\n        b.append(\"]\")\n        return b.toString()\n    }\n}\n","package org.openrndr.kartifex.utils\n\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\nobject Equations {\n    private const val DISCRIMINANT_EPSILON = 1e-10\n    private const val SOLUTION_EPSILON = 1e-8\n\n    // adapted from https://github.com/paperjs/paper.js/blob/develop/src/util/Numerical.js\n    private fun trim(acc: DoubleArray, len: Int): DoubleArray {\n        return if (len == acc.size) {\n            acc\n        } else if (len == 0) {\n            DoubleArray(0)\n        } else {\n            val result = DoubleArray(len)\n            //java.lang.System.arraycopy(acc, 0, result, 0, len)\n            acc.copyInto(result, 0, 0, len)\n            result\n        }\n    }\n\n    private fun split(n: Double): DoubleArray {\n        val x = n * 134217729\n        val y = n - x\n        val hi = y + x\n        val lo = n - hi\n        return doubleArrayOf(hi, lo)\n    }\n\n    private fun discriminant(a: Double, b: Double, c: Double): Double {\n        var D = b * b - a * c\n        val E = b * b + a * c\n        if (abs(D) * 3 < E) {\n            val ad = split(a)\n            val bd = split(b)\n            val cd = split(c)\n            val p = b * b\n            val dp = bd[0] * bd[0] - p + 2 * bd[0] * bd[1] + bd[1] * bd[1]\n            val q = a * c\n            val dq = ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0] + ad[1] * cd[1]\n            D = p - q + (dp - dq)\n        }\n        return D\n    }\n\n    fun solveLinear(a: Double, b: Double, acc: DoubleArray): Int {\n        return if (abs(a) < Scalars.EPSILON) {\n            0\n        } else {\n            acc[0] = -b / a\n            1\n        }\n    }\n\n    fun solveLinear(a: Double, b: Double): DoubleArray {\n        val acc = DoubleArray(1)\n        return trim(acc, solveLinear(a, b, acc))\n    }\n\n    @Suppress(\"NAME_SHADOWING\")\n    fun solveQuadratic(a: Double, b: Double, c: Double, acc: DoubleArray): Int {\n        var a = a\n        var b = b\n        var c = c\n        if (abs(a) < Scalars.EPSILON) {\n            return solveLinear(b, c, acc)\n        }\n        b *= -0.5\n        val k = Scalars.normalizationFactor(a, b, c)\n        a *= k\n        b *= k\n        c *= k\n        val D = discriminant(a, b, c)\n        return if (D >= -DISCRIMINANT_EPSILON) {\n            val Q: Double = if (D < 0) 0.0 else sqrt(D)\n            val R = b + if (b < 0) -Q else Q\n            if (R == 0.0) {\n                acc[0] = c / a\n                acc[1] = -c / a\n            } else {\n                acc[0] = R / a\n                acc[1] = c / R\n            }\n            var writeIdx = 0\n            for (readIdx in 0..1) {\n                val x = acc[readIdx]\n\n                // since the tolerance for the discriminant is fairly large, we check our work\n                val y = a * x * x + -2 * b * x + c\n                if (abs(y) < SOLUTION_EPSILON) {\n                    acc[writeIdx++] = x\n                }\n            }\n            writeIdx\n        } else {\n            0\n        }\n    }\n\n    fun solveQuadratic(a: Double, b: Double, c: Double): DoubleArray {\n        val acc = DoubleArray(2)\n        return trim(acc, solveQuadratic(a, b, c, acc))\n    }\n\n    @Suppress(\"NAME_SHADOWING\")\n    fun solveCubic(a: Double, b: Double, c: Double, d: Double, acc: DoubleArray): Int {\n        var a = a\n        var b = b\n        var c = c\n        var d = d\n        val k = Scalars.normalizationFactor(a, b, c, d)\n        a *= k\n        b *= k\n        c *= k\n        d *= k\n        var x: Double\n        var b1: Double\n        var c2: Double\n        var qd: Double\n        var q: Double\n        if (abs(a) < Scalars.EPSILON) {\n            return solveQuadratic(b, c, d, acc)\n        } else if (abs(d) < Scalars.EPSILON) {\n            b1 = b\n            c2 = c\n            x = 0.0\n        } else {\n            x = -(b / a) / 3\n            b1 = a * x + b\n            c2 = b1 * x + c\n            qd = (a * x + b1) * x + c2\n            q = c2 * x + d\n            val t = q / a\n            val r: Double = abs(t).pow(1 / 3.0)\n            val s: Double = if (t < 0) -1.0 else 1.0\n            val td = -qd / a\n            val rd = if (td > 0) 1.324717957244746 * max(r, sqrt(td)) else r\n            var x0 = x - s * rd\n            if (x0 != x) {\n                do {\n                    x = x0\n                    b1 = a * x + b\n                    c2 = b1 * x + c\n                    qd = (a * x + b1) * x + c2\n                    q = c2 * x + d\n                    x0 = if (qd == 0.0) x else x - q / (qd / (1 + Scalars.MACHINE_EPSILON))\n                } while (s * x0 > s * x)\n                if (abs(a) * x * x > abs(d / x)) {\n                    c2 = -d / x\n                    b1 = (c2 - c) / x\n                }\n            }\n        }\n        var solutions = solveQuadratic(a, b1, c2, acc)\n        for (i in 0 until solutions) {\n            if (acc[i] == x) {\n                return solutions\n            }\n        }\n        val y = a * x * x * x + b * x * x + c * x + d\n        if (abs(y) < SOLUTION_EPSILON) {\n            acc[solutions++] = x\n        }\n        return solutions\n    }\n\n    fun solveCubic(a: Double, b: Double, c: Double, d: Double): DoubleArray {\n        val acc = DoubleArray(3)\n        return trim(acc, solveCubic(a, b, c, d, acc))\n    }\n}\n\n\n","package org.openrndr.kartifex.utils\n\nimport org.openrndr.kartifex.*\nimport kotlin.jvm.JvmName\nimport kotlin.math.*\n\n@JvmName(\"kartifexHackSort1\")\nfun <T> Array<T>.sort(start: Int = 0, end: Int = size, selector: (T) -> Double) {\n    if (start != 0 || end != size) {\n        val copy = copyOfRange(start, end)\n        copy.sortBy(selector)\n        copy.copyInto(this, start)\n    } else {\n        sortBy(selector)\n    }\n}\n\n@JvmName(\"kartifexHackSort2\")\nfun <T> sort(a: Array<T>, start: Int = 0, end: Int = a.size, selector: (T) -> Double) {\n    a.sort(start, end, selector)\n}\n\n\nobject Intersections {\n    // utilities\n    const val FAT_LINE_PARAMETRIC_RESOLUTION = 1e-5\n    const val FAT_LINE_SPATIAL_EPSILON = 1e-5\n\n    const val PARAMETRIC_EPSILON = 1e-5\n    const val SPATIAL_EPSILON = 1e-5\n\n    const val MAX_CUBIC_CUBIC_INTERSECTIONS = 9\n\n    val PARAMETRIC_BOUNDS: Box2 =\n        Box.box(Vec2(0.0, 0.0), Vec2(1.0, 1.0))\n\n    fun lineCurve(a: Line2, b: Curve2): Array<Vec2> {\n        return if (b is Line2) {\n            lineLine(a, b)\n        } else if (b.isFlat(SPATIAL_EPSILON)) {\n            lineLine(a, Line2.line(b.start(), b.end()))\n        } else if (b is Bezier2.QuadraticBezier2) {\n            lineQuadratic(a, b)\n        } else {\n            lineCubic(a, b as Bezier2.CubicBezier2)\n        }\n    }\n\n    fun lineLine(a: Line2, b: Line2): Array<Vec2> {\n        val av: Vec2 = a.end().sub(a.start())\n        val bv: Vec2 = b.end().sub(b.start())\n        val d: Double = Vec2.cross(av, bv)\n        if (abs(d) < 1e-6) {\n            val ints: Array<Vec2> = collinearIntersection(a, b)\n            if (ints.all { v: Vec2 ->\n                    Vec.equals(\n                        a.position(v.x),\n                        b.position(v.y),\n                        SPATIAL_EPSILON\n                    )\n                }\n            ) {\n                return ints\n            } else if (abs(d) == 0.0) {\n                return emptyArray()\n            }\n        }\n        val asb = a.start().sub(b.start())\n        val s = Vec2.cross(bv, asb) / d\n        val t = Vec2.cross(av, asb) / d\n        return arrayOf(Vec2(s, t))\n    }\n\n    fun lineQuadratic(\n        p: Line2,\n        q: Bezier2.QuadraticBezier2\n    ): Array<Vec2> {\n        // (p0 - 2p1 + p2) t^2 + (-2p0 + 2p1) t + p0\n        val a: Vec2 = q.p0.add(q.p1.mul(-2.0)).add(q.p2)\n        val b: Vec2 = q.p0.mul(-2.0).add(q.p1.mul(2.0))\n        val c: Vec2 = q.p0\n        val dir: Vec2 = p.end().sub(p.start())\n        val n = Vec2(-dir.y, dir.x)\n        val roots: DoubleArray = Equations.solveQuadratic(\n            Vec.dot(n, a),\n            Vec.dot(n, b),\n            Vec.dot(n, c) + Vec2.cross(p.start(), p.end())\n        )\n        val result: Array<Vec2> = if (Scalars.equals(dir.x, 0.0, Scalars.EPSILON)) {\n            val y0: Double = p.start().y\n            Array(roots.size) { i ->\n                val t = roots[i]\n                val y1: Double = q.position(t).y\n                Vec2((y1 - y0) / dir.y, t)\n            }\n        } else {\n            val x0: Double = p.start().x\n            Array(roots.size) { i ->\n                val t = roots[i]\n                val x1: Double = q.position(t).x\n                Vec2((x1 - x0) / dir.x, t)\n            }\n        }\n        return result\n    }\n\n    fun lineCubic(\n        p: Line2,\n        q: Bezier2.CubicBezier2\n    ): Array<Vec2> {\n        // (-p0 + 3p1 - 3p2 + p3) t^3 + (3p0 - 6p1 + 3p2) t^2 + (-3p0 + 3p1) t + p0\n        val a: Vec2 = q.p0.mul(-1.0).add(q.p1.mul(3.0)).add(q.p2.mul(-3.0)).add(q.p3)\n        val b: Vec2 = q.p0.mul(3.0).add(q.p1.mul(-6.0)).add(q.p2.mul(3.0))\n        val c: Vec2 = q.p0.mul(-3.0).add(q.p1.mul(3.0))\n        val d: Vec2 = q.p0\n        val dir: Vec2 = p.end().sub(p.start())\n        val dLen: Double = dir.length()\n        val n = Vec2(-dir.y, dir.x)\n        val roots: DoubleArray = Equations.solveCubic(\n            Vec.dot(n, a),\n            Vec.dot(n, b),\n            Vec.dot(n, c),\n            Vec.dot(n, d) + Vec2.cross(p.start(), p.end())\n        )\n        val result = Array(roots.size) { i ->\n            val t = roots[i]\n            val v = q.position(t).sub(p.start())\n            val vLen: Double = v.length()\n            val s: Double = vLen / dLen * signum(Vec.dot(dir, v))\n            Vec2(s, t)\n        }\n        return result\n    }\n\n    fun normalize(intersections: Array<Vec2>): Array<Vec2> {\n        var limit = intersections.size\n        if (limit == 0) {\n            return intersections\n        }\n        var readIdx: Int\n        var writeIdx: Int\n\n        // round and filter within [0, 1]\n        readIdx = 0\n        writeIdx = 0\n        while (readIdx < limit) {\n            val i: Vec2 = intersections[readIdx].map { n: Double ->\n                round(\n                    n,\n                    PARAMETRIC_EPSILON\n                )\n            }\n            if (PARAMETRIC_BOUNDS.contains(i)) {\n                intersections[writeIdx++] = i\n            }\n            readIdx++\n        }\n        limit = writeIdx\n        if (limit > 1) {\n            // dedupe intersections on b\n            //intersections.sortBy { it.y }\n            sort(\n                intersections,\n                0,\n                limit,\n                { v: Vec2 -> v.y }\n            )\n            readIdx = 0\n            writeIdx = -1\n            while (readIdx < limit) {\n                val i: Vec2 = intersections[readIdx]\n                if (writeIdx < 0 || !Scalars.equals(intersections[writeIdx].y, i.y, Scalars.EPSILON)) {\n                    intersections[++writeIdx] = i\n                }\n                readIdx++\n            }\n            limit = writeIdx + 1\n        }\n        if (limit > 1) {\n            // dedupe intersections on a\n            sort(\n                intersections,\n                0,\n                limit,\n                { v: Vec2 -> v.x })\n\n            readIdx = 0\n            writeIdx = -1\n            while (readIdx < limit) {\n                val i: Vec2 = intersections[readIdx]\n                if (writeIdx < 0 || !Scalars.equals(intersections[writeIdx].x, i.x, Scalars.EPSILON)) {\n                    intersections[++writeIdx] = i\n                }\n                readIdx++\n            }\n            limit = writeIdx + 1\n        }\n        val result: Array<Vec2> = Array(limit) {\n            intersections[it]\n        }\n        return result\n    }\n\n    // analytical methods\n    fun collinearIntersection(\n        a: Curve2,\n        b: Curve2\n    ): Array<Vec2> {\n        val result = mutableListOf<Vec2>()\n        for (i in 0..1) {\n            val tb: Double = b.nearestPoint(a.position(i.toDouble()))\n\n            // a overhangs the start of b\n            if (tb <= 0) {\n                val s: Double = round(\n                    a.nearestPoint(b.start()),\n                    PARAMETRIC_EPSILON\n                )\n                if (0.0 <= s && s <= 1.0) {\n                    result.add(Vec2(s, 0.0))\n                }\n\n                // a overhangs the end of b\n            } else if (tb >= 1) {\n                val s: Double = round(\n                    a.nearestPoint(b.end()),\n                    PARAMETRIC_EPSILON\n                )\n                if (0 <= s && s <= 1) {\n                    result.add(Vec2(s, 1.0))\n                }\n\n                // a is contained in b\n            } else {\n                result.add(Vec2(i.toDouble(), tb))\n            }\n        }\n        if (result.size == 2 && Vec.equals(\n                result[0],\n                result[1],\n                PARAMETRIC_EPSILON\n            )\n        ) {\n            result.removeLast()\n        }\n        return result.toTypedArray()\n    }\n\n    // subdivision (slow, but as close to a reference implementation as exists)\n    class CurveInterval(\n        curve: Curve2,\n        tLo: Double,\n        tHi: Double,\n        pLo: Vec2,\n        pHi: Vec2\n    ) {\n        val curve: Curve2\n        val isFlat: Boolean\n        val tLo: Double\n        val tHi: Double\n        val pLo: Vec2\n        val pHi: Vec2\n        fun bounds(): Box2 {\n            return Box.box(pLo, pHi)\n        }\n\n        fun intersects(c: CurveInterval): Boolean {\n            return bounds().expand(SPATIAL_EPSILON).intersects(c.bounds())\n        }\n\n        fun split(): Array<CurveInterval> {\n            return if (isFlat) {\n                arrayOf(this)\n            } else {\n                val tMid = (tLo + tHi) / 2\n                val pMid: Vec2 = curve.position(tMid)\n                arrayOf(\n                    CurveInterval(curve, tLo, tMid, pLo, pMid),\n                    CurveInterval(curve, tMid, tHi, pMid, pHi)\n                )\n            }\n        }\n\n        fun intersections(c: CurveInterval, acc: MutableList<Vec2>) {\n            for (i in lineLine(Line2.line(pLo, pHi), Line2.line(c.pLo, c.pHi))) {\n                if (PARAMETRIC_BOUNDS.expand(PARAMETRIC_EPSILON).contains(i)) {\n                    acc.add(Vec.lerp(Vec2(tLo, c.tLo), Vec2(tHi, c.tHi), i))\n                }\n            }\n        }\n\n        override fun toString(): String {\n            return \"[$tLo, $tHi]\"\n        }\n\n        companion object {\n            fun from(c: Curve2): Array<CurveInterval?> {\n                val ts: DoubleArray = c.inflections()\n                ts.sort()\n                return if (ts.size == 0) {\n                    arrayOf(CurveInterval(c, 0.0, 1.0, c.start(), c.end()))\n                } else {\n                    val ls = arrayOfNulls<CurveInterval>(ts.size + 1)\n                    for (i in ls.indices) {\n                        val lo: Double = if (i == 0) 0.0 else ts[i - 1]\n                        val hi: Double = if (i == ls.size - 1) 1.0 else ts[i]\n                        ls[i] = CurveInterval(c, lo, hi, c.position(lo), c.position(hi))\n                    }\n                    ls\n                }\n            }\n        }\n\n        init {\n            this.curve = curve\n            this.tLo = tLo\n            this.tHi = tHi\n            this.pLo = pLo\n            this.pHi = pHi\n            isFlat = (Vec.equals(pLo, pHi, SPATIAL_EPSILON)\n                    || tHi - tLo < PARAMETRIC_EPSILON || curve.range(tLo, tHi)\n                .isFlat(SPATIAL_EPSILON))\n        }\n    }\n\n\n    // post-processing\n    fun round(n: Double, epsilon: Double): Double {\n        return if (Scalars.equals(n, 0.0, epsilon)) {\n            0.0\n        } else if (Scalars.equals(n, 1.0, epsilon)) {\n            1.0\n        } else {\n            n\n        }\n    }\n\n    //\n    fun intersections(a: Curve2, b: Curve2): Array<Vec2> {\n        if (!a.bounds().expand(SPATIAL_EPSILON).intersects(b.bounds())) {\n            return emptyArray()\n        }\n        return if (a is Line2) {\n            normalize(lineCurve(a, b))\n        } else if (b is Line2) {\n            val result: Array<Vec2> = normalize(\n                lineCurve(b, a)\n            )\n            for (i in result.indices) {\n                result[i] = result[i].swap()\n            }\n            result\n        } else {\n            //return subdivisionCurveCurve(a, b);\n            fatLineCurveCurve(a, b)\n        }\n    }\n\n    // fatline\n\n    // fat lines (faster, but more temperamental)\n    // This is adapted from Sederberg's \"Curve Intersection Using Bezier Clipping\", but the algorithm as described\n    // gets unstable when one curve is clipped small enough, causing it to over-clip the other curve, causing us to miss\n    // intersection points.  To address this, we quantize the curve sub-ranges using FAT_LINE_PARAMETRIC_RESOLUTION,\n    // preventing them from getting too small, and expand the width of our clipping regions by FAT_LINE_SPATIAL_EPSILON.\n    fun signedDistance(p: Vec2, a: Vec2, b: Vec2): Double {\n        val d: Vec2 = b.sub(a)\n        return (Vec2.cross(p, d) + Vec2.cross(b, a)) / d.length()\n    }\n\n    fun fatLineWidth(c: Curve2): Interval {\n        return if (c is Line2) {\n            Interval.interval(0.0, 0.0)\n        } else if (c is Bezier2.QuadraticBezier2) {\n            val b: Bezier2.QuadraticBezier2 = c\n            Interval.interval(0.0, signedDistance(b.p1, b.p0, b.p2) / 2)\n        } else if (c is Bezier2.CubicBezier2) {\n            val b: Bezier2.CubicBezier2 = c\n            val d1 = signedDistance(b.p1, b.p0, b.p3)\n            val d2 = signedDistance(b.p2, b.p0, b.p3)\n            val k = if (d1 * d2 < 0) 4 / 9.0 else 3 / 4.0\n            Interval.interval(\n                min(\n                    0.0,\n                    min(d1, d2)\n                ) * k,\n                max(0.0, max(d1, d2)) * k\n            )\n        } else {\n            throw IllegalStateException()\n        }\n    }\n\n    fun convexHull(\n        a: Vec2,\n        b: Vec2,\n        c: Bezier2.QuadraticBezier2\n    ): Array<Vec2> {\n        val p0 = Vec2(0.0, signedDistance(c.p0, a, b))\n        val p1 = Vec2(1 / 2.0, signedDistance(c.p1, a, b))\n        val p2 = Vec2(1.0, signedDistance(c.p2, a, b))\n        return arrayOf(p0, p1, p2, p0)\n    }\n\n    fun convexHull(\n        a: Vec2,\n        b: Vec2,\n        c: Bezier2.CubicBezier2\n    ): Array<Vec2> {\n        val p0 = Vec2(0.0, signedDistance(c.p0, a, b))\n        val p1 = Vec2(1 / 3.0, signedDistance(c.p1, a, b))\n        val p2 = Vec2(2 / 3.0, signedDistance(c.p2, a, b))\n        val p3 = Vec2(1.0, signedDistance(c.p3, a, b))\n        val d1 = signedDistance(p1, p0, p3)\n        val d2 = signedDistance(p2, p0, p3)\n        return if (d1 * d2 < 0) {\n            arrayOf(p0, p1, p3, p2, p0)\n        } else {\n            val k = d1 / d2\n            if (k >= 2) {\n                arrayOf(p0, p1, p3, p0)\n            } else if (k <= 0.5) {\n                arrayOf(p0, p2, p3, p0)\n            } else {\n                arrayOf(p0, p1, p2, p3, p0)\n            }\n        }\n    }\n\n    fun convexHull(\n        a: Vec2,\n        b: Vec2,\n        c: Curve2\n    ): Array<Vec2> {\n        return when (c) {\n            is Bezier2.QuadraticBezier2 -> {\n                convexHull(a, b, c)\n            }\n            is Bezier2.CubicBezier2 -> {\n                convexHull(a, b, c)\n            }\n            else -> {\n                throw IllegalStateException()\n            }\n        }\n    }\n\n    fun clipHull(fatLine: Interval, hull: Array<Vec2>): Interval {\n        var lo = Double.POSITIVE_INFINITY\n        var hi = Double.NEGATIVE_INFINITY\n        for (i in 0 until hull.size - 1) {\n            if (fatLine.contains(hull[i].y)) {\n                lo = min(lo, hull[i].x)\n                hi = max(hi, hull[i].x)\n            }\n        }\n        for (y in doubleArrayOf(fatLine.lo, fatLine.hi)) {\n            for (i in 0 until hull.size - 1) {\n                val a: Vec2 = hull[i]\n                val b: Vec2 = hull[i + 1]\n                if (Interval.interval(a.y, b.y).contains(y)) {\n                    if (a.y == b.y) {\n                        lo = min(lo, min(a.x, b.x))\n                        hi = max(\n                            lo, max(a.x, b.x)\n                        )\n                    } else {\n                        val t = Scalars.lerp(a.x, b.x, (y - a.y) / (b.y - a.y))\n                        lo = min(lo, t)\n                        hi = max(hi, t)\n                    }\n                }\n            }\n        }\n        return if (hi < lo) {\n            Interval.EMPTY\n        } else {\n            Interval.interval(lo, hi)\n        }\n    }\n\n    fun quantize(t: Interval): Interval {\n        val resolution: Double = FAT_LINE_PARAMETRIC_RESOLUTION\n        val lo: Double = min(\n            1 - resolution,\n            floor(t.lo / resolution) * resolution\n        )\n        val hi: Double = max(\n            lo + resolution,\n            ceil(t.hi / resolution) * resolution\n        )\n        return Interval.interval(lo, hi)\n    }\n\n    fun addIntersections(\n        a: FatLine,\n        b: FatLine,\n        acc: MutableList<Vec2>\n    ) {\n        val la: Line2 = a.line()\n        val lb: Line2 = b.line()\n        val av: Vec2 = la.end().sub(la.start())\n        val bv: Vec2 = lb.end().sub(lb.start())\n        val asb: Vec2 = la.start().sub(lb.start())\n        val d: Double = Vec2.cross(av, bv)\n        val i = Vec2(\n            Vec2.cross(bv, asb) / d,\n            Vec2.cross(av, asb) / d\n        )\n        if (PARAMETRIC_BOUNDS.expand(0.1).contains(i)) {\n            acc.add(Box.box(a.t, b.t).lerp(i))\n        }\n    }\n\n    fun clipFatline(\n        subject: FatLine,\n        clipper: FatLine\n    ): FatLine? {\n        val hull = convexHull(clipper.range.start(), clipper.range.end(), subject.range)\n\n        val expanded = clipper._line.expand(FAT_LINE_SPATIAL_EPSILON)\n        val normalized = clipHull(expanded, hull)\n        return if (normalized.isEmpty) null else FatLine(\n            subject.curve,\n            subject.t.lerp(normalized)\n        )\n    }\n\n    class FatLine internal constructor(curve: Curve2, t: Interval) {\n        val curve: Curve2\n        val range: Curve2\n        val t: Interval\n        val _line: Interval\n        fun mid(): Double {\n            return t.lerp(0.5)\n        }\n\n        val isFlat: Boolean\n            get() = t.size() < PARAMETRIC_EPSILON || _line.size() <= SPATIAL_EPSILON\n\n        fun bounds(): Box2 {\n            return Box.box(range.start(), range.end())\n        }\n\n        fun intersects(l: FatLine): Boolean {\n            return bounds().expand(SPATIAL_EPSILON * 10).intersects(l.bounds())\n        }\n\n        fun split(): Array<FatLine> {\n            return if (isFlat) {\n                arrayOf(this)\n            } else arrayOf(\n                FatLine(curve, Interval.interval(t.lo, mid())),\n                FatLine(curve, Interval.interval(mid(), t.hi))\n            )\n        }\n\n        fun line(): Line2 {\n            return Line2.line(range.start(), range.end())\n        }\n\n        override fun toString(): String {\n            return \"FatLine(curve=$curve, range=$range, t=$t, _line=$_line, isFlat=$isFlat)\"\n        }\n\n\n        companion object {\n            fun from(c: Curve2): Array<FatLine> {\n                val ts: DoubleArray = c.inflections()\n                ts.sort()\n                return if (ts.isEmpty()) {\n                    arrayOf(FatLine(c, Interval.interval(0.0, 1.0)))\n                } else {\n                    val result = arrayOfNulls<FatLine>(ts.size + 1)\n                    for (i in result.indices) {\n                        val lo: Double = if (i == 0) 0.0 else ts[i - 1]\n                        val hi: Double = if (i == result.size - 1) 1.0 else ts[i]\n                        result[i] = FatLine(c, Interval.interval(lo, hi))\n                    }\n                    @Suppress(\"UNCHECKED_CAST\")\n                    result as Array<FatLine>\n                }\n            }\n        }\n\n        init {\n            this.curve = curve\n            this.t = quantize(t)\n            range = curve.range(this.t)\n            _line = fatLineWidth(range)\n        }\n    }\n\n//    fun fatLineWidth(c: Curve2): Interval? {\n//        return if (c is Line2) {\n//            Interval.interval(0.0, 0.0)\n//        } else if (c is Bezier2.QuadraticBezier2) {\n//            val b: Bezier2.QuadraticBezier2 = c as Bezier2.QuadraticBezier2\n//            Interval.interval(\n//                0.0,\n//                Intersections.signedDistance(b.p1, b.p0, b.p2) / 2\n//            )\n//        } else if (c is Bezier2.CubicBezier2) {\n//            val b: Bezier2.CubicBezier2 = c as Bezier2.CubicBezier2\n//            val d1: Double = Intersections.signedDistance(b.p1, b.p0, b.p3)\n//            val d2: Double = Intersections.signedDistance(b.p2, b.p0, b.p3)\n//            val k = if (d1 * d2 < 0) 4 / 9.0 else 3 / 4.0\n//            Interval.interval(\n//                min(\n//                    0.0,\n//                    min(d1, d2)\n//                ) * k,\n//                max(0.0, max(d1, d2)) * k\n//            )\n//        } else {\n//            throw IllegalStateException()\n//        }\n//    }\n\n//    fun quantize(t: Interval): Interval? {\n//        val resolution: Double = Intersections.FAT_LINE_PARAMETRIC_RESOLUTION\n//        val lo: Double = min(\n//            1 - resolution,\n//            floor(t.lo / resolution) * resolution\n//        )\n//        val hi: Double = max(\n//            lo + resolution,\n//            ceil(t.hi / resolution) * resolution\n//        )\n//        return Interval.interval(lo, hi)\n//    }\n\n    fun fatLineCurveCurve(a: Curve2, b: Curve2): Array<Vec2> {\n        val queue = ArrayDeque<FatLine>()\n        val `as` = FatLine.from(a)\n        val bs = FatLine.from(b)\n        for (ap in `as`) {\n            for (bp in bs) {\n                queue.apply {\n                    addLast(ap)\n                    addLast(bp)\n                }\n            }\n        }\n        var iterations = 0\n        var collinearCheck = false\n        val acc = ArrayDeque<Vec2>()\n        while (queue.size > 0) {\n            // if it's taking a while, check once (and only once) if they're collinear\n            if (iterations > 32 && !collinearCheck) {\n                collinearCheck = true\n                val `is`: Array<Vec2> =\n                    collinearIntersection(a, b)\n                if (isCollinear(a, b, `is`)) {\n                    return `is`\n                }\n            }\n            var lb = queue.removeLast()\n            var la = queue.removeLast()\n            while (true) {\n                iterations++\n                if (!la.intersects(lb)) {\n                    break\n                }\n                if (la.isFlat && lb.isFlat) {\n                    addIntersections(la, lb, acc)\n                    break\n                }\n                val aSize: Double = la.t.size()\n                val bSize: Double = lb.t.size()\n\n                // use a to clip b\n                val lbPrime = clipFatline(lb, la) ?: break\n                lb = lbPrime\n\n                // use b to clip a\n                val laPrime: FatLine = clipFatline(la, lb) ?: break\n                la = laPrime\n                val ka: Double = la.t.size() / aSize\n                val kb: Double = lb.t.size() / bSize\n                if (max(ka, kb) > 0.8) {\n                    // TODO: switch over to subdivision at some point?\n                    for (ap in la.split()) {\n                        for (bp in lb.split()) {\n                            queue.apply {\n                                addLast(ap)\n                                addLast(bp)\n                            }\n                        }\n                    }\n                    break\n                }\n            }\n        }\n        return normalize(acc.toTypedArray())\n    }\n\n    private fun isCollinear(\n        a: Curve2,\n        b: Curve2,\n        `is`: Array<Vec2>\n    ): Boolean {\n        if (`is`.size != 2) {\n            return false\n        }\n        for (i in 0 until MAX_CUBIC_CUBIC_INTERSECTIONS + 1) {\n            val t: Double = i.toDouble() / MAX_CUBIC_CUBIC_INTERSECTIONS\n            val pa: Vec2 = a.position(Scalars.lerp(`is`[0].x, `is`[1].x, t))\n            val pb: Vec2 = b.position(Scalars.lerp(`is`[0].y, `is`[1].y, t))\n            if (!Vec.equals<Vec2>(\n                    pa,\n                    pb,\n                    SPATIAL_EPSILON\n                )\n            ) {\n                return false\n            }\n        }\n        return true\n    }\n}","package org.openrndr.kartifex.utils\n\nimport kotlin.math.PI\nimport kotlin.math.abs\nimport kotlin.math.pow\n\n/**\n * @author ztellman\n */\nobject Scalars {\n    const val SIGNIFICAND_WIDTH = 53\n    const val MIN_EXPONENT = -1022\n    const val MAX_EXPONENT = 1023\n    const val EXP_BIT_MASK = 0x7FF0000000000000L\n    const val EXP_BIAS        = 1023\n\n\n    fun getExponent(d: Double): Int {\n        /*\n         * Bitwise convert d to long, mask out exponent bits, shift\n         * to the right and then subtract out double's bias adjust to\n         * get true exponent value.\n         */\n        return ((d.toRawBits() and EXP_BIT_MASK shr SIGNIFICAND_WIDTH - 1) - EXP_BIAS).toInt()\n    }\n\n    fun powerOfTwoD(exp:Double) : Double {\n        return 2.0.pow(exp)\n    }\n\n    fun ulp(d: Double): Double {\n        var exp: Int = getExponent(d)\n        return when (exp) {\n            MAX_EXPONENT + 1 -> abs(d)\n            MIN_EXPONENT - 1 -> Double.MIN_VALUE\n            else -> {\n                //assert(exp <= java.lang.Double.MAX_EXPONENT && exp >= java.lang.Double.MIN_EXPONENT)\n\n                // ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n                exp = exp - (SIGNIFICAND_WIDTH - 1)\n                if (exp >= MIN_EXPONENT) {\n                    powerOfTwoD(exp.toDouble())\n                } else {\n                    // return a subnormal result; left shift integer\n                    // representation of Double.MIN_VALUE appropriate\n                    // number of positions\n\n                    Double.fromBits(\n                        1L shl\n                                exp - (MIN_EXPONENT - (SIGNIFICAND_WIDTH - 1))\n                    )\n                }\n            }\n        }\n    }\n\n    val MACHINE_EPSILON: Double = ulp(1.0)\n    const val EPSILON = 1e-14\n    fun equals(a: Double, b: Double, epsilon: Double): Boolean {\n        return abs(a - b) < epsilon\n    }\n\n    @Suppress(\"NAME_SHADOWING\")\n    fun angleEquals(t0: Double, t1: Double, epsilon: Double): Boolean {\n        var t0 = t0\n        var t1 = t1\n        if (t1 < t0) {\n            val tmp = t1\n            t1 = t0\n            t0 = tmp\n        }\n        var result = t1 - t0 < epsilon\n        if (!result) {\n            t1 -= PI * 2\n            result = t0 - t1 < epsilon\n        }\n        return result\n    }\n\n    fun normalize(a: Double, b: Double, n: Double): Double {\n        return (n - a) / (b - a)\n    }\n\n    fun lerp(a: Double, b: Double, t: Double): Double {\n        return a + (b - a) * t\n    }\n\n    fun inside(min: Double, n: Double, max: Double): Boolean {\n        return min < n && n < max\n    }\n\n    fun clamp(min: Double, n: Double, max: Double): Double {\n        return if (n <= min) {\n            min\n        } else if (n >= max) {\n            max\n        } else {\n            n\n        }\n    }\n\n    fun normalizationFactor(a: Double, b: Double, c: Double, d: Double): Double {\n        val maxValue = max(max(a, b), max(c, d))\n        return if (maxValue == 0.0) {\n            1.0\n        } else {\n            val exponent: Double = getExponent(maxValue).toDouble()\n            if (exponent < -8 || exponent > 8) 2.0.pow(-exponent) else 1.0\n        }\n    }\n\n    fun normalizationFactor(a: Double, b: Double, c: Double): Double {\n        val maxValue = max(a, b, c)\n        return if (maxValue == 0.0) {\n            1.0\n        } else {\n            val exponent = getExponent(maxValue).toDouble()\n            if (exponent < -8 || exponent > 8) 2.0.pow(-exponent) else 1.0\n        }\n    }\n\n    fun normalizationFactor(a: Double, b: Double): Double {\n        val maxValue = max(a,b)\n        return if (maxValue == 0.0) {\n            1.0\n        } else {\n            val exponent: Double = getExponent(maxValue).toDouble()\n            if (exponent < -8 || exponent > 8) 2.0.pow(-exponent) else 1.0\n        }\n    }\n\n    fun max(a: Double, b: Double): Double {\n        return if (a < b) b else a\n    }\n\n    fun max(a: Double, b: Double, c: Double): Double {\n        return max(a, max(b, c))\n    }\n\n    fun min(a: Double, b: Double): Double {\n        return if (a > b) b else a\n    }\n\n    fun min(a: Double, b: Double, c: Double): Double {\n        return min(a, min(b, c))\n    }\n}","package org.openrndr.kartifex.utils\n\n\nimport org.openrndr.collections.PriorityQueue\nimport kotlin.math.max\nimport kotlin.math.min\n\nprivate fun copySign(magnitude: Double, sign: Double): Double {\n    return if (sign < 0.0) {\n        if (magnitude < 0.0) {\n            magnitude\n        } else {\n            -magnitude\n        }\n    } else {\n        if (magnitude > 0.0) {\n            magnitude\n        } else {\n            -magnitude\n        }\n    }\n}\n\nclass SweepQueue<T> {\n    class Event<T> internal constructor(val key: Double, val value: T, val type: Int) {\n        companion object {\n            val COMPARATOR: Comparator<Event<*>> =\n                Comparator { a: Event<*>, b: Event<*> ->\n                    val diff = a.key - b.key\n                    if (diff == 0.0) {\n                        a.type - b.type\n                    } else {\n                        copySign(1.0, diff).toInt()\n                    }\n                }\n        }\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private val queue: PriorityQueue<Event<T>> = PriorityQueue(Event.COMPARATOR as Comparator<Event<T>>)\n    private val set = mutableSetOf<T>()\n    fun add(value: T, a: Double, b: Double) {\n        queue.add(Event(min(a, b) - Scalars.EPSILON, value, OPEN))\n        queue.add(Event(max(a, b) + Scalars.EPSILON, value, CLOSED))\n    }\n\n    fun peek(): Double {\n        return if (queue.isEmpty()) Double.MAX_VALUE else queue.peek().key\n    }\n\n    operator fun next(): Event<T> {\n        val e: Event<T> = queue.poll() ?: error(\"queue empty\")\n        if (e.type == CLOSED) {\n            set.remove(e.value)\n        } else {\n            set.add(e.value)\n        }\n        return e\n    }\n\n    fun take(): T? {\n        while (!queue.isEmpty()) {\n            val e = next()\n            if (e.type == OPEN) {\n                return e.value\n            }\n        }\n        return null\n    }\n\n    fun active(): Set<T> {\n        return set\n    }\n\n    companion object {\n        const val OPEN = 0\n        const val CLOSED = 1\n        private fun <T> compare(a: SweepQueue<T>, b: SweepQueue<T>): Int {\n            return Event.COMPARATOR.compare(a.queue.peek(), b.queue.peek())\n        }\n\n        fun <T> next(vararg queues: SweepQueue<T>): Int {\n            while (true) {\n                var minIdx = 0\n                for (i in 1 until queues.size) {\n                    if (queues[minIdx].queue.isEmpty() || !queues[i].queue.isEmpty() && compare(\n                            queues[i], queues[minIdx]\n                        ) < 0\n                    ) {\n                        minIdx = i\n                    }\n                }\n                val q = queues[minIdx]\n                if (q.queue.isEmpty() || q.queue.peek().type == OPEN) {\n                    return minIdx\n                } else {\n                    q.next()\n                }\n            }\n        }\n    }\n}\n","package org.openrndr.kartifex.utils.graphs\n\nimport org.openrndr.collections.PriorityQueue\nimport kotlin.math.max\nimport kotlin.math.min\n\ninterface IEdge<V, E> {\n    fun from(): V\n    fun to(): V\n    fun value(): E\n}\n\nclass Edge<V, E>(val _value: E, val _from: V, val _to: V) : IEdge<V, E> {\n    override fun from(): V {\n        return _from\n    }\n\n    override fun to(): V {\n        return _to\n    }\n\n    override fun value(): E {\n        return _value\n    }\n}\n\nfun <E> Set<E>.indexOf(e: E): Int {\n    val i = iterator()\n    var index = 0\n    while (i.hasNext()) {\n        if (i.next() == e) {\n            return index\n        }\n        index++\n    }\n    return -1\n}\n\nclass DirectedGraph<V, E>(\n    val out: MutableMap<V, MutableMap<V, E>> = mutableMapOf(),\n    val `in`: MutableMap<V, MutableSet<V>> = mutableMapOf()\n) {\n    fun indexOf(vertex: V): Int {\n        return out.keys.indexOf(vertex)\n    }\n\n\n    fun vertices(): Set<V> {\n        return out.keys\n    }\n\n    fun edges(): Iterable<Edge<V, E>> {\n        return Iterable {\n            out.entries\n                .flatMap { outer ->\n                    outer.value\n                        .entries\n                        .map { inner -> Edge(inner.value, inner.key, outer.key) }\n                }\n                .iterator()\n        }\n    }\n\n    fun edge(from: V, to: V): E {\n        val m = out[from] ?: error(\"no such edge\")\n        val e = m[to] ?: error(\"no such edge\")\n        return e\n    }\n\n    fun `in`(vertex: V): Set<V> {\n        val s: Set<V>? = `in`[vertex]\n        return if (s == null) {\n            if (out.contains(vertex)) {\n                emptySet()\n            } else {\n                error(\"no such vertex\")\n            }\n        } else {\n            s\n        }\n    }\n\n    fun out(vertex: V): Set<V> = out[vertex]?.keys ?: error(\"no such vertex $vertex\")\n\n    fun link(from: V, to:V, edge: E) = link(from, to, edge) { _, b -> b }\n\n    fun link(from: V, to: V, edge: E, merge: (E, E) -> E) {\n        add(from)\n        add(to)\n        val e: E? = (out[from] ?: error(\"no from vertex\"))[to]\n        if (e == null) {\n            out[from]!![to] = edge\n        } else {\n            out[from]!![to] = merge(e, edge)\n        }\n        out.getOrPut(to) { mutableMapOf() }\n        `in`.getOrPut(to) { mutableSetOf() }.add(from)\n    }\n\n    fun unlink(from: V, to: V) {\n        (out[from] ?: error(\"no from vertex\")).remove(to)\n        (`in`[to]!!.remove(from))\n    }\n\n    fun add(vertex: V): DirectedGraph<V, E> {\n        return if (out.contains(vertex)) {\n            this\n        } else {\n            out.put(vertex, mutableMapOf())\n            `in`[vertex] = mutableSetOf()\n            this\n        }\n    }\n\n\n//    fun remove(vertex: V): DirectedGraph<V, E> {\n//\n//\n//        if (out.contains(vertex)) {\n//            for (v in out[vertex]!!.keys) {\n//                out[v]?.remove(vertex)\n//            }\n//            out.remove(vertex)\n//\n//        }\n//        `in`.remove(vertex)\n//        return this\n//    }\n\n    fun select(selection: Set<V>): DirectedGraph<V, E> {\n        val newOut = mutableMapOf<V, MutableMap<V,E>>()\n        val newIn = mutableMapOf<V, MutableSet<V>>()\n        for (entry in out.entries) {\n            if (entry.key in selection) {\n                newOut[entry.key] = entry.value.filterKeys { key -> key in selection }.toMutableMap()\n            }\n        }\n        for (entry in `in`.entries) {\n            if (entry.key in selection) {\n                newIn[entry.key] = entry.value.filter { it -> it in selection }.toMutableSet()\n            }\n        }\n        return DirectedGraph(newOut, newIn)\n    }\n\n//    fun transpose(): DirectedGraph<V, E> {\n//        return DirectedGraph(\n//\n//            out.mapValues({ u: V, x: io.lacuna.bifurcan.Map<V, E>? ->\n//                `in`.get(u, EMPTY_SET as io.lacuna.bifurcan.Set<V>).map.mapValues(\n//                    java.util.function.BiFunction<V, Void, E> { v: V, y: Void? -> edge(v, u) })\n//            }),\n//            out.mapValues(java.util.function.BiFunction<V, io.lacuna.bifurcan.Map<V, E>, io.lacuna.bifurcan.Set<V>> { x: V, m: io.lacuna.bifurcan.Map<V, E> -> m.keys() })\n//        )\n//    }\n\n\n    override fun hashCode(): Int {\n        return out.hashCode()\n    }\n\n    override fun equals(other: Any?): Boolean {\n        return if (other is DirectedGraph<*, *>) {\n            other.out == out\n        } else {\n            false\n        }\n    }\n\n}\n\n/// directed graphs\nprivate class TarjanState(val index: Int) {\n    var lowlink: Int\n    var onStack: Boolean\n\n    init {\n        lowlink = index\n        onStack = true\n    }\n}\n\nobject Graphs {\n    fun <V> stronglyConnectedComponents(\n        graph: DirectedGraph<V, *>,\n        includeSingletons: Boolean\n    ): Set<Set<V>> {\n\n        // algorithmic state\n        val state = mutableMapOf<V, TarjanState>()\n\n        val stack = ArrayDeque<V>()\n\n        // call-stack state\n        val path = mutableListOf<V>()\n        val branches = mutableListOf<Iterator<V>>()\n        val result = mutableSetOf<Set<V>>()\n        for (seed in graph.vertices()) {\n            if (state.contains(seed)) {\n                continue\n            }\n            branches.add(mutableListOf(seed).iterator())\n            do {\n                // traverse deeper\n                if (branches.last().hasNext()) {\n                    val w: V = branches.last().next()\n                    var ws: TarjanState? = state[w]\n                    if (ws == null) {\n                        ws = TarjanState(state.size)\n                        state.put(w, ws)\n                        stack.addLast(w)\n                        path.add(w)\n                        branches.add(graph.out(w).iterator())\n                    } else if (ws.onStack) {\n                        val vs: TarjanState = state[path.last()]!!\n                        vs.lowlink = min(vs.lowlink, ws.index)\n                    }\n\n                    // return\n                } else {\n                    branches.removeLast()\n                    val w: V = path.removeLast()\n                    val ws: TarjanState = state[w]!!\n\n                    // update predecessor's lowlink, if they exist\n                    if (path.size > 0) {\n                        val v: V = path.last()\n                        val vs: TarjanState = state[v]!!\n                        vs.lowlink = min(vs.lowlink, ws.lowlink)\n                    }\n\n                    // create a new group\n                    if (ws.lowlink == ws.index) {\n                        if (!includeSingletons && stack.last() === w) {\n                            stack.removeLast()\n                            state[w]!!.onStack = false\n                        } else {\n                            val group = mutableSetOf<V>()\n                            while (true) {\n                                val x: V = stack.removeLast()\n                                group.add(x)\n                                state[x]!!.onStack = false\n                                if (x === w) {\n                                    break\n                                }\n                            }\n                            result.add(group)\n                        }\n                    }\n                }\n            } while (path.size > 0)\n        }\n        return result\n    }\n\n\n    fun <V, E> stronglyConnectedSubgraphs(\n        graph: DirectedGraph<V, E>,\n        includeSingletons: Boolean\n    ): List<DirectedGraph<V, E>> {\n        val result = mutableListOf<DirectedGraph<V, E>>()\n        stronglyConnectedComponents(graph, includeSingletons)\n            .forEach { s ->\n                result.add(\n                    graph.select(s)\n                )\n            }\n        return result\n    }\n\n\n    fun <V, E> cycles(graph: DirectedGraph<V, E>): List<List<V>> {\n        // traversal\n        val path = mutableListOf<V>()\n        val branches = mutableListOf<Iterator<V>>()\n\n        //state\n        val blocked = mutableSetOf<V>()\n        val blocking = mutableMapOf<V, MutableSet<V>>()\n        val result = mutableListOf<List<V>>()\n        for (subgraph in stronglyConnectedSubgraphs(graph, true)) {\n            // simple rings are a pathological input for this algorithm, and also very common\n            if (subgraph.vertices()\n                    .all { v: V -> subgraph.out(v).size == 1 }\n            ) {\n                val seed: V = subgraph.vertices().iterator().next()\n                subgraph.out(seed)\n                result.add(\n                    bfsVertices(seed) { vertex: V -> subgraph.out(vertex) }.asSequence().toList()+ listOf(seed)\n                )\n                continue\n            }\n            for (seed in subgraph.vertices()) {\n\n\n                val threshold = subgraph.indexOf(seed)\n                path.add(seed)\n                branches.add(subgraph.out(seed).iterator())\n                blocked.clear()\n                blocking.clear()\n                var depth = 1\n                do {\n                    // traverse deeper\n                    if (branches.last().hasNext()) {\n                        val v: V = branches.last().next()\n                        if (subgraph.indexOf(v) < threshold) {\n                            continue\n                        }\n                        if (seed == v) {\n                            result.add(path + listOf(seed))\n                            depth = 0\n                        } else if (!blocked.contains(v)) {\n                            path.add(v)\n                            depth++\n                            branches.add(subgraph.out(v).iterator())\n                        }\n                        blocked.add(v)\n                        // return\n                    } else {\n                        val v: V = path.removeLast()\n                        depth = max(-1, depth - 1)\n                        if (depth < 0) {\n                            val stack = ArrayDeque<V>().apply { addFirst(v) }\n                            while (stack.size > 0) {\n                                val u: V = stack.removeLast()\n                                if (blocked.contains(u)) {\n                                    blocked.remove(u)\n                                    blocking[u] ?: emptySet<V>()\n                                        .forEach { value: V -> stack.addLast(value) }\n                                    blocking.remove(u)\n                                }\n                            }\n                        } else {\n                            graph.out(v).forEach { u: V -> blocking.getOrPut(u) { mutableSetOf() }.add(v) }\n                        }\n                        branches.removeLast()\n                    }\n                } while (path.size > 0)\n            }\n        }\n        return result\n    }\n\n    /// traversal\n\n    /// traversal\n    fun <V> bfsVertices(start: V, adjacent: (V) -> Iterable<V>): Iterator<V> {\n        return bfsVertices(listOf(start), adjacent)\n    }\n\n    fun <V> bfsVertices(start: Iterable<V>, adjacent: (V) -> Iterable<V>): Iterator<V> {\n        val queue = ArrayDeque<V>()\n        val traversed = mutableSetOf<V>()\n        start.forEach { value: V -> queue.add(value) }\n\n        return object : Iterator<V> {\n            override fun hasNext(): Boolean {\n                return queue.size > 0\n            }\n\n            override fun next(): V {\n                val v: V = queue.removeFirst()\n                traversed.add(v)\n                adjacent(v).forEach { w: V ->\n                    if (!traversed.contains(w)) {\n                        queue.addLast(w)\n                    }\n                }\n                return v\n            }\n        }\n    }\n\n    /// search\n    private class ShortestPathState<V> {\n        val origin: V\n        val node: V\n        val prev: ShortestPathState<V>?\n        val distance: Double\n\n        constructor(origin: V) {\n            this.origin = origin\n            prev = null\n            node = origin\n            distance = 0.0\n        }\n\n        constructor(node: V, prev: ShortestPathState<V>, edge: Double) {\n            origin = prev.origin\n            this.node = node\n            this.prev = prev\n            distance = prev.distance + edge\n        }\n\n        fun path(): List<V> {\n            val result = ArrayDeque<V>()\n            var curr: ShortestPathState<V>? = this\n            while (true) {\n                result.addFirst(curr!!.node)\n                if (curr.node == curr.origin) {\n                    break\n                }\n                curr = curr.prev\n            }\n            return result\n        }\n    }\n\n\n    /**\n     * @return the shortest path, if one exists, between a starting vertex and an accepted vertex, excluding trivial\n     * solutions where a starting vertex is accepted.\n     */\n    fun <V, E> shortestPath(\n        graph: DirectedGraph<V, E>,\n        start: Iterable<V>,\n        accept: (V) -> Boolean,\n        cost: (IEdge<V, E>) -> Double\n    ): List<V>? {\n        val originStates = mutableMapOf<V, MutableMap<V, ShortestPathState<V>>>()\n        val queue = PriorityQueue<ShortestPathState<V>>(compareBy { it.distance })\n\n        for (v in start) {\n            if (graph.vertices().contains(v)) {\n                val init = ShortestPathState(v)\n                (originStates.getOrPut(v) { mutableMapOf() })[v] = init\n                queue.add(init)\n            }\n        }\n        var curr: ShortestPathState<V>?\n        while (true) {\n            curr = queue.poll()\n            if (curr == null) {\n                return null\n            }\n            val states: MutableMap<V, ShortestPathState<V>> = originStates[curr.origin] ?: error(\"no state\")\n            if (states[curr.node] !== curr) {\n                continue\n            } else if (curr.prev != null && accept(curr.node)) {\n                return curr.path()\n            }\n            for (v in graph.out(curr.node)) {\n                val edge: Double =\n                    cost(Edge(graph.edge(curr.node, v), curr.node, v))\n                require(edge >= 0) { \"negative edge weights are unsupported\" }\n                var next: ShortestPathState<V>? = states[v]\n                next = if (next == null) {\n                    ShortestPathState(v, curr, edge)\n                } else if (curr.distance + edge < next.distance) {\n                    ShortestPathState(v, curr, edge)\n                } else {\n                    continue\n                }\n                states.put(v, next)\n                queue.add(next)\n            }\n        }\n    }\n}","package org.openrndr.kartifex.utils.regions\n\nimport org.openrndr.kartifex.Curve2\nimport org.openrndr.kartifex.Interval\nimport org.openrndr.kartifex.Vec2\n\ninternal class Arc(val list:MutableList<Curve2> = mutableListOf()) : MutableList<Curve2> by list {\n\n    private var hashProxy = 0.5\n\n    private var length = Double.NaN\n    private var area = Double.NaN\n    fun length(): Double {\n        if (length.isNaN()) {\n            length = map {  c: Curve2 ->\n                c.end().sub(c.start()).length()\n            }.sum()\n        }\n        return length\n    }\n\n    fun signedArea(): Double {\n        if (area.isNaN()) {\n            area =\n                map{  obj: Curve2 -> obj.signedArea() }\n                    .sum()\n        }\n        return area\n    }\n\n    fun head(): Vec2 {\n        return first().start()\n    }\n\n    fun tail(): Vec2 {\n        return last().end()\n    }\n\n    fun position(t: Double): Vec2 {\n        val length = length()\n        var offset = 0.0\n        val threshold = length * t\n        for (c in this) {\n            val l: Double = c.end().sub(c.start()).length()\n            val i: Interval = Interval(offset, offset + l)\n            if (i.contains(threshold)) {\n                return c.position(i.normalize(threshold))\n            }\n            offset = i.hi\n        }\n        throw IllegalStateException()\n    }\n\n    fun reverse(): Arc {\n        return Arc(reversed().map { it.reverse() }.toMutableList())\n    }\n\n    fun vertices(): List<Vec2> {\n        return listOf(head()) + map { it.end()}\n    }\n\n    override fun hashCode(): Int {\n        return hashProxy.hashCode()\n    }\n\n    override fun equals(other: Any?): Boolean {\n        return this === other\n    }\n}","package org.openrndr.kartifex.utils.regions\n\nimport org.openrndr.kartifex.Curve2\nimport org.openrndr.kartifex.Region2\nimport org.openrndr.kartifex.Ring2\nimport org.openrndr.kartifex.Vec2\nimport org.openrndr.kartifex.utils.Combinatorics\nimport org.openrndr.kartifex.utils.graphs.DirectedGraph\nimport org.openrndr.kartifex.utils.graphs.Graphs\nimport kotlin.math.E\nimport kotlin.math.abs\n\nobject Clip {\n    // The approach used here is described at https://ideolalia.com/2018/08/28/artifex.html.  The \"simplest\" approach would\n    // be to represent the unused segments as a multi-graph (since there can be multiple segments connecting any pair of vertices),\n    // but the graph data structure used here is *not* a multi-graph, so instead we model it as a graph which only includes\n    // the shortest edge between the vertices, and we just iterate over it multiple times.  Empirically 2-3 times should\n    // always suffice, but we give ourselves a bit of breathing room because mostly we just want to preclude an infinite loop.\n    private const val MAX_REPAIR_ATTEMPTS = 10\n\n    private enum class Operation {\n        UNION, INTERSECTION, DIFFERENCE\n    }\n\n    private enum class Type {\n        OUTSIDE, INSIDE, SAME_EDGE, DIFF_EDGE\n    }\n\n    private fun operation(\n        ra: Region2,\n        rb: Region2,\n        operation: Operation,\n        aPredicate: (Type) -> Boolean,\n        bPredicate: (Type) -> Boolean\n    ): Region2 {\n        val split: Split.Result = Split.split(ra, rb)\n        val a: Region2 = split.a\n        val b: Region2 = split.b\n\n        // Partition rings into arcs separated at intersection points\n        val pa: List<Arc> = partition(a, split.splits)\n        var pb: List<Arc> = partition(b, split.splits)\n        if (operation == Operation.DIFFERENCE) {\n            pb = pb.map { obj: Arc -> obj.reverse() }\n        }\n\n        // Filter out arcs which are to be ignored, per our operation\n        var arcs: MutableSet<Arc> = mutableSetOf()\n        pa.filter { arc: Arc -> aPredicate(classify(b, arc)) }.forEach { value -> arcs.add(value) }\n        pb.filter { arc: Arc -> bPredicate(classify(a, arc)) }.forEach { value -> arcs.add(value) }\n\n        /*\n    describe(\"split\", split.splits.elements());\n    describe(\"arcs\", arcs.elements().stream().map(Arc::vertices).toArray(IList[]::new));\n    VERTICES.forEach(v -> System.out.println(VERTICES.indexOf(v) + \" \" + v));\n    // */\n        val result = mutableListOf<Ring2>()\n        val consumed = mutableSetOf<Arc>()\n\n        // First we're going to extract complete cycles, and then try to iteratively repair the graph\n        for (i in 0 until MAX_REPAIR_ATTEMPTS) {\n            // Construct a graph where the edges are the set of all arcs connecting the vertices\n            val graph = DirectedGraph<Vec2, Set<Arc>>()\n            arcs.forEach { arc: Arc ->\n                graph.link(\n                    arc.head(), arc.tail(), mutableSetOf(arc)\n                ) { obj, s -> obj.union(s) }\n            }\n\n            //graph.vertices().forEach(v -> System.out.println(VERTICES.indexOf(v) + \" \" + graph.out(v).stream().map(VERTICES::indexOf).collect(Lists.linearCollector())));\n            if (i > 0) {\n                for (path in repairGraph(\n                    graph,\n                    (pa + pb) - arcs - consumed\n                )) {\n                    for (arc in path) {\n                        // if the graph currently contains the arc, remove it\n                        if (arcs.contains(arc)) {\n                            //describe(\"remove\", arc.vertices());\n                            graph.unlink(arc.head(), arc.tail())\n                            arcs.remove(arc)\n\n                            // if the graph doesn't contain the arc, add it\n                        } else {\n                            //describe(\"add\", arc.vertices());\n                            graph.link(arc.head(), arc.tail(), mutableSetOf(arc))\n                            arcs.add(arc)\n                        }\n                    }\n                }\n            }\n\n            // find every cycle in the graph, and then expand those cycles into every possible arc combination, yielding a bunch\n            // of rings ordered from largest to smallest\n            val cycles: List<List<Arc>> = Graphs.cycles(graph)\n                .map { cycle ->\n                    edges(cycle\n                    ) { x, y -> graph.edge(x, y).toList() }\n                }\n                .map { paths -> Combinatorics.combinations(paths) }\n                .flatten()\n                .sortedBy { area -> area(area) }\n                .reversed()\n\n            // extract as many cycles as possible without using the same arc twice\n            for (cycle in cycles) {\n                //describe(\"cycle\", cycle.stream().map(Arc::vertices).toArray(IList[]::new));\n                if (cycle.any { value -> consumed.contains(value) }\n                ) {\n                    continue\n                }\n                cycle.forEach { value -> consumed.add(value) }\n                result.add(ring(cycle))\n            }\n            arcs = (arcs - consumed).toMutableSet()\n            if (arcs.size == 0) {\n                break\n            }\n        }\n        //assert(arcs.size() == 0L)\n        return Region2(result)\n    }\n\n    private fun isTop(c: Curve2): Boolean {\n//        if (c == null) {\n//            return false\n//        }\n        val delta: Double = c.end().x - c.start().x\n        return if (delta == 0.0) {\n            c.end().y > c.start().y\n        } else delta < 0\n    }\n\n\n    private fun classify(\n        region: Region2,\n        arc: Arc\n    ): Type {\n        // we want some point near the middle of the arc which is unlikely to coincide with a vertex, because those\n        // sometimes sit ambiguously on the edge of the other region\n        val result: Ring2.Result = region.test(arc.position(1.0 / E))\n        return if (!result.inside) {\n            Type.OUTSIDE\n        } else if (result.curve == null) {\n            Type.INSIDE\n        } else {\n            if (isTop(arc.first()) == isTop(result.curve))\n                Type.SAME_EDGE else Type.DIFF_EDGE\n        }\n    }\n\n    /**\n     * Cuts the rings of a region at the specified vertices, yielding a list of arcs that will serve as the edges of our\n     * graph.\n     */\n    private fun partition(\n        region: Region2,\n        vertices: Set<Vec2>\n    ): List<Arc> {\n        val result: MutableList<Arc> = mutableListOf()\n        for (r in region.rings) {\n            val cs: Array<Curve2> = r.curves\n            var offset = 0\n            while (offset < cs.size) {\n                if (vertices.contains(cs[offset].start())) {\n                    break\n                }\n                offset++\n            }\n            if (offset == cs.size) {\n                result.add(Arc(cs.toMutableList()))\n            } else {\n                var acc = Arc()\n                for (i in offset until cs.size) {\n                    val c: Curve2 = cs[i]\n                    if (vertices.contains(c.start())) {\n                        if (acc.size > 0) {\n                            result.add(acc)\n                        }\n                        acc = Arc(mutableListOf(c))\n                    } else {\n                        acc.add(c)\n                    }\n                }\n                for (i in 0 until offset) {\n                    acc.add(cs[i])\n                }\n                if (acc.size > 0) {\n                    result.add(acc)\n                }\n            }\n        }\n        return result\n    }\n\n    private val SHORTEST_ARC = { x: Arc, y: Arc -> if (x.length() < y.length()) x else y }\n\n    private fun repairGraph(\n        graph: DirectedGraph<Vec2, Set<Arc>>,\n        unused: Iterable<Arc>\n    ): List<List<Arc>> {\n\n        // create a graph of all the unused arcs\n        val search = DirectedGraph<Vec2, Arc>()\n        for (arc in unused) {\n            search.link(arc.head(), arc.tail(), arc, SHORTEST_ARC)\n        }\n\n        // add in the existing arcs as reversed edges, so we can potentially retract them\n        for (e in graph.edges()) {\n            val arc: Arc = e.value().minByOrNull(\n                { obj -> obj.length() })!!\n\n            search.link(arc.tail(), arc.head(), arc, SHORTEST_ARC)\n        }\n\n        //search.vertices().forEach(v -> System.out.println(VERTICES.indexOf(v) + \" \" + search.out(v).stream().map(VERTICES::indexOf).collect(Lists.linearCollector())));\n        //graph.vertices().forEach(v -> System.out.println(VERTICES.indexOf(v) + \" \" + graph.out(v).stream().map(VERTICES::indexOf).collect(Lists.linearCollector())));\n        val `in` = graph.vertices()\n            .filter { v -> graph.`in`(v).isEmpty() }.toSet()\n        val out = graph.vertices()\n            .filter { v -> graph.out(v).isEmpty() }.toSet()\n        val currIn = (`in` + setOf()).toMutableSet()\n        val currOut = (out + setOf()).toMutableSet()\n\n        // attempt to greedily pair our outs and ins\n        val result = mutableSetOf<List<Arc>>()\n        while (currIn.size > 0 && currOut.size > 0) {\n            val path = Graphs.shortestPath(search, currOut,\n                { value -> `in`.contains(value) },\n                { e -> e.value().length() }\n            )\n            // if our search found a vertex that was previously claimed, we need something better than a greedy search\n            if (path == null || !currIn.contains(path.last())) {\n                break\n            } else {\n                currOut.remove(path.first())\n                currIn.remove(path.last())\n                result.add(edges(path) { from, to -> search.edge(from, to) })\n            }\n        }\n        return if (currIn.size == 0 || currOut.size == 0) {\n            result.toList()\n        } else Combinatorics.permutations(out.toList())\n            .map { vs -> greedyPairing(search, vs, `in`) }\n            .minByOrNull { path -> path.sumOf { arcs -> length(arcs) } }\n            .orEmpty()\n\n        // Do greedy pairings with every possible vertex ordering, and choose the one that results in the shortest aggregate\n        // paths. If `out` is sufficiently large, `permutations` will just return a subset of random shufflings, and it's\n        // possible we won't find a single workable solution this time around.\n    }\n\n    private fun greedyPairing(\n        graph: DirectedGraph<Vec2, Arc>,\n        out: List<Vec2>,\n        `in`: Set<Vec2>\n    ): List<List<Arc>> {\n        val result: MutableList<List<Arc>> = mutableListOf()\n        val currIn = (`in` + setOf<Vec2>()).toMutableSet()\n        for (v in out) {\n            // this will only happen if a vertex needs to have multiple edges added/removed, but we'll just get it on the\n            // next time around\n            if (currIn.size == 0) {\n                break\n            }\n            val path: List<Vec2> = Graphs.shortestPath(graph, listOf(v),\n                { value -> currIn.contains(value) },\n                { e -> e.value().length() }) ?: (return emptyList())\n            currIn.remove(path.last())\n            result.add(edges(path) { from, to -> graph.edge(from, to) })\n        }\n        return result\n    }\n\n    private fun <U, V> edges(vertices: List<U>, edge: (U, U) -> V): List<V> {\n        val result = mutableListOf<V>()\n        for (i in 0 until vertices.size - 1) {\n            result.add(edge(vertices[i], vertices[(i + 1)]))\n        }\n        return result\n    }\n\n    private fun area(arcs: List<Arc>): Double {\n        return abs(arcs.sumOf { arc -> arc.signedArea() })\n    }\n\n    private fun length(arcs: List<Arc>): Double {\n        return abs(arcs.sumOf { arc -> arc.length() })\n    }\n\n    private fun ring(arcs: List<Arc>): Ring2 {\n        val acc: MutableList<Curve2> = mutableListOf()\n        arcs.forEach { arc ->\n            arc.forEach { value -> acc.add(value) }\n        }\n        return Ring2(acc)\n    }\n\n    ///\n    fun union(a: Region2, b: Region2): Region2 {\n        return operation(a, b,\n            Operation.UNION,\n            { t -> t == Type.OUTSIDE || t == Type.SAME_EDGE },\n             { t: Type -> t == Type.OUTSIDE })\n    }\n\n    fun intersection(a: Region2, b: Region2): Region2 {\n        return operation(a, b,\n            Operation.INTERSECTION,\n             { t: Type -> t == Type.INSIDE || t == Type.SAME_EDGE },\n             { t: Type -> t == Type.INSIDE })\n    }\n\n    fun difference(a: Region2, b: Region2): Region2 {\n        return operation(a, b,\n            Operation.DIFFERENCE,\n             { t: Type -> t == Type.OUTSIDE || t == Type.DIFF_EDGE },\n             { t: Type -> t == Type.INSIDE })\n    }\n}","package org.openrndr.kartifex.utils.regions\n\nimport org.openrndr.kartifex.*\nimport org.openrndr.kartifex.utils.Intersections\nimport org.openrndr.kartifex.utils.Intersections.SPATIAL_EPSILON\nimport org.openrndr.kartifex.utils.Scalars\nimport org.openrndr.kartifex.utils.SweepQueue\nimport utils.DoubleAccumulator\n\nobject Split {\n    fun split(a: Region2, b: Region2): Result {\n        val queues = arrayOf<SweepQueue<Curve2>>(SweepQueue(), SweepQueue())\n        addToQueue(a, queues[0])\n        addToQueue(b, queues[1])\n        val union = VertexUnion()\n        val intersections = mutableMapOf<Curve2, DoubleAccumulator>()\n        val cs = arrayOfNulls<Curve2>(2)\n        while (true) {\n            val idx = SweepQueue.next(*queues)\n            cs[idx] = queues[idx].take()\n            if (cs[idx] == null) {\n                break\n            }\n            intersections[cs[idx]?:error(\"null\")] = DoubleAccumulator()\n            for (c in queues[1 - idx].active()) {\n                cs[1 - idx] = c\n                val ts = cs[0]!!.intersections(cs[1]!!)\n                for (i in ts.indices) {\n                    val t0 = ts[i].x\n                    val t1 = ts[i].y\n                    intersections[cs[0]]?.add(t0)\n                    intersections[cs[1]]?.add(t1)\n                    val p0 = cs[0]!!.position(t0)\n                    val p1 = cs[1]!!.position(t1)\n                    union.join(p0, p1)\n                }\n            }\n        }\n        val deduped = intersections.mapValues { (c , acc) -> dedupe(c, acc, union) }\n        return Result(split(a, deduped, union), split(b, deduped, union), union.roots())\n    }\n\n    private fun split(\n        region: Region2,\n        splits: Map<Curve2, DoubleAccumulator>,\n        union: VertexUnion\n    ): Region2 = Region2(region.rings.mapNotNull { ring -> split(ring, splits, union) }.toTypedArray())\n\n    private fun dedupe(\n        c: Curve2,\n        acc: DoubleAccumulator,\n        union: VertexUnion\n    ): DoubleAccumulator {\n        val ts = acc.toArray()\n        ts.sort()\n        val result = DoubleAccumulator()\n        for (i in ts.indices) {\n            val t0 = if (result.size() == 0) 0.0 else result.last()\n            val t1 = ts[i]\n            if (Scalars.equals(t0, t1, Intersections.PARAMETRIC_EPSILON)\n                || Vec.equals(c.position(t0), c.position(t1), Intersections.SPATIAL_EPSILON)\n            ) {\n                union.join(c.position(t0), c.position(t1))\n            } else if (Scalars.equals(t1, 1.0, Intersections.PARAMETRIC_EPSILON)\n                || Vec.equals(c.position(t1), c.end(), Intersections.SPATIAL_EPSILON)\n            ) {\n                union.join(c.position(t1), c.end())\n            } else {\n                result.add(t1)\n            }\n        }\n        return result\n    }\n\n    private fun split(\n        r: Ring2,\n        splits: Map<Curve2, DoubleAccumulator>,\n        union: VertexUnion\n    ): Ring2? {\n        val curves = mutableListOf<Curve2>()\n        for (c in r.curves) {\n            val acc = splits[c]!!\n            for (cp in c.split(acc.toArray())) {\n                val cpa = union.adjust(cp)\n                if (cpa != null) {\n                    curves.add(cpa)\n                }\n            }\n        }\n        return if (curves.size == 0) null else Ring2(curves)\n    }\n\n    private fun addToQueue(region: Region2, queue: SweepQueue<Curve2>) {\n        for (r in region.rings) {\n            for (c in r.curves) {\n                // TODO EJ: determine if taking the extends of the bounding box of the curve is the better solution\n                queue.add(c, c.start().x, c.end().x)\n//                val bounds = c.bounds()\n//                if (!c.isFlat(SPATIAL_EPSILON)) {\n//                    val cs = c.split(c.inflections())\n//                    for (s in cs) {\n//                        queue.add(s, s.bounds().lower().x, s.bounds().upper().x)\n//                    }\n//                } else {\n//                    queue.add(c, bounds.lower().x, bounds.upper().x)\n//                }\n\n            }\n        }\n    }\n\n    internal class VertexUnion {\n        private val parent = mutableMapOf<Vec2, Vec2>()\n        private val roots = mutableSetOf<Vec2>()\n        fun join(a: Vec2, b: Vec2) {\n            @Suppress(\"NAME_SHADOWING\") var a: Vec2 = a\n            @Suppress(\"NAME_SHADOWING\") var b: Vec2 = b\n            a = adjust(a)\n            b = adjust(b)\n            val cmp = a.compareTo(b)\n            when {\n                cmp < 0 -> {\n                    parent[b] = a\n                    roots.add(a)\n                }\n                cmp > 0 -> {\n                    parent[a] = b\n                    roots.add(b)\n                }\n                else -> {\n                    roots.add(b)\n                }\n            }\n        }\n\n        fun adjust(p: Vec2): Vec2 {\n            var curr = p\n            while (true) {\n                val next = parent[curr]\n                if (next == null) {\n                    if (curr != p) {\n                        parent[p] = curr\n                    }\n                    return curr\n                }\n                curr = next\n            }\n        }\n\n        fun adjust(c: Curve2): Curve2? {\n            val start = adjust(c.start())\n            val end = adjust(c.end())\n            return if (start == end) null else c.endpoints(start, end)\n        }\n\n        fun roots(): Set<Vec2> {\n            return (roots - parent.keys)\n        }\n    }\n    class Result(val a: Region2, val b: Region2, val splits: Set<Vec2>)\n}","package org.openrndr.utils\n\n/**\n * @author ztellman\n */\nobject Hashes {\n    fun hash(x: Double): Int {\n        val hash: Long = 31L * x.toBits()\n        return (hash xor (hash ushr 32)).toInt()\n    }\n\n    fun hash(x: Double, y: Double): Int {\n        var hash = 1L\n        hash = hash * 31 + x.toBits()\n        hash = hash * 31 + y.toBits()\n        return (hash xor (hash ushr 32)).toInt()\n    }\n\n    fun hash(x: Double, y: Double, z: Double): Int {\n        var hash = 1L\n        hash = hash * 31 + x.toBits()\n        hash = hash * 31 + y.toBits()\n        hash = hash * 31 + z.toBits()\n        return (hash xor (hash ushr 32)).toInt()\n    }\n\n    fun hash(x: Double, y: Double, z: Double, w: Double): Int {\n        var hash = 1L\n        hash = hash * 31 + x.toBits()\n        hash = hash * 31 + y.toBits()\n        hash = hash * 31 + z.toBits()\n        hash = hash * 31 + w.toBits()\n        return (hash xor (hash ushr 32)).toInt()\n    }\n}","package org.openrndr.ktessellation\n\ninternal class ActiveRegion {\n    var eUp /* upper edge, directed right to left */: GLUhalfEdge? = null\n    var nodeUp /* dictionary node corresponding to eUp */: DictNode? = null\n    var windingNumber /* used to determine which regions are\n                                 * inside the polygon */ = 0\n    var inside /* is this region inside the polygon? */ = false\n    var sentinel /* marks fake edges at t = +/-infinity */ = false\n    var dirty /* marks regions where the upper or lower\n                                 * edge has changed, but we haven't checked\n                                 * whether they intersect yet */ = false\n    var fixUpperEdge /* marks temporary edges introduced when\n                                 * we process a \"right vertex\" (one without\n                                 * any edges leaving to the right) */ = false\n}\n","package org.openrndr.ktessellation\n\nfun <T> arraycopy(src: Array<T>, srcPos: Int, dest: Array<T>, destPos: Int, length: Int) {\n    for (i in 0 until length) {\n        if (i + srcPos >= src.size || i + destPos >= dest.size)\n            break\n        dest[i + destPos] = src[i + srcPos]\n    }\n}\n\nfun arraycopy(src: FloatArray, srcPos: Int, dest: FloatArray, destPos: Int, length: Int) {\n    for (i in 0 until length) {\n        if (i + srcPos >= src.size || i + destPos >= dest.size)\n            break\n        dest[i + destPos] = src[i + srcPos]\n    }\n}\n\n\n","package org.openrndr.ktessellation\n\ninternal class CachedVertex {\n    var coords = DoubleArray(3)\n    var data: Any? = null\n}\n","@file:Suppress(\"UNUSED_PARAMETER\", \"NAME_SHADOWING\", \"unused\")\n\npackage org.openrndr.ktessellation\n\ninternal class Dict private constructor() {\n    var head: DictNode? = null\n    var frame: Any? = null\n    var leq: DictLeq? = null\n\n    interface DictLeq {\n        fun leq(frame: Any, key1: Any, key2: Any): Boolean\n    }\n\n    companion object {\n        fun dictNewDict(frame: Any?, leq: DictLeq?): Dict {\n            val dict = Dict()\n            dict.head = DictNode()\n\n            dict.head?.let {\n                it.key = null\n                it.next = it\n                it.prev = it\n            }\n            dict.frame = frame\n            dict.leq = leq\n            return dict\n        }\n\n        fun dictDeleteDict(dict: Dict) {\n            dict.head = null\n            dict.frame = null\n            dict.leq = null\n        }\n\n        fun dictInsert(dict: Dict, key: Any): DictNode {\n            return dictInsertBefore(dict, dict.head ?: error(\"dict.head == null\"), key)\n        }\n\n        fun dictInsertBefore(\n            dict: Dict,\n            node: DictNode,\n            key: Any\n        ): DictNode {\n            var node: DictNode = node\n            do {\n                node = node.prev ?: error(\"node.prev == null\")\n            } while (node.key != null && !dict.leq!!.leq(dict.frame!!, node.key!!, key))\n            val newNode = DictNode()\n            newNode.key = key\n            newNode.next = node.next\n            node.next?.prev = newNode\n            newNode.prev = node\n            node.next = newNode\n            return newNode\n        }\n\n        fun dictKey(aNode: DictNode): Any? {\n            return aNode.key\n        }\n\n        fun dictSucc(aNode: DictNode): DictNode? {\n            return aNode.next\n        }\n\n        fun dictPred(aNode: DictNode): DictNode? {\n            return aNode.prev\n        }\n\n        fun dictMin(aDict: Dict): DictNode {\n            return aDict.head?.next ?: error(\"head.next == null\")\n        }\n\n        fun dictMax(aDict: Dict): DictNode {\n            return aDict.head?.prev ?: error(\"head.prev == null\")\n        }\n\n        fun dictDelete(dict: Dict?, node: DictNode) {\n            node.next?.prev = node.prev\n            node.prev?.next = node.next\n        }\n\n        fun dictSearch(dict: Dict, key: Any?): DictNode? {\n            var node: DictNode? = dict.head\n            do {\n                node = node?.next\n            } while (node?.key != null && !dict.leq!!.leq(dict.frame!!, key!!, node.key!!))\n            return node\n        }\n    }\n}\n","package org.openrndr.ktessellation\n\ninternal class DictNode {\n    var key: Any? = null\n    var next: DictNode? = null\n    var prev: DictNode? = null\n}\n","@file:Suppress(\"unused\")\n\npackage org.openrndr.ktessellation\n\nobject GLConstants {\n    const val GL_POINTS = 0x0000\n    const val GL_LINES = 0x0001\n    const val GL_LINE_LOOP = 0x0002\n    const val GL_LINE_STRIP = 0x0003\n    const val GL_TRIANGLES = 0x0004\n    const val GL_TRIANGLE_STRIP = 0x0005\n    const val GL_TRIANGLE_FAN = 0x0006\n}","@file:Suppress(\"unused\", \"MemberVisibilityCanBePrivate\")\n\npackage org.openrndr.ktessellation\n\n/*\n * Copyright (c) 2002-2008 LWJGL Project\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * * Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of 'LWJGL' nor the names of\n *   its contributors may be used to endorse or promote products derived\n *   from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * GLU.java\n *\n *\n * Created 23-dec-2003\n * @author Erik Duijs\n */\nobject GLU {\n    const val PI: Float = kotlin.math.PI.toFloat()\n\n    /* Errors: (return value 0 = no error) */\n    const val GLU_INVALID_ENUM = 100900\n    const val GLU_INVALID_VALUE = 100901\n    const val GLU_OUT_OF_MEMORY = 100902\n\n    /****           Tesselation constants            */\n    const val GLU_TESS_MAX_COORD = 1.0e150\n    const val TESS_MAX_COORD = 1.0e150\n\n    /* TessProperty */\n    const val GLU_TESS_WINDING_RULE = 100140\n    const val GLU_TESS_BOUNDARY_ONLY = 100141\n    const val GLU_TESS_TOLERANCE = 100142\n\n    /* TessWinding */\n    const val GLU_TESS_WINDING_ODD = 100130\n    const val GLU_TESS_WINDING_NONZERO = 100131\n    const val GLU_TESS_WINDING_POSITIVE = 100132\n    const val GLU_TESS_WINDING_NEGATIVE = 100133\n    const val GLU_TESS_WINDING_ABS_GEQ_TWO = 100134\n\n    /* TessCallback */\n    const val GLU_TESS_BEGIN = 100100 /* void (CALLBACK*)(GLenum    type)  */\n    const val GLU_TESS_VERTEX = 100101 /* void (CALLBACK*)(void      *data) */\n    const val GLU_TESS_END = 100102 /* void (CALLBACK*)(void)            */\n    const val GLU_TESS_ERROR = 100103 /* void (CALLBACK*)(GLenum    errno) */\n    const val GLU_TESS_EDGE_FLAG = 100104 /* void (CALLBACK*)(GLboolean boundaryEdge)  */\n    const val GLU_TESS_COMBINE = 100105 /* void (CALLBACK*)(GLdouble  coords[3],\n\t                                                            void      *data[4],\n\t                                                            GLfloat   weight[4],\n\t                                                            void      **dataOut)     */\n    const val GLU_TESS_BEGIN_DATA = 100106 /* void (CALLBACK*)(GLenum    type,\n\t                                                            void      *polygon_data) */\n    const val GLU_TESS_VERTEX_DATA = 100107 /* void (CALLBACK*)(void      *data,\n\t                                                            void      *polygon_data) */\n    const val GLU_TESS_END_DATA = 100108 /* void (CALLBACK*)(void      *polygon_data) */\n    const val GLU_TESS_ERROR_DATA = 100109 /* void (CALLBACK*)(GLenum    errno,\n\t                                                            void      *polygon_data) */\n    const val GLU_TESS_EDGE_FLAG_DATA = 100110 /* void (CALLBACK*)(GLboolean boundaryEdge,\n\t                                                            void      *polygon_data) */\n    const val GLU_TESS_COMBINE_DATA = 100111 /* void (CALLBACK*)(GLdouble  coords[3],\n\t                                                            void      *data[4],\n\t                                                            GLfloat   weight[4],\n\t                                                            void      **dataOut,\n\t                                                            void      *polygon_data) */\n\n    /* TessError */\n    const val GLU_TESS_ERROR1 = 100151\n    const val GLU_TESS_ERROR2 = 100152\n    const val GLU_TESS_ERROR3 = 100153\n    const val GLU_TESS_ERROR4 = 100154\n    const val GLU_TESS_ERROR5 = 100155\n    const val GLU_TESS_ERROR6 = 100156\n    const val GLU_TESS_ERROR7 = 100157\n    const val GLU_TESS_ERROR8 = 100158\n    const val GLU_TESS_MISSING_BEGIN_POLYGON: Int = GLU_TESS_ERROR1\n    const val GLU_TESS_MISSING_BEGIN_CONTOUR: Int = GLU_TESS_ERROR2\n    const val GLU_TESS_MISSING_END_POLYGON: Int = GLU_TESS_ERROR3\n    const val GLU_TESS_MISSING_END_CONTOUR: Int = GLU_TESS_ERROR4\n    const val GLU_TESS_COORD_TOO_LARGE: Int = GLU_TESS_ERROR5\n    const val GLU_TESS_NEED_COMBINE_CALLBACK: Int = GLU_TESS_ERROR6\n    fun gluErrorString(error_code: Int): String {\n        return when (error_code) {\n            GLU_INVALID_ENUM -> \"Invalid enum (glu)\"\n            GLU_INVALID_VALUE -> \"Invalid value (glu)\"\n            GLU_OUT_OF_MEMORY -> \"Out of memory (glu)\"\n            GLU_TESS_MISSING_BEGIN_POLYGON -> \"missing begin polygon\"\n            GLU_TESS_MISSING_BEGIN_CONTOUR -> \"missing begin contour\"\n            GLU_TESS_MISSING_END_POLYGON -> \"missing end polygon\"\n            GLU_TESS_MISSING_END_CONTOUR -> \"missing end contour\"\n            GLU_TESS_COORD_TOO_LARGE -> \"tess coord too large\"\n            GLU_TESS_NEED_COMBINE_CALLBACK -> \"tess need combine callback\"\n            else -> \"E_NO_CLUE\"\n        }\n    }\n\n    fun gluNewTess(): GLUtessellator {\n        return GLUtessellatorImpl()\n    }\n}","/*\n* Portions Copyright (C) 2003-2006 Sun Microsystems, Inc.\n* All rights reserved.\n*/\n/*\n** License Applicability. Except to the extent portions of this file are\n** made subject to an alternative license as permitted in the SGI Free\n** Software License B, Version 1.1 (the \"License\"), the contents of this\n** file are subject only to the provisions of the License. You may not use\n** this file except in compliance with the License. You may obtain a copy\n** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600\n** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:\n**\n** http://oss.sgi.com/projects/FreeB\n**\n** Note that, as provided in the License, the Software is distributed on an\n** \"AS IS\" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS\n** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND\n** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A\n** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.\n**\n** NOTE:  The Original Code (as defined below) has been licensed to Sun\n** Microsystems, Inc. (\"Sun\") under the SGI Free Software License B\n** (Version 1.1), shown above (\"SGI License\").   Pursuant to Section\n** 3.2(3) of the SGI License, Sun is distributing the Covered Code to\n** you under an alternative license (\"Alternative License\").  This\n** Alternative License includes all of the provisions of the SGI License\n** except that Section 2.2 and 11 are omitted.  Any differences between\n** the Alternative License and the SGI License are offered solely by Sun\n** and not by SGI.\n**\n** Original Code. The Original Code is: OpenGL Sample Implementation,\n** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,\n** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.\n** Copyright in any portions created by third parties is as indicated\n** elsewhere herein. All Rights Reserved.\n**\n** Additional Notice Provisions: The application programming interfaces\n** established by SGI in conjunction with the Original Code are The\n** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released\n** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version\n** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X\n** Window System(R) (Version 1.3), released October 19, 1998. This software\n** was created using the OpenGL(R) version 1.2.1 Sample Implementation\n** published by SGI, but has not been independently verified as being\n** compliant with the OpenGL(R) version 1.2.1 Specification.\n**\n** Author: Eric Veach, July 1994\n** Java Port: Pepijn VanEeckhoudt, July 2003\n** Java Port: Nathan Parker Burg, August 2003\n** Kotlin Port: Edwin Jakobs, December 2021\n*/\npackage org.openrndr.ktessellation\n\ninternal class GLUhalfEdge(var first: Boolean) {\n    var next /* doubly-linked list (prev==Sym->next) */: GLUhalfEdge? = null\n    var Sym /* same edge, opposite direction */: GLUhalfEdge? = null\n    var Onext /* next edge CCW around origin */: GLUhalfEdge? = null\n    var Lnext /* next edge CCW around left face */: GLUhalfEdge? = null\n    var Org /* origin vertex (Overtex too long) */: GLUvertex? = null\n    var Lface /* left face */: GLUface? = null\n\n    /* Internal data (keep hidden) */\n    var activeRegion /* a region with this upper edge (sweep.c) */: ActiveRegion? = null\n    var winding /* change in winding number when crossing */ = 0\n}","@file:Suppress(\"UNREACHABLE_CODE\", \"SENSELESS_COMPARISON\", \"unused\")\n\npackage org.openrndr.ktessellation\n\n@Suppress(\"UNNECESSARY_NOT_NULL_ASSERTION\")\nopen class GLUtessellatorImpl : GLUtessellator {\n    private var state /* what begin/end calls have we seen? */: Int\n    private var lastEdge /* lastEdge->Org is the most recent vertex */: GLUhalfEdge? =\n        null\n    internal var mesh: GLUmesh? = null\n    /* stores the input contours, and eventually\n                                   the tessellation itself */\n\n    /*** state needed for projecting onto the sweep plane  */\n    var normal = DoubleArray(3) /* user-specified normal (if provided) */\n    var sUnit = DoubleArray(3) /* unit vector in s-direction (debugging) */\n    var tUnit = DoubleArray(3) /* unit vector in t-direction (debugging) */\n\n    /*** state needed for the line sweep  */\n    private var relTolerance /* tolerance for merging features */: Double\n    var windingRule /* rule for determining polygon interior */: Int\n    var fatalError /* fatal error: needed combine callback */ = false\n    internal var dict /* edge dictionary for sweep line */: Dict? = null\n    internal var pq /* priority queue of vertex events */: PriorityQ? = null\n    internal var event /* current sweep event being processed */: GLUvertex? = null\n\n    /*** state needed for rendering callbacks (see render.c)  */\n    var flagBoundary /* mark boundary edges (use EdgeFlag) */: Boolean\n    var boundaryOnly /* Extract contours, not triangles */: Boolean\n    internal var lonelyTriList: GLUface? = null\n    /* list of triangles which could not be rendered as strips or fans */\n    /*** state needed to cache single-contour polygons for renderCache()  */\n    private var flushCacheOnNextVertex /* empty cache on next vertex() call */ = false\n    var cacheCount /* number of cached vertices */ = 0\n    internal var cache: Array<CachedVertex?> =\n        arrayOfNulls(\n            TESS_MAX_CACHE\n        ) /* the vertex data */\n\n    /*** rendering callbacks that also pass polygon data   */\n    private var polygonData /* client data for current polygon */: Any?\n    private var callBegin: GLUtessellatorCallback\n    private var callEdgeFlag: GLUtessellatorCallback\n    private var callVertex: GLUtessellatorCallback\n    private var callEnd: GLUtessellatorCallback\n\n    //    private GLUtessellatorCallback callMesh;\n    private var callError: GLUtessellatorCallback\n    private var callCombine: GLUtessellatorCallback\n    private var callBeginData: GLUtessellatorCallback\n    private var callEdgeFlagData: GLUtessellatorCallback\n    private var callVertexData: GLUtessellatorCallback\n    private var callEndData: GLUtessellatorCallback\n\n    //    private GLUtessellatorCallback callMeshData;\n    private var callErrorData: GLUtessellatorCallback\n    private var callCombineData: GLUtessellatorCallback\n    private fun makeDormant() {\n        /* Return the tessellator to its original dormant state. */\n        if (mesh != null) {\n            Mesh.__gl_meshDeleteMesh(mesh!!)\n        }\n        state = TessState.T_DORMANT\n        lastEdge = null\n        mesh = null\n    }\n\n    private fun requireState(newState: Int) {\n        check(state == newState) { \"state should be $newState is $state\" }\n        //if (state != newState) gotoState(newState);\n    }\n\n    private fun gotoState(newState: Int) {\n        println(\"requesting new state! $newState current state is $state\")\n        while (state != newState) {\n            /* We change the current state one level at a time, to get to\n             * the desired state.\n             */\n            if (state < newState) {\n                if (state == TessState.T_DORMANT) {\n                    callErrorOrErrorData(GLU.GLU_TESS_MISSING_BEGIN_POLYGON)\n                    gluTessBeginPolygon(null)\n                } else if (state == TessState.T_IN_POLYGON) {\n                    callErrorOrErrorData(GLU.GLU_TESS_MISSING_BEGIN_CONTOUR)\n                    gluTessBeginContour()\n                }\n            } else {\n                if (state == TessState.T_IN_CONTOUR) {\n                    callErrorOrErrorData(GLU.GLU_TESS_MISSING_END_CONTOUR)\n                    gluTessEndContour()\n                } else if (state == TessState.T_IN_POLYGON) {\n                    callErrorOrErrorData(GLU.GLU_TESS_MISSING_END_POLYGON)\n                    /* gluTessEndPolygon( tess ) is too much work! */makeDormant()\n                }\n            }\n        }\n    }\n\n    override fun gluDeleteTess() {\n        requireState(TessState.T_DORMANT)\n    }\n\n    override fun gluTessProperty(which: Int, value: Double) {\n        when (which) {\n            GLU.GLU_TESS_TOLERANCE -> {\n                if (value < 0.0 || value > 1.0) return\n                relTolerance = value\n                return\n            }\n            GLU.GLU_TESS_WINDING_RULE -> {\n                val windingRule = value.toInt()\n                if (windingRule.toDouble() != value) return /* not an integer */\n                when (windingRule) {\n                    GLU.GLU_TESS_WINDING_ODD, GLU.GLU_TESS_WINDING_NONZERO, GLU.GLU_TESS_WINDING_POSITIVE, GLU.GLU_TESS_WINDING_NEGATIVE, GLU.GLU_TESS_WINDING_ABS_GEQ_TWO -> {\n                        this.windingRule = windingRule\n                        return\n                    }\n                    else -> {}\n                }\n                boundaryOnly = value != 0.0\n                return\n            }\n            GLU.GLU_TESS_BOUNDARY_ONLY -> {\n                boundaryOnly = value != 0.0\n                return\n            }\n            else -> {\n                callErrorOrErrorData(GLU.GLU_INVALID_ENUM)\n                return\n            }\n        }\n        callErrorOrErrorData(GLU.GLU_INVALID_VALUE)\n    }\n\n    /* Returns tessellator property */\n    override fun gluGetTessProperty(which: Int, value: DoubleArray, value_offset: Int) {\n        when (which) {\n            GLU.GLU_TESS_TOLERANCE -> {\n                require(relTolerance in 0.0..1.0)\n                value[value_offset] = relTolerance\n            }\n            GLU.GLU_TESS_WINDING_RULE -> {\n                require(windingRule == GLU.GLU_TESS_WINDING_ODD || windingRule == GLU.GLU_TESS_WINDING_NONZERO || windingRule == GLU.GLU_TESS_WINDING_POSITIVE || windingRule == GLU.GLU_TESS_WINDING_NEGATIVE || windingRule == GLU.GLU_TESS_WINDING_ABS_GEQ_TWO)\n                value[value_offset] = windingRule.toDouble()\n            }\n            GLU.GLU_TESS_BOUNDARY_ONLY -> {\n                //require(boundaryOnly == true || boundaryOnly == false)\n                value[value_offset] = if (boundaryOnly) 1.0 else 0.0\n            }\n            else -> {\n                value[value_offset] = 0.0\n                callErrorOrErrorData(GLU.GLU_INVALID_ENUM)\n            }\n        }\n    } /* gluGetTessProperty() */\n\n    override fun gluTessNormal(x: Double, y: Double, z: Double) {\n        normal[0] = x\n        normal[1] = y\n        normal[2] = z\n    }\n\n    override fun gluTessCallback(which: Int, aCallback: GLUtessellatorCallback?) {\n        when (which) {\n            GLU.GLU_TESS_BEGIN -> {\n                callBegin = aCallback ?: NULL_CB\n                return\n            }\n            GLU.GLU_TESS_BEGIN_DATA -> {\n                callBeginData = aCallback ?: NULL_CB\n                return\n            }\n            GLU.GLU_TESS_EDGE_FLAG -> {\n                callEdgeFlag = aCallback ?: NULL_CB\n                /* If the client wants boundary edges to be flagged,\n * we render everything as separate triangles (no strips or fans).\n */flagBoundary = aCallback != null\n                return\n            }\n            GLU.GLU_TESS_EDGE_FLAG_DATA -> {\n                run {\n                    callBegin = aCallback ?: NULL_CB\n                    callEdgeFlagData = callBegin\n                }\n                /* If the client wants boundary edges to be flagged,\n * we render everything as separate triangles (no strips or fans).\n */flagBoundary = aCallback != null\n                return\n            }\n            GLU.GLU_TESS_VERTEX -> {\n                callVertex = aCallback ?: NULL_CB\n                return\n            }\n            GLU.GLU_TESS_VERTEX_DATA -> {\n                callVertexData = aCallback ?: NULL_CB\n                return\n            }\n            GLU.GLU_TESS_END -> {\n                callEnd = aCallback ?: NULL_CB\n                return\n            }\n            GLU.GLU_TESS_END_DATA -> {\n                callEndData = aCallback ?: NULL_CB\n                return\n            }\n            GLU.GLU_TESS_ERROR -> {\n                callError = aCallback ?: NULL_CB\n                return\n            }\n            GLU.GLU_TESS_ERROR_DATA -> {\n                callErrorData = aCallback ?: NULL_CB\n                return\n            }\n            GLU.GLU_TESS_COMBINE -> {\n                callCombine = aCallback ?: NULL_CB\n                return\n            }\n            GLU.GLU_TESS_COMBINE_DATA -> {\n                callCombineData = aCallback ?: NULL_CB\n                return\n            }\n            else -> {\n                callErrorOrErrorData(GLU.GLU_INVALID_ENUM)\n                return\n            }\n        }\n    }\n\n    private fun addVertex(coords: DoubleArray, vertexData: Any?): Boolean {\n        var e: GLUhalfEdge?\n        e = lastEdge\n        if (e == null) {\n/* Make a self-loop (one vertex, one edge). */\n            e = Mesh.__gl_meshMakeEdge(mesh ?: error(\"mesh == null\"))\n            if (e == null) return false\n            if (!Mesh.__gl_meshSplice(e, e.Sym ?: error(\"e.Sym == null\"))) return false\n        } else {\n/* Create a new vertex and edge which immediately follow e\n * in the ordering around the left face.\n */\n            if (Mesh.__gl_meshSplitEdge(e) == null) return false\n            e = e.Lnext\n        }\n\n/* The new vertex is now e.Org. */\n        e!!.Org!!.data = vertexData\n        e!!.Org!!.coords[0] = coords[0]\n        e!!.Org!!.coords[1] = coords[1]\n        e!!.Org!!.coords[2] = coords[2]\n\n/* The winding of an edge says how the winding number changes as we\n * cross from the edge''s right face to its left face.  We add the\n * vertices in such an order that a CCW contour will add +1 to\n * the winding number of the region inside the contour.\n */e.winding = 1\n        e.Sym!!.winding = -1\n        lastEdge = e\n        return true\n    }\n\n    private fun cacheVertex(coords: DoubleArray, vertexData: Any?) {\n        if (cache[cacheCount] == null) {\n            cache[cacheCount] = CachedVertex()\n        }\n        val v: CachedVertex = cache[cacheCount] ?: error(\"cache[cacheCount] == null\")\n        v.data = vertexData\n        v.coords[0] = coords[0]\n        v.coords[1] = coords[1]\n        v.coords[2] = coords[2]\n        ++cacheCount\n    }\n\n    private fun flushCache(): Boolean {\n        val v: Array<CachedVertex?> = cache\n        mesh = Mesh.__gl_meshNewMesh()\n        if (mesh == null) return false\n        for (i in 0 until cacheCount) {\n            val vertex: CachedVertex = v[i] ?: error(\"v[i] == null\")\n            if (!addVertex(vertex.coords, vertex.data)) return false\n        }\n        cacheCount = 0\n        flushCacheOnNextVertex = false\n        return true\n    }\n\n    override fun gluTessVertex(coords: DoubleArray, coords_offset: Int, vertexData: Any?) {\n        var tooLarge = false\n        var x: Double\n        val clamped = DoubleArray(3)\n        requireState(TessState.T_IN_CONTOUR)\n        if (flushCacheOnNextVertex) {\n            if (!flushCache()) {\n                callErrorOrErrorData(GLU.GLU_OUT_OF_MEMORY)\n                return\n            }\n            lastEdge = null\n        }\n        var i = 0\n        while (i < 3) {\n            x = coords[i + coords_offset]\n            if (x < -GLU.GLU_TESS_MAX_COORD) {\n                x = -GLU.GLU_TESS_MAX_COORD\n                tooLarge = true\n            }\n            if (x > GLU.GLU_TESS_MAX_COORD) {\n                x = GLU.GLU_TESS_MAX_COORD\n                tooLarge = true\n            }\n            clamped[i] = x\n            ++i\n        }\n        if (tooLarge) {\n            callErrorOrErrorData(GLU.GLU_TESS_COORD_TOO_LARGE)\n        }\n        if (mesh == null) {\n            if (cacheCount < TESS_MAX_CACHE) {\n                cacheVertex(clamped, vertexData)\n                return\n            }\n            if (!flushCache()) {\n                callErrorOrErrorData(GLU.GLU_OUT_OF_MEMORY)\n                return\n            }\n        }\n        if (!addVertex(clamped, vertexData)) {\n            callErrorOrErrorData(GLU.GLU_OUT_OF_MEMORY)\n        }\n    }\n\n    override fun gluTessBeginPolygon(data: Any?) {\n        requireState(TessState.T_DORMANT)\n        state = TessState.T_IN_POLYGON\n        cacheCount = 0\n        flushCacheOnNextVertex = false\n        mesh = null\n        polygonData = data\n    }\n\n    override fun gluTessBeginContour() {\n        requireState(TessState.T_IN_POLYGON)\n        state = TessState.T_IN_CONTOUR\n        lastEdge = null\n        if (cacheCount > 0) {\n/* Just set a flag so we don't get confused by empty contours\n * -- these can be generated accidentally with the obsolete\n * NextContour() interface.\n */\n            flushCacheOnNextVertex = true\n        }\n    }\n\n    override fun gluTessEndContour() {\n        requireState(TessState.T_IN_CONTOUR)\n        state = TessState.T_IN_POLYGON\n    }\n\n    override fun gluTessEndPolygon() {\n        val mesh: GLUmesh?\n        try {\n            requireState(TessState.T_IN_POLYGON)\n            state = TessState.T_DORMANT\n            if (this.mesh == null) {\n                if (!flagBoundary /*&& callMesh == NULL_CB*/) {\n\n/* Try some special code to make the easy cases go quickly\n * (eg. convex polygons).  This code does NOT handle multiple contours,\n * intersections, edge flags, and of course it does not generate\n * an explicit mesh either.\n */\n                    if (Render.__gl_renderCache(this)) {\n                        polygonData = null\n                        return\n                    }\n                }\n                if (!flushCache()) throw RuntimeException() /* could've used a label*/\n            }\n\n/* Determine the polygon normal and project vertices onto the plane\n         * of the polygon.\n         */Normal.__gl_projectPolygon(this)\n\n/* __gl_computeInterior( tess ) computes the planar arrangement specified\n * by the given contours, and further subdivides this arrangement\n * into regions.  Each region is marked \"inside\" if it belongs\n * to the polygon, according to the rule given by windingRule.\n * Each interior region is guaranteed be monotone.\n */\n            if (!Sweep.__gl_computeInterior(this)) {\n                throw RuntimeException() /* could've used a label */\n            }\n            mesh = this.mesh\n            if (!fatalError) {\n\n/* If the user wants only the boundary contours, we throw away all edges\n * except those which separate the interior from the exterior.\n * Otherwise we tessellate all the regions marked \"inside\".\n */\n                val rc: Boolean = if (boundaryOnly) {\n                    TessMono.__gl_meshSetWindingNumber(mesh!!, 1, true)\n                } else {\n                    TessMono.__gl_meshTessellateInterior(mesh!!)\n                }\n                if (!rc) throw RuntimeException() /* could've used a label */\n                Mesh.__gl_meshCheckMesh(mesh)\n                if (callBegin !== NULL_CB || callEnd !== NULL_CB || callVertex !== NULL_CB || callEdgeFlag !== NULL_CB || callBeginData !== NULL_CB || callEndData !== NULL_CB || callVertexData !== NULL_CB || callEdgeFlagData !== NULL_CB) {\n                    if (boundaryOnly) {\n                        Render.__gl_renderBoundary(this, mesh) /* output boundary contours */\n                    } else {\n                        Render.__gl_renderMesh(this, mesh) /* output strips and fans */\n                    }\n                }\n                //                if (callMesh != NULL_CB) {\n//\n///* Throw away the exterior faces, so that all faces are interior.\n//                 * This way the user doesn't have to check the \"inside\" flag,\n//                 * and we don't need to even reveal its existence.  It also leaves\n//                 * the freedom for an implementation to not generate the exterior\n//                 * faces in the first place.\n//                 */\n//                    TessMono.__gl_meshDiscardExterior(mesh);\n//                    callMesh.mesh(mesh);\t\t/* user wants the mesh itself */\n//                    mesh = null;\n//                    polygonData = null;\n//                    return;\n//                }\n            }\n            Mesh.__gl_meshDeleteMesh(mesh!!)\n            polygonData = null\n        } catch (e: Exception) {\n            e.printStackTrace()\n            callErrorOrErrorData(GLU.GLU_OUT_OF_MEMORY)\n        }\n    }\n\n    /** */ /* Obsolete calls -- for backward compatibility */\n    override fun gluBeginPolygon() {\n        gluTessBeginPolygon(null)\n        gluTessBeginContour()\n    }\n\n    /*ARGSUSED*/\n    override fun gluNextContour(type: Int) {\n        gluTessEndContour()\n        gluTessBeginContour()\n    }\n\n    override fun gluEndPolygon() {\n        gluTessEndContour()\n        gluTessEndPolygon()\n    }\n\n    fun callBeginOrBeginData(a: Int) {\n        if (callBeginData !== NULL_CB) callBeginData.beginData(a, polygonData) else callBegin.begin(a)\n    }\n\n    fun callVertexOrVertexData(a: Any?) {\n        if (callVertexData !== NULL_CB) callVertexData.vertexData(a, polygonData) else callVertex.vertex(a)\n    }\n\n    fun callEdgeFlagOrEdgeFlagData(a: Boolean) {\n        if (callEdgeFlagData !== NULL_CB) callEdgeFlagData.edgeFlagData(a, polygonData) else callEdgeFlag.edgeFlag(a)\n    }\n\n    fun callEndOrEndData() {\n        if (callEndData !== NULL_CB) callEndData.endData(polygonData) else callEnd.end()\n    }\n\n    fun callCombineOrCombineData(\n        coords: DoubleArray?,\n        vertexData: Array<Any?>?,\n        weights: FloatArray?,\n        outData: Array<Any?>?\n    ) {\n        if (callCombineData !== NULL_CB) callCombineData.combineData(\n            coords,\n            vertexData,\n            weights,\n            outData,\n            polygonData\n        ) else callCombine.combine(coords, vertexData, weights, outData)\n    }\n\n    fun callErrorOrErrorData(a: Int) {\n        if (callErrorData !== NULL_CB) callErrorData.errorData(a, polygonData) else callError.error(a)\n    }\n\n    companion object {\n        const val TESS_MAX_CACHE = 100\n        private const val GLU_TESS_DEFAULT_TOLERANCE = 0.0\n\n        //    private static final int GLU_TESS_MESH = 100112;\t/* void (*)(GLUmesh *mesh)\t    */\n        private val NULL_CB: GLUtessellatorCallback =\n            GLUtessellatorCallbackAdapter()\n\n        fun gluNewTess(): GLUtessellator {\n            return GLUtessellatorImpl()\n        }\n    }\n\n    //    #define MAX_FAST_ALLOC\t(MAX(sizeof(EdgePair), \\\n    //                 MAX(sizeof(GLUvertex),sizeof(GLUface))))\n    init {\n        state = TessState.T_DORMANT\n        normal[0] = 0.0\n        normal[1] = 0.0\n        normal[2] = 0.0\n        relTolerance = GLU_TESS_DEFAULT_TOLERANCE\n        windingRule = GLU.GLU_TESS_WINDING_ODD\n        flagBoundary = false\n        boundaryOnly = false\n        callBegin = NULL_CB\n        callEdgeFlag = NULL_CB\n        callVertex = NULL_CB\n        callEnd = NULL_CB\n        callError = NULL_CB\n        callCombine = NULL_CB\n        //        callMesh = NULL_CB;\n        callBeginData = NULL_CB\n        callEdgeFlagData = NULL_CB\n        callVertexData = NULL_CB\n        callEndData = NULL_CB\n        callErrorData = NULL_CB\n        callCombineData = NULL_CB\n        polygonData = null\n        for (i in cache.indices) {\n            cache[i] = CachedVertex()\n        }\n    }\n}\n","package org.openrndr.ktessellation\n\n\ninternal class GLUface {\n    var next /* next face (never NULL) */: GLUface? = null\n    var prev /* previous face (never NULL) */: GLUface? = null\n    var anEdge /* a half edge with this left face */: GLUhalfEdge? = null\n    var data /* room for client's data */: Any? = null\n\n    /* Internal data (keep hidden) */\n    var trail /* \"stack\" for conversion to strips */: GLUface? = null\n    var marked /* flag for conversion to strips */ = false\n    var inside /* this face is in the polygon interior */ = false\n}\n\n","package org.openrndr.ktessellation\n\n\ninternal class GLUmesh {\n    var vHead: GLUvertex =\n        GLUvertex() /* dummy header for vertex list */\n    var fHead: GLUface =\n        GLUface() /* dummy header for face list */\n    var eHead: GLUhalfEdge =\n        GLUhalfEdge(true) /* dummy header for edge list */\n    var eHeadSym: GLUhalfEdge =\n        GLUhalfEdge(false) /* and its symmetric counterpart */\n}\n","@file:Suppress(\"SpellCheckingInspection\")\n\npackage org.openrndr.ktessellation\n\ninternal class GLUvertex {\n    var next /* next vertex (never NULL) */: GLUvertex? = null\n    var prev /* previous vertex (never NULL) */: GLUvertex? = null\n    var anEdge /* a half-edge with this origin */: GLUhalfEdge? = null\n    var data /* client's data */: Any? = null\n\n    /* Internal data (keep hidden) */\n    var coords = DoubleArray(3) /* vertex location in 3D */\n    var s = 0.0\n    var t /* projection onto the sweep plane */ = 0.0\n    var pqHandle /* to allow deletion from priority queue */ = 0\n}\n","@file:Suppress(\n    \"UNNECESSARY_NOT_NULL_ASSERTION\", \"FloatingPointLiteralPrecision\", \"MemberVisibilityCanBePrivate\",\n    \"FunctionName\"\n)\n\npackage org.openrndr.ktessellation\n\nimport kotlin.math.abs\nimport kotlin.math.sqrt\n\ninternal object Normal {\n    var SLANTED_SWEEP = false\n    var S_UNIT_X /* Pre-normalized */ = 0.0\n    var S_UNIT_Y = 0.0\n    private const val TRUE_PROJECT = false\n    private fun Dot(u: DoubleArray, v: DoubleArray): Double {\n        return u[0] * v[0] + u[1] * v[1] + u[2] * v[2]\n    }\n\n    fun Normalize(v: DoubleArray) {\n        var len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2]\n        require(len > 0)\n        len = sqrt(len)\n        v[0] /= len\n        v[1] /= len\n        v[2] /= len\n    }\n\n    fun LongAxis(v: DoubleArray): Int {\n        var i = 0\n        if (abs(v[1]) > abs(v[0])) {\n            i = 1\n        }\n        if (abs(v[2]) > abs(v[i])) {\n            i = 2\n        }\n        return i\n    }\n\n    fun ComputeNormal(tess: GLUtessellatorImpl, norm: DoubleArray) {\n        var v: GLUvertex\n        val v1: GLUvertex\n        val v2: GLUvertex\n        var c: Double\n        var tLen2: Double\n        var maxLen2: Double\n        val vHead: GLUvertex = tess.mesh!!.vHead\n        var i: Int\n        val maxVal = DoubleArray(3)\n        val minVal = DoubleArray(3)\n        val minVert: Array<GLUvertex?> = arrayOfNulls(3)\n        val maxVert: Array<GLUvertex?> = arrayOfNulls(3)\n        val d1 = DoubleArray(3)\n        val d2 = DoubleArray(3)\n        val tNorm = DoubleArray(3)\n        maxVal[2] = -2 * GLU.TESS_MAX_COORD\n        maxVal[1] = maxVal[2]\n        maxVal[0] = maxVal[1]\n        minVal[2] = 2 * GLU.TESS_MAX_COORD\n        minVal[1] = minVal[2]\n        minVal[0] = minVal[1]\n        v = vHead.next ?: error(\"vhead next == null\")\n        while (v !== vHead) {\n            i = 0\n            while (i < 3) {\n                c = v.coords[i]\n                if (c < minVal[i]) {\n                    minVal[i] = c\n                    minVert[i] = v\n                }\n                if (c > maxVal[i]) {\n                    maxVal[i] = c\n                    maxVert[i] = v\n                }\n                ++i\n            }\n            v = v.next ?: error(\"v.next == null\")\n        }\n\n/* Find two vertices separated by at least 1/sqrt(3) of the maximum\n         * distance between any two vertices\n         */i = 0\n        if (maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) {\n            i = 1\n        }\n        if (maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) {\n            i = 2\n        }\n        if (minVal[i] >= maxVal[i]) {\n/* All vertices are the same -- normal doesn't matter */\n            norm[0] = 0.0\n            norm[1] = 0.0\n            norm[2] = 1.0\n            return\n        }\n\n/* Look for a third vertex which forms the triangle with maximum area\n         * (Length of normal == twice the triangle area)\n         */maxLen2 = 0.0\n        v1 = minVert[i] ?: error(\"minVert[$i] == null\")\n        v2 = maxVert[i] ?: error(\"maxVert[$i] == null\")\n        d1[0] = v1.coords[0] - v2.coords[0]\n        d1[1] = v1.coords[1] - v2.coords[1]\n        d1[2] = v1.coords[2] - v2.coords[2]\n        v = vHead.next ?: error(\"vHead.next == null\")\n        while (v !== vHead) {\n            d2[0] = v.coords[0] - v2.coords[0]\n            d2[1] = v.coords[1] - v2.coords[1]\n            d2[2] = v.coords[2] - v2.coords[2]\n            tNorm[0] = d1[1] * d2[2] - d1[2] * d2[1]\n            tNorm[1] = d1[2] * d2[0] - d1[0] * d2[2]\n            tNorm[2] = d1[0] * d2[1] - d1[1] * d2[0]\n            tLen2 = tNorm[0] * tNorm[0] + tNorm[1] * tNorm[1] + tNorm[2] * tNorm[2]\n            if (tLen2 > maxLen2) {\n                maxLen2 = tLen2\n                norm[0] = tNorm[0]\n                norm[1] = tNorm[1]\n                norm[2] = tNorm[2]\n            }\n            v = v.next ?: error(\"v.next == null\")\n        }\n        if (maxLen2 <= 0) {\n/* All points lie on a single line -- any decent normal will do */\n            norm[2] = 0.0\n            norm[1] = norm[2]\n            norm[0] = norm[1]\n            norm[LongAxis(d1)] = 1.0\n        }\n    }\n\n    fun CheckOrientation(tess: GLUtessellatorImpl) {\n        var f: GLUface\n        val fHead: GLUface = tess.mesh!!.fHead\n        var v: GLUvertex\n        val vHead: GLUvertex = tess.mesh!!.vHead\n        var e: GLUhalfEdge\n\n/* When we compute the normal automatically, we choose the orientation\n * so that the the sum of the signed areas of all contours is non-negative.\n */\n        var area = 0.0\n        f = fHead.next ?: error(\"fHead.next == null\")\n        while (f !== fHead) {\n            e = f.anEdge ?: error(\"f.anEdge == null\")\n            if (e.winding <= 0) {\n                f = f.next ?: error(\"f.next == null\")\n                continue\n            }\n            do {\n                area += (e.Org!!.s - e.Sym!!.Org!!.s) * (e!!.Org!!.t + e!!.Sym!!.Org!!.t)\n                e = e.Lnext ?: error(\"e.Lnext == null\")\n            } while (e !== f.anEdge)\n            f = f.next ?: error(\"f.next == null\")\n        }\n        if (area < 0) {\n/* Reverse the orientation by flipping all the t-coordinates */\n            v = vHead.next ?: error(\"vHead.next == null\")\n            while (v !== vHead) {\n                v.t = -v.t\n                v = v.next ?: error(\"v.next == null\")\n            }\n            tess.tUnit[0] = -tess.tUnit[0]\n            tess.tUnit[1] = -tess.tUnit[1]\n            tess.tUnit[2] = -tess.tUnit[2]\n        }\n    }\n\n    /* Determine the polygon normal and project vertices onto the plane\n * of the polygon.\n */\n    @Suppress(\"FunctionName\")\n    fun __gl_projectPolygon(tess: GLUtessellatorImpl) {\n        var v: GLUvertex\n        val vHead: GLUvertex = tess.mesh!!.vHead\n        val w: Double\n        val norm = DoubleArray(3)\n        var computedNormal = false\n        norm[0] = tess.normal[0]\n        norm[1] = tess.normal[1]\n        norm[2] = tess.normal[2]\n        if (norm[0] == 0.0 && norm[1] == 0.0 && norm[2] == 0.0) {\n            ComputeNormal(tess, norm)\n            computedNormal = true\n        }\n        val sUnit: DoubleArray = tess.sUnit\n        val tUnit: DoubleArray = tess.tUnit\n        val i: Int = LongAxis(norm)\n        if (TRUE_PROJECT) {\n/* Choose the initial sUnit vector to be approximately perpendicular\n * to the normal.\n */\n            Normalize(norm)\n            sUnit[i] = 0.0\n            sUnit[(i + 1) % 3] = S_UNIT_X\n            sUnit[(i + 2) % 3] = S_UNIT_Y\n\n/* Now make it exactly perpendicular */w = Dot(sUnit, norm)\n            sUnit[0] -= w * norm[0]\n            sUnit[1] -= w * norm[1]\n            sUnit[2] -= w * norm[2]\n            Normalize(sUnit)\n\n/* Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame */tUnit[0] =\n                norm[1] * sUnit[2] - norm[2] * sUnit[1]\n            tUnit[1] = norm[2] * sUnit[0] - norm[0] * sUnit[2]\n            tUnit[2] = norm[0] * sUnit[1] - norm[1] * sUnit[0]\n            Normalize(tUnit)\n        } else {\n/* Project perpendicular to a coordinate axis -- better numerically */\n            sUnit[i] = 0.0\n            sUnit[(i + 1) % 3] = S_UNIT_X\n            sUnit[(i + 2) % 3] = S_UNIT_Y\n            tUnit[i] = 0.0\n            tUnit[(i + 1) % 3] = if (norm[i] > 0) -S_UNIT_Y else S_UNIT_Y\n            tUnit[(i + 2) % 3] = if (norm[i] > 0) S_UNIT_X else -S_UNIT_X\n        }\n\n/* Project the vertices onto the sweep plane */\n        v = vHead.next ?: error(\"vHead.next == null\")\n        while (v !== vHead) {\n            v.s = Dot(v.coords, sUnit)\n            v.t = Dot(v.coords, tUnit)\n            v = v.next ?: error(\"v.next == null\")\n        }\n        if (computedNormal) {\n            CheckOrientation(tess)\n        }\n    }\n\n    init {\n        if (SLANTED_SWEEP) {\n/* The \"feature merging\" is not intended to be complete.  There are\n * special cases where edges are nearly parallel to the sweep line\n * which are not implemented.  The algorithm should still behave\n * robustly (ie. produce a reasonable tesselation) in the presence\n * of such edges, however it may miss features which could have been\n * merged.  We could minimize this effect by choosing the sweep line\n * direction to be something unusual (ie. not parallel to one of the\n * coordinate axes).\n */\n            S_UNIT_X = 0.50941539564955385 /* Pre-normalized */\n            S_UNIT_Y = 0.86052074622010633\n        } else {\n            S_UNIT_X = 1.0\n            S_UNIT_Y = 0.0\n        }\n    }\n}\n","package org.openrndr.ktessellation\n\nimport org.openrndr.math.Vector2\n\nclass Primitive(\n    /**\n     * The OpenGL constant defining the type of this primitive\n     *\n     */\n    val type: Int\n) {\n    /**\n     * A list of the indices of the vertices required to draw this primitive.\n     *\n     */\n    val positions: MutableList<Vector2> = mutableListOf()\n}","@file:Suppress(\"UNUSED_PARAMETER\")\n\npackage org.openrndr.ktessellation\n\n@Suppress(\"FunctionName\")\ninternal abstract class PriorityQ {\n    class PQnode {\n        var handle = 0\n    }\n\n    class PQhandleElem {\n        var key: Any? = null\n        var node = 0\n    }\n\n    interface Leq {\n        fun leq(key1: Any?, key2: Any?): Boolean\n    }\n\n    abstract fun pqDeletePriorityQ()\n    abstract fun pqInit(): Boolean\n    abstract fun pqInsert(keyNew: Any?): Int\n    abstract fun pqExtractMin(): Any?\n    abstract fun pqDelete(hCurr: Int)\n    abstract fun pqMinimum(): Any?\n    abstract fun pqIsEmpty(): Boolean //    #endif\n\n    companion object {\n        const val INIT_SIZE = 32\n\n        //    #ifdef FOR_TRITE_TEST_PROGRAM\n        //    private static boolean LEQ(PriorityQCommon.Leq leq, Object x,Object y) {\n        //        return pq.leq.leq(x,y);\n        //    }\n        //    #else\n        /* Violates modularity, but a little faster */ //    #include \"geom.h\"\n        fun LEQ(leq: Leq, x: Any, y: Any): Boolean {\n            return Geom.VertLeq(\n                x as GLUvertex,\n                y as GLUvertex\n            )\n        }\n\n        fun pqNewPriorityQ(leq: Leq): PriorityQ {\n            return PriorityQSort(leq)\n        }\n    }\n}\n","@file:Suppress(\"NAME_SHADOWING\", \"FunctionName\", \"ConvertTwoComparisonsToRangeCheck\")\n\npackage org.openrndr.ktessellation\n\n@Suppress(\"MemberVisibilityCanBePrivate\")\ninternal class PriorityQHeap(val leq: Leq) :\n    PriorityQ() {\n    var nodes: Array<PQnode?>?\n    var handles: Array<PQhandleElem?>?\n    var size = 0\n    var max: Int\n    var freeList: Int\n    var initialized: Boolean\n\n    /* really __gl_pqHeapDeletePriorityQ */\n    override fun pqDeletePriorityQ() {\n        handles = null\n        nodes = null\n    }\n\n    fun FloatDown(curr: Int) {\n        var curr = curr\n        val n: Array<PQnode?>? = nodes\n        val h: Array<PQhandleElem?>? = handles\n        var hChild: Int\n        var child: Int\n        val hCurr: Int = n!![curr]!!.handle\n        while (true) {\n            child = curr shl 1\n            if (child < size && LEQ(\n                    leq, h!![n[child + 1]!!.handle]!!.key!!,\n                    h[n[child]!!.handle]!!.key!!\n                )\n            ) {\n                ++child\n            }\n            require(child <= max)\n            hChild = n[child]!!.handle\n            if (child > size || LEQ(leq, h!![hCurr]!!.key!!, h[hChild]!!.key!!)) {\n                n[curr]!!.handle = hCurr\n                h!![hCurr]!!.node = curr\n                break\n            }\n            n[curr]!!.handle = hChild\n            h[hChild]!!.node = curr\n            curr = child\n        }\n    }\n\n    fun FloatUp(curr: Int) {\n        var curr = curr\n        val n: Array<PQnode?>? = nodes\n        val h: Array<PQhandleElem?>? = handles\n        var hParent: Int\n        var parent: Int\n        val hCurr: Int = n!![curr]!!.handle\n        while (true) {\n            parent = curr shr 1\n            hParent = n[parent]!!.handle\n            if (parent == 0 || LEQ(leq, h!![hParent]!!.key!!, h[hCurr]!!.key!!)) {\n                n[curr]!!.handle = hCurr\n                h!![hCurr]!!.node = curr\n                break\n            }\n            n[curr]!!.handle = hParent\n            h[hParent]!!.node = curr\n            curr = parent\n        }\n    }\n\n    /* really __gl_pqHeapInit */\n    override fun pqInit(): Boolean {\n\n        /* This method of building a heap is O(n), rather than O(n lg n). */\n        var i: Int = size\n        while (i >= 1) {\n            FloatDown(i)\n            --i\n        }\n        initialized = true\n        return true\n    }\n\n    /* really __gl_pqHeapInsert */ /* returns LONG_MAX iff out of memory */\n    override fun pqInsert(keyNew: Any?): Int {\n        val free: Int\n        val curr: Int = ++size\n        if (curr * 2 > max) {\n            val saveNodes: Array<PQnode?>? = nodes\n            val saveHandles: Array<PQhandleElem?>? = handles\n\n            /* If the heap overflows, double its size. */max = max shl 1\n            //            pq->nodes = (PQnode *)memRealloc( pq->nodes, (size_t) ((pq->max + 1) * sizeof( pq->nodes[0] )));\n            val pqNodes: Array<PQnode?> =\n                arrayOfNulls(max + 1)\n            arraycopy(nodes!!, 0, pqNodes, 0, nodes!!.size)\n            for (i in nodes!!.size until pqNodes.size) {\n                pqNodes[i] = PQnode()\n            }\n            nodes = pqNodes\n            if (nodes == null) {\n                nodes = saveNodes /* restore ptr to free upon return */\n                return Int.MAX_VALUE\n            }\n\n//            pq->handles = (PQhandleElem *)memRealloc( pq->handles,(size_t)((pq->max + 1) * sizeof( pq->handles[0] )));\n            val pqHandles: Array<PQhandleElem?> =\n                arrayOfNulls(max + 1)\n            arraycopy(handles!!, 0, pqHandles, 0, handles!!.size)\n            for (i in handles!!.size until pqHandles.size) {\n                pqHandles[i] = PQhandleElem()\n            }\n            handles = pqHandles\n            if (handles == null) {\n                handles = saveHandles /* restore ptr to free upon return */\n                return Int.MAX_VALUE\n            }\n        }\n        if (freeList == 0) {\n            free = curr\n        } else {\n            free = freeList\n            freeList = handles!![free]!!.node\n        }\n        nodes!![curr]!!.handle = free\n        handles!![free]!!.node = curr\n        handles!![free]!!.key = keyNew\n        if (initialized) {\n            FloatUp(curr)\n        }\n        require(free != Int.MAX_VALUE)\n        return free\n    }\n\n    /* really __gl_pqHeapExtractMin */\n    override fun pqExtractMin(): Any? {\n        val n: Array<PQnode?>? = nodes\n        val h: Array<PQhandleElem?>? = handles\n        val hMin: Int = n!![1]!!.handle\n        val min: Any? = h!![hMin]!!.key\n        if (size > 0) {\n            n[1]!!.handle = n[size]!!.handle\n            h[n[1]!!.handle]!!.node = 1\n            h[hMin]!!.key = null\n            h[hMin]!!.node = freeList\n            freeList = hMin\n            if (--size > 0) {\n                FloatDown(1)\n            }\n        }\n        return min\n    }\n\n    /* really __gl_pqHeapDelete */\n    override fun pqDelete(hCurr: Int) {\n        val n: Array<PQnode?>? = nodes\n        val h: Array<PQhandleElem?>? = handles\n        require(hCurr >= 1 && hCurr <= max && h!![hCurr]!!.key != null)\n        val curr: Int = h!![hCurr]!!.node\n        n!![curr]!!.handle = n[size]!!.handle\n        h[n[curr]!!.handle]!!.node = curr\n        if (curr <= --size) {\n            if (curr <= 1 || LEQ(\n                    leq,\n                    h[n[curr shr 1]!!.handle]!!.key!!,\n                    h[n[curr]!!.handle]!!.key!!\n                )\n            ) {\n                FloatDown(curr)\n            } else {\n                FloatUp(curr)\n            }\n        }\n        h[hCurr]!!.key = null\n        h[hCurr]!!.node = freeList\n        freeList = hCurr\n    }\n\n    override fun pqMinimum(): Any? {\n        return handles!![nodes!![1]!!.handle]!!.key\n    }\n\n    override fun pqIsEmpty(): Boolean {\n        return size == 0\n    }\n\n    /* really __gl_pqHeapNewPriorityQ */\n    init {\n        max = INIT_SIZE\n        nodes =\n            arrayOfNulls(INIT_SIZE + 1)\n        for (i in nodes!!.indices) {\n            nodes!![i] = PQnode()\n        }\n        handles =\n            arrayOfNulls(INIT_SIZE + 1)\n        for (i in handles!!.indices) {\n            handles!![i] = PQhandleElem()\n        }\n        initialized = false\n        freeList = 0\n        nodes!![1]!!.handle = 1 /* so that Minimum() returns NULL */\n        handles!![1]!!.key = null\n    }\n}\n","package org.openrndr.ktessellation\n\n\nimport kotlin.math.abs\n\ninternal class PriorityQSort(leq: PriorityQ.Leq) :\n    PriorityQ() {\n    var heap: PriorityQHeap?\n    var keys: Array<Any?>?\n\n    // JAVA: 'order' contains indices into the keys array.\n    // This simulates the indirect pointers used in the original C code\n    // (from Frank Suykens, Luciad.com).\n    var order: IntArray? = null\n    var size: Int\n    var max: Int\n    var initialized: Boolean\n    var leq: PriorityQ.Leq\n\n    /* really __gl_pqSortDeletePriorityQ */\n    override fun pqDeletePriorityQ() {\n        if (heap != null) heap!!.pqDeletePriorityQ()\n        order = null\n        keys = null\n    }\n\n    private class Stack {\n        var p = 0\n        var r = 0\n    }\n\n    /* really __gl_pqSortInit */\n    override fun pqInit(): Boolean {\n        var p: Int\n        var r: Int\n        var i: Int\n        var j: Int\n        var piv: Int\n        val stack = arrayOfNulls<Stack>(50)\n        for (k in stack.indices) {\n            stack[k] = Stack()\n        }\n        var top = 0\n        var seed = 2016473283\n\n        /* Create an array of indirect pointers to the keys, so that we\n         * the handles we have returned are still valid.\n         */order = IntArray(size + 1)\n        /* the previous line is a patch to compensate for the fact that IBM */\n/* machines return a null on a malloc of zero bytes (unlike SGI),   */\n/* so we have to put in this defense to guard against a memory      */\n/* fault four lines down. from fossum@austin.ibm.com.               */p = 0\n        r = size - 1\n        piv = 0\n        i = p\n        while (i <= r) {\n\n            // indirect pointers: keep an index into the keys array, not a direct pointer to its contents\n            order!![i] = piv\n            ++piv\n            ++i\n        }\n\n        /* Sort the indirect pointers in descending order,\n         * using randomized Quicksort\n         */stack[top]!!.p = p\n        stack[top]!!.r = r\n        ++top\n        while (--top >= 0) {\n            p = stack[top]!!.p\n            r = stack[top]!!.r\n            while (r > p + 10) {\n                seed = abs(seed * 1539415821 + 1)\n                i = p + seed % (r - p + 1)\n                piv = order!![i]\n                order!![i] = order!![p]\n                order!![p] = piv\n                i = p - 1\n                j = r + 1\n                do {\n                    do {\n                        ++i\n                    } while (GT(leq, keys!![order!![i]]!!, keys!![piv]!!))\n                    do {\n                        --j\n                    } while (LT(leq, keys!![order!![j]]!!, keys!![piv]!!))\n                    Swap(order!!, i, j)\n                } while (i < j)\n                Swap(order!!, i, j) /* Undo last swap */\n                if (i - p < r - j) {\n                    stack[top]!!.p = j + 1\n                    stack[top]!!.r = r\n                    ++top\n                    r = i - 1\n                } else {\n                    stack[top]!!.p = p\n                    stack[top]!!.r = i - 1\n                    ++top\n                    p = j + 1\n                }\n            }\n            /* Insertion sort small lists */i = p + 1\n            while (i <= r) {\n                piv = order!![i]\n                j = i\n                while (j > p && LT(leq, keys!![order!![j - 1]]!!, keys!![piv]!!)) {\n                    order!![j] = order!![j - 1]\n                    --j\n                }\n                order!![j] = piv\n                ++i\n            }\n        }\n        max = size\n        initialized = true\n        heap!!.pqInit() /* always succeeds */\n\n/*        #ifndef NDEBUG\n        p = order;\n        r = p + size - 1;\n        for (i = p; i < r; ++i) {\n            Assertion.doAssert(LEQ(     * * (i + 1), **i ));\n        }\n        #endif*/return true\n    }\n\n    /* really __gl_pqSortInsert */ /* returns LONG_MAX iff out of memory */\n    override fun pqInsert(keyNew: Any?): Int {\n        val curr: Int\n        if (initialized) {\n            return heap!!.pqInsert(keyNew)\n        }\n        curr = size\n        if (++size >= max) {\n            val saveKey = keys\n\n            /* If the heap overflows, double its size. */max = max shl 1\n            //            pq->keys = (PQHeapKey *)memRealloc( pq->keys,(size_t)(pq->max * sizeof( pq->keys[0] )));\n            val pqKeys = arrayOfNulls<Any>(max)\n            arraycopy(keys!!, 0, pqKeys, 0, keys!!.size)\n            keys = pqKeys\n            if (keys == null) {\n                keys = saveKey /* restore ptr to free upon return */\n                return Int.MAX_VALUE\n            }\n        }\n        require(curr != Int.MAX_VALUE)\n        keys!![curr] = keyNew\n\n        /* Negative handles index the sorted array. */return -(curr + 1)\n    }\n\n    /* really __gl_pqSortExtractMin */\n    override fun pqExtractMin(): Any? {\n        val sortMin: Any\n        val heapMin: Any?\n        if (size == 0) {\n            return heap!!.pqExtractMin()\n        }\n        sortMin = keys!![order!![size - 1]]!!\n        if (!heap!!.pqIsEmpty()) {\n            heapMin = heap!!.pqMinimum()\n            if (PriorityQ.LEQ(leq, heapMin!!, sortMin)) {\n                return heap!!.pqExtractMin()\n            }\n        }\n        do {\n            --size\n        } while (size > 0 && keys!![order!![size - 1]] == null)\n        return sortMin\n    }\n\n    /* really __gl_pqSortMinimum */\n    override fun pqMinimum(): Any? {\n        val sortMin: Any\n        val heapMin: Any?\n        if (size == 0) {\n            return heap!!.pqMinimum()\n        }\n        sortMin = keys!![order!![size - 1]]!!\n        if (!heap!!.pqIsEmpty()) {\n            heapMin = heap!!.pqMinimum()\n            if (LEQ(leq, heapMin!!, sortMin)) {\n                return heapMin\n            }\n        }\n        return sortMin\n    }\n\n    /* really __gl_pqSortIsEmpty */\n    override fun pqIsEmpty(): Boolean {\n        return size == 0 && heap!!.pqIsEmpty()\n    }\n\n    /* really __gl_pqSortDelete */\n    override fun pqDelete(hCurr: Int) {\n        var curr = hCurr\n        if (curr >= 0) {\n            heap!!.pqDelete(curr)\n            return\n        }\n        curr = -(curr + 1)\n        require(curr < max && keys!![curr] != null)\n        keys!![curr] = null\n        while (size > 0 && keys!![order!![size - 1]] == null) {\n            --size\n        }\n    }\n\n    companion object {\n        private fun LT(leq: PriorityQ.Leq, x: Any, y: Any): Boolean {\n            return !LEQ(leq, y, x)\n        }\n\n        private fun GT(leq: PriorityQ.Leq, x: Any, y: Any): Boolean {\n            return !LEQ(leq, x, y)\n        }\n\n        private fun Swap(array: IntArray, a: Int, b: Int) {\n            if (true) {\n                val tmp = array[a]\n                array[a] = array[b]\n                array[b] = tmp\n            } else {\n            }\n        }\n    }\n\n    init {\n        heap = PriorityQHeap(leq)\n        keys = arrayOfNulls(PriorityQ.INIT_SIZE)\n        size = 0\n        max = PriorityQ.INIT_SIZE\n        initialized = false\n        this.leq = leq\n    }\n}\n","@file:Suppress(\"FunctionName\", \"ConstantConditionIf\", \"NAME_SHADOWING\", \"UNCHECKED_CAST\",\n    \"MemberVisibilityCanBePrivate\", \"RemoveEmptySecondaryConstructorBody\", \"ClassName\"\n)\n\npackage org.openrndr.ktessellation\n\n\ninternal object Render {\n    private const val USE_OPTIMIZED_CODE_PATH = false\n    private val renderFan = RenderFan()\n    private val renderStrip = RenderStrip()\n    private val renderTriangle = RenderTriangle()\n\n    /************************ Strips and Fans decomposition  */ /* __gl_renderMesh( tess, mesh ) takes a mesh and breaks it into triangle\n * fans, strips, and separate triangles.  A substantial effort is made\n * to use as few rendering primitives as possible (ie. to make the fans\n * and strips as large as possible).\n *\n * The rendering output is provided as callbacks (see the api).\n */\n    fun __gl_renderMesh(\n        tess: GLUtessellatorImpl,\n        mesh: GLUmesh\n    ) {\n        var f: GLUface\n\n        /* Make a list of separate triangles so we can render them all at once */tess.lonelyTriList = null\n        f = mesh.fHead.next!!\n        while (f !== mesh.fHead) {\n            f.marked = false\n            f = f.next!!\n        }\n        f = mesh.fHead.next!!\n        while (f !== mesh.fHead) {\n\n\n            /* We examine all faces in an arbitrary order.  Whenever we find\n             * an unprocessed face F, we output a group of faces including F\n             * whose size is maximum.\n             */\n            if (f.inside && !f.marked) {\n                RenderMaximumFaceGroup(tess, f)\n                require(f.marked)\n            }\n            f = f.next!!\n        }\n        if (tess.lonelyTriList != null) {\n            RenderLonelyTriangles(tess, tess.lonelyTriList)\n            tess.lonelyTriList = null\n        }\n    }\n\n    fun RenderMaximumFaceGroup(\n        tess: GLUtessellatorImpl,\n        fOrig: GLUface\n    ) {\n        /* We want to find the largest triangle fan or strip of unmarked faces\n         * which includes the given face fOrig.  There are 3 possible fans\n         * passing through fOrig (one centered at each vertex), and 3 possible\n         * strips (one for each CCW permutation of the vertices).  Our strategy\n         * is to try all of these, and take the primitive which uses the most\n         * triangles (a greedy approach).\n         */\n        val e: GLUhalfEdge = fOrig.anEdge!!\n        var max = FaceCount()\n        var newFace: FaceCount\n        max.size = 1\n        max.eStart = e\n        max.render = renderTriangle\n        if (!tess.flagBoundary) {\n            newFace = MaximumFan(e)\n            if (newFace.size > max.size) {\n                max = newFace\n            }\n            newFace = MaximumFan(e.Lnext!!)\n            if (newFace.size > max.size) {\n                max = newFace\n            }\n            newFace = MaximumFan(e.Onext!!.Sym!!)\n            if (newFace.size > max.size) {\n                max = newFace\n            }\n            newFace = MaximumStrip(e)\n            if (newFace.size > max.size) {\n                max = newFace\n            }\n            newFace = MaximumStrip(e.Lnext!!)\n            if (newFace.size > max.size) {\n                max = newFace\n            }\n            newFace = MaximumStrip(e.Onext!!.Sym!!)\n            if (newFace.size > max.size) {\n                max = newFace\n            }\n        }\n        max.render!!.render(tess, max.eStart!!, max.size)\n    }\n\n    /* Macros which keep track of faces we have marked temporarily, and allow\n * us to backtrack when necessary.  With triangle fans, this is not\n * really necessary, since the only awkward case is a loop of triangles\n * around a single origin vertex.  However with strips the situation is\n * more complicated, and we need a general tracking method like the\n * one here.\n */\n    private fun Marked(f: GLUface): Boolean {\n        return !f.inside || f.marked\n    }\n\n    private fun AddToTrail(\n        f: GLUface,\n        t: GLUface?\n    ): GLUface {\n        f.trail = t\n        f.marked = true\n        return f\n    }\n\n    private fun FreeTrail(t: GLUface?) {\n        var t: GLUface? = t\n        if (true) {\n            while (t != null) {\n                t.marked = false\n                t = t.trail\n            }\n        } else {\n            /* absorb trailing semicolon */\n        }\n    }\n\n    private fun MaximumFan(eOrig: GLUhalfEdge): FaceCount {\n        /* eOrig.Lface is the face we want to render.  We want to find the size\n         * of a maximal fan around eOrig.Org.  To do this we just walk around\n         * the origin vertex as far as possible in both directions.\n         */\n        val newFace = FaceCount(0, null, renderFan)\n        var trail: GLUface? = null\n        var e: GLUhalfEdge\n        e = eOrig\n        while (!Marked(e.Lface!!)) {\n            trail = AddToTrail(e.Lface!!, trail)\n            ++newFace.size\n            e = e.Onext!!\n        }\n        e = eOrig\n        while (!Marked(e.Sym!!.Lface!!)) {\n            trail = AddToTrail(e.Sym!!.Lface!!, trail)\n            ++newFace.size\n            e = e.Sym!!.Lnext!!\n        }\n        newFace.eStart = e\n        FreeTrail(trail)\n        return newFace\n    }\n\n    private fun IsEven(n: Long): Boolean {\n        return n and 0x1L == 0L\n    }\n\n    private fun MaximumStrip(eOrig: GLUhalfEdge): FaceCount {\n        /* Here we are looking for a maximal strip that contains the vertices\n         * eOrig.Org, eOrig.Dst, eOrig.Lnext.Dst (in that order or the\n         * reverse, such that all triangles are oriented CCW).\n         *\n         * Again we walk forward and backward as far as possible.  However for\n         * strips there is a twist: to get CCW orientations, there must be\n         * an *even* number of triangles in the strip on one side of eOrig.\n         * We walk the strip starting on a side with an even number of triangles;\n         * if both side have an odd number, we are forced to shorten one side.\n         */\n        val newFace = FaceCount(0, null, renderStrip)\n        var headSize: Long = 0\n        var tailSize: Long = 0\n        var trail: GLUface? = null\n        var e: GLUhalfEdge\n        e = eOrig\n        while (!Marked(e.Lface!!)) {\n            trail = AddToTrail(e.Lface!!, trail)\n            ++tailSize\n            e = e.Lnext!!.Sym!!\n            if (Marked(e.Lface!!)) break\n            trail = AddToTrail(e.Lface!!, trail)\n            ++tailSize\n            e = e.Onext!!\n        }\n        val eTail: GLUhalfEdge = e\n        e = eOrig\n        while (!Marked(e.Sym!!.Lface!!)) {\n            trail = AddToTrail(e.Sym!!.Lface!!, trail)\n            ++headSize\n            e = e.Sym!!.Lnext!!\n            if (Marked(e.Sym!!.Lface!!)) break\n            trail = AddToTrail(e.Sym!!.Lface!!, trail)\n            ++headSize\n            e = e.Sym!!.Onext!!.Sym!!\n        }\n        val eHead: GLUhalfEdge = e\n        newFace.size = tailSize + headSize\n        if (IsEven(tailSize)) {\n            newFace.eStart = eTail.Sym\n        } else if (IsEven(headSize)) {\n            newFace.eStart = eHead\n        } else {\n            /* Both sides have odd length, we must shorten one of them.  In fact,\n             * we must start from eHead to guarantee inclusion of eOrig.Lface.\n             */\n            --newFace.size\n            newFace.eStart = eHead.Onext\n        }\n        /*LINTED*/FreeTrail(trail)\n        return newFace\n    }\n\n    fun RenderLonelyTriangles(\n        tess: GLUtessellatorImpl,\n        f: GLUface?\n    ) {\n        /* Now we render all the separate triangles which could not be\n         * grouped into a triangle fan or strip.\n         */\n        var f: GLUface? = f\n        var e: GLUhalfEdge\n        var newState: Int\n        var edgeState = -1 /* force edge state output for first vertex */\n        tess.callBeginOrBeginData(GLConstants.GL_TRIANGLES)\n        while (f != null) {\n\n            /* Loop once for each edge (there will always be 3 edges) */\n            e = f.anEdge!!\n            do {\n                if (tess.flagBoundary) {\n                    /* Set the \"edge state\" to true just before we output the\n                     * first vertex of each edge on the polygon boundary.\n                     */\n                    newState = if (!e.Sym!!.Lface!!.inside) 1 else 0\n                    if (edgeState != newState) {\n                        edgeState = newState\n                        tess.callEdgeFlagOrEdgeFlagData(edgeState != 0)\n                    }\n                }\n                tess.callVertexOrVertexData(e.Org!!.data)\n                e = e.Lnext!!\n            } while (e !== f.anEdge)\n            f = f.trail\n        }\n        tess.callEndOrEndData()\n    }\n\n    /************************ Boundary contour decomposition  */ /* __gl_renderBoundary( tess, mesh ) takes a mesh, and outputs one\n * contour for each face marked \"inside\".  The rendering output is\n * provided as callbacks (see the api).\n */\n    fun __gl_renderBoundary(\n        tess: GLUtessellatorImpl,\n        mesh: GLUmesh\n    ) {\n        var f: GLUface\n        var e: GLUhalfEdge\n        f = mesh.fHead.next!!\n        while (f !== mesh.fHead) {\n            if (f.inside) {\n                tess.callBeginOrBeginData(GLConstants.GL_LINE_LOOP)\n                e = f.anEdge!!\n                do {\n                    tess.callVertexOrVertexData(e.Org!!.data)\n                    e = e.Lnext!!\n                } while (e !== f.anEdge)\n                tess.callEndOrEndData()\n            }\n            f = f.next!!\n        }\n    }\n\n    /************************ Quick-and-dirty decomposition  */\n    private const val SIGN_INCONSISTENT = 2\n    fun ComputeNormal(tess: GLUtessellatorImpl, norm: DoubleArray, check: Boolean): Int /*\n * If check==false, we compute the polygon normal and place it in norm[].\n * If check==true, we check that each triangle in the fan from v0 has a\n * consistent orientation with respect to norm[].  If triangles are\n * consistently oriented CCW, return 1; if CW, return -1; if all triangles\n * are degenerate return 0; otherwise (no consistent orientation) return\n * SIGN_INCONSISTENT.\n */ {\n        val v: Array<CachedVertex> = tess.cache as Array<CachedVertex>\n        //            CachedVertex vn = v0 + tess.cacheCount;\n        val vn: Int = tess.cacheCount\n        //            CachedVertex vc;\n        var dot: Double\n        var xc: Double\n        var yc: Double\n        var zc: Double\n        var xp: Double\n        var yp: Double\n        var zp: Double\n        val n = DoubleArray(3)\n        var sign = 0\n\n        /* Find the polygon normal.  It is important to get a reasonable\n         * normal even when the polygon is self-intersecting (eg. a bowtie).\n         * Otherwise, the computed normal could be very tiny, but perpendicular\n         * to the true plane of the polygon due to numerical noise.  Then all\n         * the triangles would appear to be degenerate and we would incorrectly\n         * decompose the polygon as a fan (or simply not render it at all).\n         *\n         * We use a sum-of-triangles normal algorithm rather than the more\n         * efficient sum-of-trapezoids method (used in CheckOrientation()\n         * in normal.c).  This lets us explicitly reverse the signed area\n         * of some triangles to get a reasonable normal in the self-intersecting\n         * case.\n         */if (!check) {\n            norm[2] = 0.0\n            norm[1] = norm[2]\n            norm[0] = norm[1]\n        }\n        var vc = 1\n        xc = v[vc].coords[0] - v[0].coords[0]\n        yc = v[vc].coords[1] - v[0].coords[1]\n        zc = v[vc].coords[2] - v[0].coords[2]\n        while (++vc < vn) {\n            xp = xc\n            yp = yc\n            zp = zc\n            xc = v[vc].coords[0] - v[0].coords[0]\n            yc = v[vc].coords[1] - v[0].coords[1]\n            zc = v[vc].coords[2] - v[0].coords[2]\n\n            /* Compute (vp - v0) cross (vc - v0) */n[0] = yp * zc - zp * yc\n            n[1] = zp * xc - xp * zc\n            n[2] = xp * yc - yp * xc\n            dot = n[0] * norm[0] + n[1] * norm[1] + n[2] * norm[2]\n            if (!check) {\n                /* Reverse the contribution of back-facing triangles to get\n                 * a reasonable normal for self-intersecting polygons (see above)\n                 */\n                if (dot >= 0) {\n                    norm[0] += n[0]\n                    norm[1] += n[1]\n                    norm[2] += n[2]\n                } else {\n                    norm[0] -= n[0]\n                    norm[1] -= n[1]\n                    norm[2] -= n[2]\n                }\n            } else if (dot != 0.0) {\n                /* Check the new orientation for consistency with previous triangles */\n                sign = if (dot > 0) {\n                    if (sign < 0) return SIGN_INCONSISTENT\n                    1\n                } else {\n                    if (sign > 0) return SIGN_INCONSISTENT\n                    -1\n                }\n            }\n        }\n        return sign\n    }\n\n    /* __gl_renderCache( tess ) takes a single contour and tries to render it\n * as a triangle fan.  This handles convex polygons, as well as some\n * non-convex polygons if we get lucky.\n *\n * Returns true if the polygon was successfully rendered.  The rendering\n * output is provided as callbacks (see the api).\n */\n    fun __gl_renderCache(tess: GLUtessellatorImpl): Boolean {\n        val v: Array<CachedVertex> = tess.cache as Array<CachedVertex>\n        //            CachedVertex vn = v0 + tess.cacheCount;\n        val vn: Int = tess.cacheCount\n        //            CachedVertex vc;\n        var vc: Int\n        val norm = DoubleArray(3)\n        if (tess.cacheCount < 3) {\n            /* Degenerate contour -- no output */\n            return true\n        }\n        norm[0] = tess.normal[0]\n        norm[1] = tess.normal[1]\n        norm[2] = tess.normal[2]\n        if (norm[0] == 0.0 && norm[1] == 0.0 && norm[2] == 0.0) {\n            ComputeNormal(tess, norm, false)\n        }\n        val sign: Int = ComputeNormal(tess, norm, true)\n        if (sign == SIGN_INCONSISTENT) {\n            /* Fan triangles did not have a consistent orientation */\n            return false\n        }\n        if (sign == 0) {\n            /* All triangles were degenerate */\n            return true\n        }\n        return if (!USE_OPTIMIZED_CODE_PATH) {\n            false\n        } else {\n            /* Make sure we do the right thing for each winding rule */\n            when (tess.windingRule) {\n                GLU.GLU_TESS_WINDING_ODD, GLU.GLU_TESS_WINDING_NONZERO -> {}\n                GLU.GLU_TESS_WINDING_POSITIVE -> if (sign < 0) return true\n                GLU.GLU_TESS_WINDING_NEGATIVE -> if (sign > 0) return true\n                GLU.GLU_TESS_WINDING_ABS_GEQ_TWO -> return true\n            }\n            tess.callBeginOrBeginData(if (tess.boundaryOnly) GLConstants.GL_LINE_LOOP else if (tess.cacheCount > 3) GLConstants.GL_TRIANGLE_FAN else GLConstants.GL_TRIANGLES)\n            tess.callVertexOrVertexData(v[0].data)\n            if (sign > 0) {\n                vc = 1\n                while (vc < vn) {\n                    tess.callVertexOrVertexData(v[vc].data)\n                    ++vc\n                }\n            } else {\n                vc = vn - 1\n                while (vc > 0) {\n                    tess.callVertexOrVertexData(v[vc].data)\n                    --vc\n                }\n            }\n            tess.callEndOrEndData()\n            true\n        }\n    }\n\n    /* This structure remembers the information we need about a primitive\n * to be able to render it later, once we have determined which\n * primitive is able to use the most triangles.\n */\n    private class FaceCount {\n        constructor() {}\n        constructor(size: Long, eStart: GLUhalfEdge?, render: renderCallBack) {\n            this.size = size\n            this.eStart = eStart\n            this.render = render\n        }\n\n        var size /* number of triangles used */: Long = 0\n        var eStart /* edge where this primitive starts */: GLUhalfEdge? = null\n        var render: renderCallBack? = null\n    }\n\n    private interface renderCallBack {\n        fun render(\n            tess: GLUtessellatorImpl,\n            e: GLUhalfEdge,\n            size: Long\n        )\n    }\n\n    private class RenderTriangle : renderCallBack {\n        override fun render(\n            tess: GLUtessellatorImpl,\n            e: GLUhalfEdge,\n            size: Long\n        ) {\n            /* Just add the triangle to a triangle list, so we can render all\n             * the separate triangles at once.\n             */\n            require(size == 1L)\n            tess.lonelyTriList = AddToTrail(e.Lface!!, tess.lonelyTriList)\n        }\n    }\n\n    private class RenderFan : renderCallBack {\n        override fun render(\n            tess: GLUtessellatorImpl,\n            e: GLUhalfEdge,\n            size: Long\n        ) {\n            /* Render as many CCW triangles as possible in a fan starting from\n             * edge \"e\".  The fan *should* contain exactly \"size\" triangles\n             * (otherwise we've goofed up somewhere).\n             */\n            var e: GLUhalfEdge = e\n            var size = size\n            tess.callBeginOrBeginData(GLConstants.GL_TRIANGLE_FAN)\n            tess.callVertexOrVertexData(e.Org!!.data)\n            tess.callVertexOrVertexData(e.Sym!!.Org!!.data)\n            while (!Marked(e.Lface!!)) {\n                e.Lface!!.marked = true\n                --size\n                e = e.Onext!!\n                tess.callVertexOrVertexData(e.Sym!!.Org!!.data)\n            }\n            require(size == 0L)\n            tess.callEndOrEndData()\n        }\n    }\n\n    private class RenderStrip : renderCallBack {\n        override fun render(\n            tess: GLUtessellatorImpl,\n            e: GLUhalfEdge,\n            size: Long\n        ) {\n            /* Render as many CCW triangles as possible in a strip starting from\n             * edge \"e\".  The strip *should* contain exactly \"size\" triangles\n             * (otherwise we've goofed up somewhere).\n             */\n            var e: GLUhalfEdge = e\n            var size = size\n            tess.callBeginOrBeginData(GLConstants.GL_TRIANGLE_STRIP)\n            tess.callVertexOrVertexData(e.Org!!.data)\n            tess.callVertexOrVertexData(e.Sym!!.Org!!.data)\n            while (!Marked(e.Lface!!)) {\n                e.Lface!!.marked = true\n                --size\n                e = e.Lnext!!.Sym!!\n                tess.callVertexOrVertexData(e.Org!!.data)\n                if (Marked(e.Lface!!)) break\n                e.Lface!!.marked = true\n                --size\n                e = e.Onext!!\n                tess.callVertexOrVertexData(e.Sym!!.Org!!.data)\n            }\n            require(size == 0L)\n            tess.callEndOrEndData()\n        }\n    }\n}\n","@file:Suppress(\n    \"FunctionName\", \"UNUSED_PARAMETER\", \"MemberVisibilityCanBePrivate\", \"MemberVisibilityCanBePrivate\",\n    \"SENSELESS_COMPARISON\", \"NAME_SHADOWING\", \"SpellCheckingInspection\", \"RedundantNullableReturnType\",\n    \"UNNECESSARY_NOT_NULL_ASSERTION\", \"unused\", \"FoldInitializerAndIfToElvis\"\n)\n\npackage org.openrndr.ktessellation\n\nimport kotlin.math.max\nimport kotlin.math.min\n\ninternal object Sweep {\n    //    #ifdef FOR_TRITE_TEST_PROGRAM\n    //    extern void DebugEvent( GLUtessellator *tess );\n    //    #else\n    private fun DebugEvent(tess: GLUtessellatorImpl) {}\n\n    //    #endif\n    /*\n * Invariants for the Edge Dictionary.\n * - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)\n *   at any valid location of the sweep event\n * - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2\n *   share a common endpoint\n * - for each e, e.Dst has been processed, but not e.Org\n * - each edge e satisfies VertLeq(e.Dst,event) && VertLeq(event,e.Org)\n *   where \"event\" is the current sweep line event.\n * - no edge e has zero length\n *\n * Invariants for the Mesh (the processed portion).\n * - the portion of the mesh left of the sweep line is a planar graph,\n *   ie. there is *some* way to embed it in the plane\n * - no processed edge has zero length\n * - no two processed vertices have identical coordinates\n * - each \"inside\" region is monotone, ie. can be broken into two chains\n *   of monotonically increasing vertices according to VertLeq(v1,v2)\n *   - a non-invariant: these chains may intersect (very slightly)\n *\n * Invariants for the Sweep.\n * - if none of the edges incident to the event vertex have an activeRegion\n *   (ie. none of these edges are in the edge dictionary), then the vertex\n *   has only right-going edges.\n * - if an edge is marked \"fixUpperEdge\" (it is a temporary edge introduced\n *   by ConnectRightVertex), then it is the only right-going edge from\n *   its associated vertex.  (This says that these edges exist only\n *   when it is necessary.)\n */\n    /* When we merge two edges into one, we need to compute the combined\n * winding of the new edge.\n */\n    private fun AddWinding(\n        eDst: GLUhalfEdge,\n        eSrc: GLUhalfEdge\n    ) {\n        eDst.winding += eSrc.winding\n        eDst.Sym!!.winding += eSrc.Sym!!.winding\n    }\n\n    private fun RegionBelow(r: ActiveRegion): ActiveRegion? {\n        return Dict.dictKey(Dict.dictPred(r.nodeUp!!)!!) as ActiveRegion?\n    }\n\n    private fun RegionAbove(r: ActiveRegion): ActiveRegion? {\n        return Dict.dictKey(Dict.dictSucc(r.nodeUp!!)!!) as ActiveRegion?\n    }\n\n    fun EdgeLeq(\n        tess: GLUtessellatorImpl,\n        reg1: ActiveRegion,\n        reg2: ActiveRegion\n    ): Boolean /*\n * Both edges must be directed from right to left (this is the canonical\n * direction for the upper edge of each region).\n *\n * The strategy is to evaluate a \"t\" value for each edge at the\n * current sweep line position, given by tess.event.  The calculations\n * are designed to be very stable, but of course they are not perfect.\n *\n * Special case: if both edge destinations are at the sweep event,\n * we sort the edges by slope (they would otherwise compare equally).\n */ {\n        val event: GLUvertex = tess.event!!\n        val t1: Double\n        val t2: Double\n        val e1: GLUhalfEdge = reg1.eUp!!\n        val e2: GLUhalfEdge = reg2.eUp!!\n        if (e1.Sym!!.Org === event) {\n            return if (e2.Sym!!.Org === event) {\n                /* Two edges right of the sweep line which meet at the sweep event.\n                         * Sort them by slope.\n                         */\n                if (Geom.VertLeq(e1.Org!!, e2.Org!!)) {\n                    Geom.EdgeSign(e2.Sym!!.Org!!, e1.Org!!, e2.Org!!) <= 0\n                } else Geom.EdgeSign(e1.Sym!!.Org!!, e2.Org!!, e1.Org!!) >= 0\n            } else Geom.EdgeSign(e2.Sym!!.Org!!, event, e2.Org!!) <= 0\n        }\n        if (e2.Sym!!.Org === event) {\n            return Geom.EdgeSign(e1.Sym!!.Org!!, event, e1.Org!!) >= 0\n        }\n\n        /* General case - compute signed distance *from* e1, e2 to event */t1 =\n            Geom.EdgeEval(e1.Sym!!.Org!!, event, e1.Org!!)\n        t2 = Geom.EdgeEval(e2.Sym!!.Org!!, event, e2.Org!!)\n        return t1 >= t2\n    }\n\n    fun DeleteRegion(\n        tess: GLUtessellatorImpl,\n        reg: ActiveRegion?\n    ) {\n        if (reg!!.fixUpperEdge) {\n            /* It was created with zero winding number, so it better be\n             * deleted with zero winding number (ie. it better not get merged\n             * with a real edge).\n             */\n            require(reg.eUp!!.winding == 0)\n        }\n        reg.eUp!!.activeRegion = null\n        Dict.dictDelete(tess.dict, reg.nodeUp!!) /* __gl_dictListDelete */\n    }\n\n    fun FixUpperEdge(\n        reg: ActiveRegion,\n        newEdge: GLUhalfEdge?\n    ): Boolean /*\n * Replace an upper edge which needs fixing (see ConnectRightVertex).\n */ {\n        require(reg.fixUpperEdge)\n        if (!Mesh.__gl_meshDelete(reg.eUp!!)) return false\n        reg.fixUpperEdge = false\n        reg.eUp = newEdge\n        newEdge!!.activeRegion = reg\n        return true\n    }\n\n    fun TopLeftRegion(reg: ActiveRegion): ActiveRegion? {\n        var reg: ActiveRegion = reg\n        val org: GLUvertex = reg.eUp!!.Org!!\n        val e: GLUhalfEdge\n\n        /* Find the region above the uppermost edge with the same origin */do {\n            reg = RegionAbove(reg)!!\n        } while (reg.eUp!!.Org === org)\n\n        /* If the edge above was a temporary edge introduced by ConnectRightVertex,\n         * now is the time to fix it.\n         */if (reg.fixUpperEdge) {\n            e = Mesh.__gl_meshConnect(RegionBelow(reg)!!.eUp!!.Sym!!, reg.eUp!!.Lnext!!)\n            if (e == null) return null\n            if (!FixUpperEdge(reg, e)) return null\n            reg = RegionAbove(reg)!!\n        }\n        return reg\n    }\n\n    fun TopRightRegion(reg: ActiveRegion): ActiveRegion {\n        var reg: ActiveRegion = reg\n        val dst: GLUvertex = reg.eUp!!.Sym!!.Org!!\n\n        /* Find the region above the uppermost edge with the same destination */do {\n            reg = RegionAbove(reg)!!\n        } while (reg.eUp!!.Sym!!.Org!! === dst)\n        return reg\n    }\n\n    fun AddRegionBelow(\n        tess: GLUtessellatorImpl,\n        regAbove: ActiveRegion?,\n        eNewUp: GLUhalfEdge?\n    ): ActiveRegion? /*\n * Add a new active region to the sweep line, *somewhere* below \"regAbove\"\n * (according to where the new edge belongs in the sweep-line dictionary).\n * The upper edge of the new region will be \"eNewUp\".\n * Winding number and \"inside\" flag are not updated.\n */ {\n        val regNew = ActiveRegion()\n        regNew.eUp = eNewUp\n        /* __gl_dictListInsertBefore */regNew.nodeUp =\n            Dict.dictInsertBefore(tess.dict!!, regAbove!!.nodeUp!!, regNew)\n        if (regNew.nodeUp == null) throw RuntimeException()\n        regNew.fixUpperEdge = false\n        regNew.sentinel = false\n        regNew.dirty = false\n        eNewUp!!.activeRegion = regNew\n        return regNew\n    }\n\n    fun IsWindingInside(tess: GLUtessellatorImpl, n: Int): Boolean {\n        return when (tess.windingRule) {\n            GLU.GLU_TESS_WINDING_ODD -> n and 1 != 0\n            GLU.GLU_TESS_WINDING_NONZERO -> n != 0\n            GLU.GLU_TESS_WINDING_POSITIVE -> n > 0\n            GLU.GLU_TESS_WINDING_NEGATIVE -> n < 0\n            GLU.GLU_TESS_WINDING_ABS_GEQ_TWO -> n >= 2 || n <= -2\n            else -> error(\"no such winding rule\")\n        }\n\n    }\n\n    fun ComputeWinding(\n        tess: GLUtessellatorImpl,\n        reg: ActiveRegion\n    ) {\n        reg.windingNumber = RegionAbove(reg)!!.windingNumber + reg.eUp!!.winding\n        reg.inside = IsWindingInside(tess, reg.windingNumber)\n    }\n\n    fun FinishRegion(\n        tess: GLUtessellatorImpl,\n        reg: ActiveRegion\n    ) /*\n * Delete a region from the sweep line.  This happens when the upper\n * and lower chains of a region meet (at a vertex on the sweep line).\n * The \"inside\" flag is copied to the appropriate mesh face (we could\n * not do this before -- since the structure of the mesh is always\n * changing, this face may not have even existed until now).\n */ {\n        val e: GLUhalfEdge = reg.eUp!!\n        val f: GLUface = e.Lface!!\n        f.inside = reg.inside\n        f.anEdge = e /* optimization for __gl_meshTessellateMonoRegion() */\n        DeleteRegion(tess, reg)\n    }\n\n    fun FinishLeftRegions(\n        tess: GLUtessellatorImpl,\n        regFirst: ActiveRegion, regLast: ActiveRegion?\n    ): GLUhalfEdge /*\n * We are given a vertex with one or more left-going edges.  All affected\n * edges should be in the edge dictionary.  Starting at regFirst.eUp,\n * we walk down deleting all regions where both edges have the same\n * origin vOrg.  At the same time we copy the \"inside\" flag from the\n * active region to the face, since at this point each face will belong\n * to at most one region (this was not necessarily true until this point\n * in the sweep).  The walk stops at the region above regLast; if regLast\n * is null we walk as far as possible.  At the same time we relink the\n * mesh if necessary, so that the ordering of edges around vOrg is the\n * same as in the dictionary.\n */ {\n        var reg: ActiveRegion\n        var regPrev: ActiveRegion?\n        var e: GLUhalfEdge\n        var ePrev: GLUhalfEdge\n        regPrev = regFirst\n        ePrev = regFirst.eUp!!\n        while (regPrev !== regLast) {\n            regPrev!!.fixUpperEdge = false /* placement was OK */\n            reg = RegionBelow(regPrev)!!\n            e = reg.eUp!!\n            if (e.Org !== ePrev.Org) {\n                if (!reg.fixUpperEdge) {\n                    /* Remove the last left-going edge.  Even though there are no further\n                     * edges in the dictionary with this origin, there may be further\n                     * such edges in the mesh (if we are adding left edges to a vertex\n                     * that has already been processed).  Thus it is important to call\n                     * FinishRegion rather than just DeleteRegion.\n                     */\n                    FinishRegion(tess, regPrev)\n                    break\n                }\n                /* If the edge below was a temporary edge introduced by\n                 * ConnectRightVertex, now is the time to fix it.\n                 */\n                e = Mesh.__gl_meshConnect(ePrev.Onext!!.Sym!!, e.Sym!!)\n                if (e == null) throw RuntimeException()\n                if (!FixUpperEdge(reg, e)) throw RuntimeException()\n            }\n\n            /* Relink edges so that ePrev.Onext == e */\n            if (ePrev.Onext !== e) {\n                if (!Mesh.__gl_meshSplice(e.Sym!!.Lnext!!, e)) throw RuntimeException()\n                if (!Mesh.__gl_meshSplice(ePrev, e)) throw RuntimeException()\n            }\n            FinishRegion(tess, regPrev) /* may change reg.eUp */\n            ePrev = reg.eUp!!\n            regPrev = reg\n        }\n        return ePrev\n    }\n\n    fun AddRightEdges(\n        tess: GLUtessellatorImpl,\n        regUp: ActiveRegion?,\n        eFirst: GLUhalfEdge,\n        eLast: GLUhalfEdge,\n        eTopLeft: GLUhalfEdge?,\n        cleanUp: Boolean\n    ) /*\n * Purpose: insert right-going edges into the edge dictionary, and update\n * winding numbers and mesh connectivity appropriately.  All right-going\n * edges share a common origin vOrg.  Edges are inserted CCW starting at\n * eFirst; the last edge inserted is eLast.Sym.Lnext.  If vOrg has any\n * left-going edges already processed, then eTopLeft must be the edge\n * such that an imaginary upward vertical segment from vOrg would be\n * contained between eTopLeft.Sym.Lnext and eTopLeft; otherwise eTopLeft\n * should be null.\n */ {\n        var eTopLeft: GLUhalfEdge? = eTopLeft\n        var reg: ActiveRegion\n        var regPrev: ActiveRegion?\n        var e: GLUhalfEdge\n        var ePrev: GLUhalfEdge?\n        var firstTime = true\n\n        /* Insert the new right-going edges in the dictionary */e = eFirst\n        do {\n            require(Geom.VertLeq(e.Org!!, e.Sym!!.Org!!))\n            AddRegionBelow(tess, regUp, e.Sym)\n            e = e.Onext!!\n        } while (e !== eLast)\n\n        /* Walk *all* right-going edges from e.Org, in the dictionary order,\n         * updating the winding numbers of each region, and re-linking the mesh\n         * edges to match the dictionary ordering (if necessary).\n         */if (eTopLeft == null) {\n            eTopLeft = RegionBelow(regUp!!)!!.eUp!!.Sym!!.Onext\n        }\n        regPrev = regUp\n        ePrev = eTopLeft\n        while (true) {\n            reg = RegionBelow(regPrev!!)!!\n            e = reg.eUp!!.Sym!!\n            if (e.Org !== ePrev!!.Org) break\n            if (e.Onext !== ePrev) {\n                /* Unlink e from its current position, and relink below ePrev */\n                if (!Mesh.__gl_meshSplice(e.Sym!!.Lnext!!, e)) throw RuntimeException()\n                if (!Mesh.__gl_meshSplice(ePrev!!.Sym!!.Lnext!!, e)) throw RuntimeException()\n            }\n            /* Compute the winding number and \"inside\" flag for the new regions */reg.windingNumber =\n                regPrev.windingNumber - e.winding\n            reg.inside = IsWindingInside(tess, reg.windingNumber)\n\n            /* Check for two outgoing edges with same slope -- process these\n             * before any intersection tests (see example in __gl_computeInterior).\n             */regPrev.dirty = true\n            if (!firstTime && CheckForRightSplice(tess, regPrev)) {\n                AddWinding(e, ePrev!!)\n                DeleteRegion(tess, regPrev)\n                if (!Mesh.__gl_meshDelete(ePrev)) throw RuntimeException()\n            }\n            firstTime = false\n            regPrev = reg\n            ePrev = e\n        }\n        regPrev!!.dirty = true\n        require(regPrev.windingNumber - e.winding == reg.windingNumber)\n        if (cleanUp) {\n            /* Check for intersections between newly adjacent edges. */\n            WalkDirtyRegions(tess, regPrev)\n        }\n    }\n\n    fun CallCombine(\n        tess: GLUtessellatorImpl, isect: GLUvertex,\n        data: Array<Any?>?, weights: FloatArray?, needed: Boolean\n    ) {\n        val coords = DoubleArray(3)\n\n        /* Copy coord data in case the callback changes it. */coords[0] = isect.coords[0]\n        coords[1] = isect.coords[1]\n        coords[2] = isect.coords[2]\n        val outData = arrayOfNulls<Any>(1)\n        tess.callCombineOrCombineData(coords, data, weights, outData)\n        isect.data = outData[0]\n        if (isect.data == null) {\n            if (!needed) {\n                isect.data = data!![0]\n            } else if (!tess.fatalError) {\n                /* The only way fatal error is when two edges are found to intersect,\n                 * but the user has not provided the callback necessary to handle\n                 * generated intersection points.\n                 */\n                tess.callErrorOrErrorData(GLU.GLU_TESS_NEED_COMBINE_CALLBACK)\n                tess.fatalError = true\n            }\n        }\n    }\n\n    fun SpliceMergeVertices(\n        tess: GLUtessellatorImpl, e1: GLUhalfEdge,\n        e2: GLUhalfEdge\n    ) /*\n * Two vertices with idential coordinates are combined into one.\n * e1.Org is kept, while e2.Org is discarded.\n */ {\n        val data = arrayOfNulls<Any>(4)\n        val weights = floatArrayOf(0.5f, 0.5f, 0.0f, 0.0f)\n        data[0] = e1.Org!!.data\n        data[1] = e2.Org!!.data\n        CallCombine(tess, e1.Org!!, data, weights, false)\n        if (!Mesh.__gl_meshSplice(e1, e2)) throw RuntimeException()\n    }\n\n    fun VertexWeights(\n        isect: GLUvertex,\n        org: GLUvertex,\n        dst: GLUvertex,\n        weights: FloatArray\n    ) /*\n * Find some weights which describe how the intersection vertex is\n * a linear combination of \"org\" and \"dest\".  Each of the two edges\n * which generated \"isect\" is allocated 50% of the weight; each edge\n * splits the weight between its org and dst according to the\n * relative distance to \"isect\".\n */ {\n        val t1: Double = Geom.VertL1dist(org, isect)\n        val t2: Double = Geom.VertL1dist(dst, isect)\n        weights[0] = (0.5 * t2 / (t1 + t2)).toFloat()\n        weights[1] = (0.5 * t1 / (t1 + t2)).toFloat()\n        isect.coords[0] += weights[0] * org.coords[0] + weights[1] * dst.coords[0]\n        isect.coords[1] += weights[0] * org.coords[1] + weights[1] * dst.coords[1]\n        isect.coords[2] += weights[0] * org.coords[2] + weights[1] * dst.coords[2]\n    }\n\n    fun GetIntersectData(\n        tess: GLUtessellatorImpl, isect: GLUvertex,\n        orgUp: GLUvertex, dstUp: GLUvertex,\n        orgLo: GLUvertex, dstLo: GLUvertex\n    ) /*\n * We've computed a new intersection point, now we need a \"data\" pointer\n * from the user so that we can refer to this new vertex in the\n * rendering callbacks.\n */ {\n        val data = arrayOfNulls<Any>(4)\n        val weights = FloatArray(4)\n        val weights1 = FloatArray(2)\n        val weights2 = FloatArray(2)\n        data[0] = orgUp.data\n        data[1] = dstUp.data\n        data[2] = orgLo.data\n        data[3] = dstLo.data\n        isect.coords[2] = 0.0\n        isect.coords[1] = isect.coords[2]\n        isect.coords[0] = isect.coords[1]\n        VertexWeights(isect, orgUp, dstUp, weights1)\n        VertexWeights(isect, orgLo, dstLo, weights2)\n        arraycopy(weights1, 0, weights, 0, 2)\n        arraycopy(weights2, 0, weights, 2, 2)\n        CallCombine(tess, isect, data, weights, true)\n    }\n\n    fun CheckForRightSplice(\n        tess: GLUtessellatorImpl,\n        regUp: ActiveRegion\n    ): Boolean /*\n * Check the upper and lower edge of \"regUp\", to make sure that the\n * eUp.Org is above eLo, or eLo.Org is below eUp (depending on which\n * origin is leftmost).\n *\n * The main purpose is to splice right-going edges with the same\n * dest vertex and nearly identical slopes (ie. we can't distinguish\n * the slopes numerically).  However the splicing can also help us\n * to recover from numerical errors.  For example, suppose at one\n * point we checked eUp and eLo, and decided that eUp.Org is barely\n * above eLo.  Then later, we split eLo into two edges (eg. from\n * a splice operation like this one).  This can change the result of\n * our test so that now eUp.Org is incident to eLo, or barely below it.\n * We must correct this condition to maintain the dictionary invariants.\n *\n * One possibility is to check these edges for intersection again\n * (ie. CheckForIntersect).  This is what we do if possible.  However\n * CheckForIntersect requires that tess.event lies between eUp and eLo,\n * so that it has something to fall back on when the intersection\n * calculation gives us an unusable answer.  So, for those cases where\n * we can't check for intersection, this routine fixes the problem\n * by just splicing the offending vertex into the other edge.\n * This is a guaranteed solution, no matter how degenerate things get.\n * Basically this is a combinatorial solution to a numerical problem.\n */ {\n        val regLo: ActiveRegion = RegionBelow(regUp)!!\n        val eUp: GLUhalfEdge = regUp.eUp!!\n        val eLo: GLUhalfEdge = regLo.eUp!!\n        if (Geom.VertLeq(eUp.Org!!, eLo.Org!!)) {\n            if (Geom.EdgeSign(eLo.Sym!!.Org!!, eUp.Org!!, eLo.Org!!) > 0) return false\n\n            /* eUp.Org appears to be below eLo */if (!Geom.VertEq(eUp.Org!!, eLo.Org!!)) {\n                /* Splice eUp.Org into eLo */\n                if (Mesh.__gl_meshSplitEdge(eLo.Sym!!) == null) throw RuntimeException()\n                if (!Mesh.__gl_meshSplice(eUp, eLo.Sym!!.Lnext!!)) throw RuntimeException()\n                regLo.dirty = true\n                regUp.dirty = regLo.dirty\n            } else if (eUp.Org !== eLo.Org) {\n                /* merge the two vertices, discarding eUp.Org */\n                tess.pq!!.pqDelete(eUp.Org!!.pqHandle) /* __gl_pqSortDelete */\n                SpliceMergeVertices(tess, eLo.Sym!!.Lnext!!, eUp)\n            }\n        } else {\n            if (Geom.EdgeSign(eUp.Sym!!.Org!!, eLo.Org!!, eUp.Org!!) < 0) return false\n\n            /* eLo.Org appears to be above eUp, so splice eLo.Org into eUp */regUp.dirty = true\n            RegionAbove(regUp)!!.dirty = regUp.dirty\n            if (Mesh.__gl_meshSplitEdge(eUp.Sym!!) == null) throw RuntimeException()\n            if (!Mesh.__gl_meshSplice(eLo.Sym!!.Lnext!!, eUp)) throw RuntimeException()\n        }\n        return true\n    }\n\n    fun CheckForLeftSplice(\n        tess: GLUtessellatorImpl?,\n        regUp: ActiveRegion?\n    ): Boolean /*\n * Check the upper and lower edge of \"regUp\", to make sure that the\n * eUp.Sym.Org is above eLo, or eLo.Sym.Org is below eUp (depending on which\n * destination is rightmost).\n *\n * Theoretically, this should always be true.  However, splitting an edge\n * into two pieces can change the results of previous tests.  For example,\n * suppose at one point we checked eUp and eLo, and decided that eUp.Sym.Org\n * is barely above eLo.  Then later, we split eLo into two edges (eg. from\n * a splice operation like this one).  This can change the result of\n * the test so that now eUp.Sym.Org is incident to eLo, or barely below it.\n * We must correct this condition to maintain the dictionary invariants\n * (otherwise new edges might get inserted in the wrong place in the\n * dictionary, and bad stuff will happen).\n *\n * We fix the problem by just splicing the offending vertex into the\n * other edge.\n */ {\n        val regLo: ActiveRegion = RegionBelow(regUp!!)!!\n        val eUp: GLUhalfEdge = regUp.eUp!!\n        val eLo: GLUhalfEdge = regLo.eUp!!\n        val e: GLUhalfEdge\n        require(!Geom.VertEq(eUp.Sym!!.Org!!, eLo.Sym!!.Org!!))\n        if (Geom.VertLeq(eUp.Sym!!.Org!!, eLo.Sym!!.Org!!)) {\n            if (Geom.EdgeSign(eUp.Sym!!.Org!!, eLo.Sym!!.Org!!, eUp.Org!!) < 0) return false\n\n            /* eLo.Sym.Org is above eUp, so splice eLo.Sym.Org into eUp */regUp.dirty = true\n            RegionAbove(regUp!!)!!.dirty = regUp!!.dirty\n            e = Mesh.__gl_meshSplitEdge(eUp)\n            if (e == null) throw RuntimeException()\n            if (!Mesh.__gl_meshSplice(eLo.Sym!!, e)) throw RuntimeException()\n            e.Lface!!.inside = regUp.inside\n        } else {\n            if (Geom.EdgeSign(eLo.Sym!!.Org!!, eUp.Sym!!.Org!!, eLo.Org!!) > 0) return false\n\n            /* eUp.Sym.Org is below eLo, so splice eUp.Sym.Org into eLo */regLo.dirty = true\n            regUp.dirty = regLo.dirty\n            e = Mesh.__gl_meshSplitEdge(eLo)\n            if (e == null) throw RuntimeException()\n            if (!Mesh.__gl_meshSplice(eUp.Lnext!!, eLo.Sym!!)) throw RuntimeException()\n            e.Sym!!.Lface!!.inside = regUp.inside\n        }\n        return true\n    }\n\n    fun CheckForIntersect(\n        tess: GLUtessellatorImpl,\n        regUp: ActiveRegion\n    ): Boolean /*\n * Check the upper and lower edges of the given region to see if\n * they intersect.  If so, create the intersection and add it\n * to the data structures.\n *\n * Returns true if adding the new intersection resulted in a recursive\n * call to AddRightEdges(); in this case all \"dirty\" regions have been\n * checked for intersections, and possibly regUp has been deleted.\n */ {\n        var regUp: ActiveRegion = regUp\n        var regLo: ActiveRegion = RegionBelow(regUp!!)!!\n        var eUp: GLUhalfEdge = regUp.eUp!!\n        var eLo: GLUhalfEdge = regLo.eUp!!\n        val orgUp: GLUvertex = eUp.Org!!\n        val orgLo: GLUvertex = eLo.Org!!\n        val dstUp: GLUvertex = eUp.Sym!!.Org!!\n        val dstLo: GLUvertex = eLo.Sym!!.Org!!\n        val isect = GLUvertex()\n        val e: GLUhalfEdge\n        require(!Geom.VertEq(dstLo, dstUp))\n        require(Geom.EdgeSign(dstUp, tess.event!!, orgUp) <= 0)\n        require(Geom.EdgeSign(dstLo, tess.event!!, orgLo) >= 0)\n        require(orgUp !== tess.event && orgLo !== tess.event)\n        require(!regUp.fixUpperEdge && !regLo.fixUpperEdge)\n        if (orgUp === orgLo) return false /* right endpoints are the same */\n        val tMinUp: Double = min(orgUp.t, dstUp.t)\n        val tMaxLo: Double = max(orgLo.t, dstLo.t)\n        if (tMinUp > tMaxLo) return false /* t ranges do not overlap */\n        if (Geom.VertLeq(orgUp, orgLo)) {\n            if (Geom.EdgeSign(dstLo, orgUp, orgLo) > 0) return false\n        } else {\n            if (Geom.EdgeSign(dstUp, orgLo, orgUp) < 0) return false\n        }\n\n        /* At this point the edges intersect, at least marginally */DebugEvent(tess)\n        Geom.EdgeIntersect(dstUp, orgUp, dstLo, orgLo, isect)\n        require(min(orgUp.t, dstUp.t) <= isect.t)\n        require(isect.t <= max(orgLo.t, dstLo.t))\n        require(min(dstLo.s, dstUp.s) <= isect.s)\n        require(isect.s <= max(orgLo.s, orgUp.s))\n        if (Geom.VertLeq(isect, tess.event!!)) {\n            /* The intersection point lies slightly to the left of the sweep line,\n             * so move it until it''s slightly to the right of the sweep line.\n             * (If we had perfect numerical precision, this would never happen\n             * in the first place).  The easiest and safest thing to do is\n             * replace the intersection by tess.event.\n             */\n            isect.s = tess.event!!.s\n            isect.t = tess.event!!.t\n        }\n        /* Similarly, if the computed intersection lies to the right of the\n         * rightmost origin (which should rarely happen), it can cause\n         * unbelievable inefficiency on sufficiently degenerate inputs.\n         * (If you have the test program, try running test54.d with the\n         * \"X zoom\" option turned on).\n         */\n        val orgMin: GLUvertex = if (Geom.VertLeq(orgUp, orgLo)) orgUp else orgLo\n        if (Geom.VertLeq(orgMin, isect)) {\n            isect.s = orgMin.s\n            isect.t = orgMin.t\n        }\n        if (Geom.VertEq(isect, orgUp) || Geom.VertEq(\n                isect,\n                orgLo\n            )\n        ) {\n            /* Easy case -- intersection at one of the right endpoints */\n            CheckForRightSplice(tess, regUp)\n            return false\n        }\n        if ((!Geom.VertEq(dstUp, tess.event!!)\n                    && Geom.EdgeSign(dstUp, tess.event!!, isect) >= 0)\n            || (!Geom.VertEq(dstLo, tess.event!!)\n                    && Geom.EdgeSign(dstLo, tess.event!!, isect) <= 0)\n        ) {\n            /* Very unusual -- the new upper or lower edge would pass on the\n             * wrong side of the sweep event, or through it.  This can happen\n             * due to very small numerical errors in the intersection calculation.\n             */\n            if (dstLo === tess.event) {\n                /* Splice dstLo into eUp, and process the new region(s) */\n                if (Mesh.__gl_meshSplitEdge(eUp.Sym!!) == null) throw RuntimeException()\n                if (!Mesh.__gl_meshSplice(eLo.Sym!!, eUp)) throw RuntimeException()\n                regUp = TopLeftRegion(regUp)!!\n                if (regUp == null) throw RuntimeException()\n                eUp = RegionBelow(regUp)!!.eUp!!\n                FinishLeftRegions(tess, RegionBelow(regUp)!!, regLo)\n                AddRightEdges(tess, regUp, eUp.Sym!!.Lnext!!, eUp, eUp, true)\n                return true\n            }\n            if (dstUp === tess.event) {\n                /* Splice dstUp into eLo, and process the new region(s) */\n                if (Mesh.__gl_meshSplitEdge(eLo.Sym!!) == null) throw RuntimeException()\n                if (!Mesh.__gl_meshSplice(\n                        eUp.Lnext!!,\n                        eLo.Sym!!.Lnext!!\n                    )\n                ) throw RuntimeException()\n                regLo = regUp\n                regUp = TopRightRegion(regUp)\n                e = RegionBelow(regUp)!!.eUp!!.Sym!!.Onext!!\n                regLo.eUp = eLo.Sym!!.Lnext!!\n                eLo = FinishLeftRegions(tess, regLo, null)\n                AddRightEdges(tess, regUp, eLo.Onext!!, eUp.Sym!!.Onext!!, e, true)\n                return true\n            }\n            /* Special case: called from ConnectRightVertex.  If either\n             * edge passes on the wrong side of tess.event, split it\n             * (and wait for ConnectRightVertex to splice it appropriately).\n             */if (Geom.EdgeSign(dstUp, tess.event!!, isect) >= 0) {\n                regUp.dirty = true\n                RegionAbove(regUp)!!.dirty = regUp.dirty\n                if (Mesh.__gl_meshSplitEdge(eUp.Sym!!) == null) throw RuntimeException()\n                eUp.Org!!.s = tess.event!!.s\n                eUp.Org!!.t = tess.event!!.t\n            }\n            if (Geom.EdgeSign(dstLo, tess.event!!, isect) <= 0) {\n                regLo.dirty = true\n                regUp.dirty = regLo.dirty\n                if (Mesh.__gl_meshSplitEdge(eLo.Sym!!) == null) throw RuntimeException()\n                eLo.Org!!.s = tess.event!!.s\n                eLo.Org!!.t = tess.event!!.t\n            }\n            /* leave the rest for ConnectRightVertex */return false\n        }\n\n        /* General case -- split both edges, splice into new vertex.\n         * When we do the splice operation, the order of the arguments is\n         * arbitrary as far as correctness goes.  However, when the operation\n         * creates a new face, the work done is proportional to the size of\n         * the new face.  We expect the faces in the processed part of\n         * the mesh (ie. eUp.Lface) to be smaller than the faces in the\n         * unprocessed original contours (which will be eLo.Sym.Lnext.Lface).\n         */if (Mesh.__gl_meshSplitEdge(eUp.Sym!!) == null) throw RuntimeException()\n        if (Mesh.__gl_meshSplitEdge(eLo.Sym!!) == null) throw RuntimeException()\n        if (!Mesh.__gl_meshSplice(eLo.Sym!!.Lnext!!, eUp)) throw RuntimeException()\n        eUp.Org!!.s = isect.s\n        eUp.Org!!.t = isect.t\n        eUp.Org!!.pqHandle = tess.pq!!.pqInsert(eUp.Org) /* __gl_pqSortInsert */\n        if (eUp.Org!!.pqHandle.toLong() == Long.MAX_VALUE) {\n            tess.pq!!.pqDeletePriorityQ() /* __gl_pqSortDeletePriorityQ */\n            tess.pq = null\n            throw RuntimeException()\n        }\n        GetIntersectData(tess, eUp.Org!!, orgUp, dstUp, orgLo, dstLo)\n        regLo.dirty = true\n        regUp.dirty = regLo.dirty\n        RegionAbove(regUp)!!.dirty = regUp.dirty\n        return false\n    }\n\n    fun WalkDirtyRegions(\n        tess: GLUtessellatorImpl,\n        regUp: ActiveRegion\n    ) /*\n * When the upper or lower edge of any region changes, the region is\n * marked \"dirty\".  This routine walks through all the dirty regions\n * and makes sure that the dictionary invariants are satisfied\n * (see the comments at the beginning of this file).  Of course\n * new dirty regions can be created as we make changes to restore\n * the invariants.\n */ {\n        var regUp: ActiveRegion? = regUp\n        var regLo: ActiveRegion? = RegionBelow(regUp ?: error(\"regUp == null\"))\n        var eUp: GLUhalfEdge\n        var eLo: GLUhalfEdge\n        while (true) {\n\n            /* Find the lowest dirty region (we walk from the bottom up). */\n            while (regLo!!.dirty) {\n                regUp = regLo\n                regLo = RegionBelow(regLo)!!\n            }\n            if (!regUp!!.dirty) {\n                regLo = regUp\n                regUp = RegionAbove(regUp)\n                if (regUp == null || !regUp.dirty) {\n                    /* We've walked all the dirty regions */\n                    return\n                }\n            }\n            regUp.dirty = false\n            eUp = regUp.eUp!!\n            eLo = regLo.eUp!!\n            if (eUp.Sym!!.Org !== eLo.Sym!!.Org) {\n                /* Check that the edge ordering is obeyed at the Dst vertices. */\n                if (CheckForLeftSplice(tess, regUp)) {\n\n                    /* If the upper or lower edge was marked fixUpperEdge, then\n                     * we no longer need it (since these edges are needed only for\n                     * vertices which otherwise have no right-going edges).\n                     */\n                    if (regLo.fixUpperEdge) {\n                        DeleteRegion(tess, regLo)\n                        if (!Mesh.__gl_meshDelete(eLo)) throw RuntimeException()\n                        regLo = RegionBelow(regUp)!!\n                        eLo = regLo.eUp!!\n                    } else if (regUp.fixUpperEdge) {\n                        DeleteRegion(tess, regUp)\n                        if (!Mesh.__gl_meshDelete(eUp)) throw RuntimeException()\n                        regUp = RegionAbove(regLo)!!\n                        eUp = regUp.eUp!!\n                    }\n                }\n            }\n            if (eUp.Org !== eLo.Org) {\n                if (eUp.Sym!!.Org !== eLo.Sym!!.Org && !regUp.fixUpperEdge && !regLo.fixUpperEdge\n                    && (eUp.Sym!!.Org === tess.event || eLo.Sym!!.Org === tess.event)\n                ) {\n                    /* When all else fails in CheckForIntersect(), it uses tess.event\n                     * as the intersection location.  To make this possible, it requires\n                     * that tess.event lie between the upper and lower edges, and also\n                     * that neither of these is marked fixUpperEdge (since in the worst\n                     * case it might splice one of these edges into tess.event, and\n                     * violate the invariant that fixable edges are the only right-going\n                     * edge from their associated vertex).\n                         */\n                    if (CheckForIntersect(tess, regUp)) {\n                        /* WalkDirtyRegions() was called recursively; we're done */\n                        return\n                    }\n                } else {\n                    /* Even though we can't use CheckForIntersect(), the Org vertices\n                     * may violate the dictionary edge ordering.  Check and correct this.\n                     */\n                    CheckForRightSplice(tess, regUp)\n                }\n            }\n            if (eUp.Org === eLo.Org && eUp.Sym!!.Org === eLo.Sym!!.Org) {\n                /* A degenerate loop consisting of only two edges -- delete it. */\n                AddWinding(eLo, eUp)\n                DeleteRegion(tess, regUp)\n                if (!Mesh.__gl_meshDelete(eUp)) throw RuntimeException()\n                regUp = RegionAbove(regLo)!!\n            }\n        }\n    }\n\n    fun ConnectRightVertex(\n        tess: GLUtessellatorImpl, regUp: ActiveRegion,\n        eBottomLeft: GLUhalfEdge\n    ) /*\n * Purpose: connect a \"right\" vertex vEvent (one where all edges go left)\n * to the unprocessed portion of the mesh.  Since there are no right-going\n * edges, two regions (one above vEvent and one below) are being merged\n * into one.  \"regUp\" is the upper of these two regions.\n *\n * There are two reasons for doing this (adding a right-going edge):\n *  - if the two regions being merged are \"inside\", we must add an edge\n *    to keep them separated (the combined region would not be monotone).\n *  - in any case, we must leave some record of vEvent in the dictionary,\n *    so that we can merge vEvent with features that we have not seen yet.\n *    For example, maybe there is a vertical edge which passes just to\n *    the right of vEvent; we would like to splice vEvent into this edge.\n *\n * However, we don't want to connect vEvent to just any vertex.  We don''t\n * want the new edge to cross any other edges; otherwise we will create\n * intersection vertices even when the input data had no self-intersections.\n * (This is a bad thing; if the user's input data has no intersections,\n * we don't want to generate any false intersections ourselves.)\n *\n * Our eventual goal is to connect vEvent to the leftmost unprocessed\n * vertex of the combined region (the union of regUp and regLo).\n * But because of unseen vertices with all right-going edges, and also\n * new vertices which may be created by edge intersections, we don''t\n * know where that leftmost unprocessed vertex is.  In the meantime, we\n * connect vEvent to the closest vertex of either chain, and mark the region\n * as \"fixUpperEdge\".  This flag says to delete and reconnect this edge\n * to the next processed vertex on the boundary of the combined region.\n * Quite possibly the vertex we connected to will turn out to be the\n * closest one, in which case we won''t need to make any changes.\n */ {\n        var regUp: ActiveRegion = regUp\n        var eBottomLeft: GLUhalfEdge = eBottomLeft\n        var eNew: GLUhalfEdge\n        var eTopLeft: GLUhalfEdge = eBottomLeft.Onext!!\n        val regLo: ActiveRegion = RegionBelow(regUp)!!\n        val eUp: GLUhalfEdge = regUp.eUp!!\n        val eLo: GLUhalfEdge = regLo.eUp!!\n        var degenerate = false\n        if (eUp.Sym!!.Org !== eLo.Sym!!.Org) {\n            CheckForIntersect(tess, regUp)\n        }\n\n        /* Possible new degeneracies: upper or lower edge of regUp may pass\n         * through vEvent, or may coincide with new intersection vertex\n         */if (Geom.VertEq(eUp.Org!!, tess.event!!)) {\n            if (!Mesh.__gl_meshSplice(eTopLeft.Sym!!.Lnext!!, eUp)) throw RuntimeException()\n            regUp = TopLeftRegion(regUp)!!\n            if (regUp == null) throw RuntimeException()\n            eTopLeft = RegionBelow(regUp)!!.eUp!!\n            FinishLeftRegions(tess, RegionBelow(regUp)!!, regLo)\n            degenerate = true\n        }\n        if (Geom.VertEq(eLo.Org!!, tess.event!!)) {\n            if (!Mesh.__gl_meshSplice(\n                    eBottomLeft,\n                    eLo.Sym!!.Lnext!!\n                )\n            ) throw RuntimeException()\n            eBottomLeft = FinishLeftRegions(tess, regLo, null)\n            degenerate = true\n        }\n        if (degenerate) {\n            AddRightEdges(tess, regUp, eBottomLeft.Onext!!, eTopLeft, eTopLeft, true)\n            return\n        }\n\n        /* Non-degenerate situation -- need to add a temporary, fixable edge.\n         * Connect to the closer of eLo.Org, eUp.Org.\n         */\n        eNew = if (Geom.VertLeq(eLo.Org!!, eUp.Org!!)) {\n            eLo.Sym!!.Lnext!!\n        } else {\n            eUp\n        }\n        eNew = Mesh.__gl_meshConnect(eBottomLeft.Onext!!.Sym!!, eNew)\n        //if (eNew == null) throw RuntimeException()\n\n        /* Prevent cleanup, otherwise eNew might disappear before we've even\n         * had a chance to mark it as a temporary edge.\n         */\n        AddRightEdges(tess, regUp, eNew, eNew.Onext!!, eNew.Onext, false)\n        eNew.Sym!!.activeRegion!!.fixUpperEdge = true\n        WalkDirtyRegions(tess, regUp)\n    }\n\n    /* Because vertices at exactly the same location are merged together\n * before we process the sweep event, some degenerate cases can't occur.\n * However if someone eventually makes the modifications required to\n * merge features which are close together, the cases below marked\n * TOLERANCE_NONZERO will be useful.  They were debugged before the\n * code to merge identical vertices in the main loop was added.\n */\n    private const val TOLERANCE_NONZERO = false\n    fun ConnectLeftDegenerate(\n        tess: GLUtessellatorImpl,\n        regUp: ActiveRegion, vEvent: GLUvertex\n    ) /*\n * The event vertex lies exacty on an already-processed edge or vertex.\n * Adding the new vertex involves splicing it into the already-processed\n * part of the mesh.\n */ {\n        var regUp: ActiveRegion = regUp\n        var eTopLeft: GLUhalfEdge?\n        var eTopRight: GLUhalfEdge\n        val e: GLUhalfEdge = regUp.eUp!!\n        if (Geom.VertEq(e.Org!!, vEvent)) {\n            /* e.Org is an unprocessed vertex - just combine them, and wait\n             * for e.Org to be pulled from the queue\n             */\n            //require(TOLERANCE_NONZERO)\n            SpliceMergeVertices(tess, e, vEvent.anEdge!!)\n            return\n        }\n        if (!Geom.VertEq(e.Sym!!.Org!!, vEvent)) {\n            /* General case -- splice vEvent into edge e which passes through it */\n            if (Mesh.__gl_meshSplitEdge(e.Sym!!) == null) throw RuntimeException()\n            if (regUp.fixUpperEdge) {\n                /* This edge was fixable -- delete unused portion of original edge */\n                if (!Mesh.__gl_meshDelete(e.Onext!!)) throw RuntimeException()\n                regUp.fixUpperEdge = false\n            }\n            if (!Mesh.__gl_meshSplice(vEvent.anEdge!!, e)) throw RuntimeException()\n            SweepEvent(tess, vEvent) /* recurse */\n            return\n        }\n        //assert(TOLERANCE_NONZERO)\n        regUp = TopRightRegion(regUp)\n        val reg: ActiveRegion = RegionBelow(regUp)!!\n        eTopRight = reg.eUp!!.Sym!!\n        val eLast: GLUhalfEdge = eTopRight.Onext!!\n        eTopLeft = eLast\n        if (reg.fixUpperEdge) {\n            /* Here e.Sym.Org has only a single fixable edge going right.\n             * We can delete it since now we have some real right-going edges.\n             */\n            require(eTopLeft !== eTopRight /* there are some left edges too */)\n            DeleteRegion(tess, reg)\n            if (!Mesh.__gl_meshDelete(eTopRight)) throw RuntimeException()\n            eTopRight = eTopLeft.Sym!!.Lnext!!\n        }\n        if (!Mesh.__gl_meshSplice(vEvent.anEdge!!, eTopRight)) throw RuntimeException()\n        if (!Geom.EdgeGoesLeft(eTopLeft)) {\n            /* e.Sym.Org had no left-going edges -- indicate this to AddRightEdges() */\n            eTopLeft = null\n        }\n        AddRightEdges(tess, regUp, eTopRight.Onext!!, eLast, eTopLeft, true)\n    }\n\n    fun ConnectLeftVertex(\n        tess: GLUtessellatorImpl,\n        vEvent: GLUvertex\n    ) /*\n * Purpose: connect a \"left\" vertex (one where both edges go right)\n * to the processed portion of the mesh.  Let R be the active region\n * containing vEvent, and let U and L be the upper and lower edge\n * chains of R.  There are two possibilities:\n *\n * - the normal case: split R into two regions, by connecting vEvent to\n *   the rightmost vertex of U or L lying to the left of the sweep line\n *\n * - the degenerate case: if vEvent is close enough to U or L, we\n *   merge vEvent into that edge chain.  The subcases are:\n *\t- merging with the rightmost vertex of U or L\n *\t- merging with the active edge of U or L\n *\t- merging with an already-processed portion of U or L\n */ {\n        val regUp: ActiveRegion\n        val reg: ActiveRegion\n        val eLo: GLUhalfEdge\n        val eNew: GLUhalfEdge\n        val tmp = ActiveRegion()\n\n        /* assert ( vEvent.anEdge.Onext.Onext == vEvent.anEdge ); */\n\n        /* Get a pointer to the active region containing vEvent */\n        tmp.eUp = vEvent.anEdge!!.Sym\n        /* __GL_DICTLISTKEY */ /* __gl_dictListSearch */\n        regUp = Dict.dictKey(\n            Dict.dictSearch(\n                tess.dict!!,\n                tmp\n            )!!\n        ) as ActiveRegion\n        val regLo: ActiveRegion = RegionBelow(regUp)!!\n        val eUp: GLUhalfEdge = regUp.eUp!!\n        eLo = regLo.eUp!!\n\n        /* Try merging with U or L first */\n        if (Geom.EdgeSign(\n                eUp.Sym!!.Org!!,\n                vEvent,\n                eUp.Org!!\n            ) == 0.0\n        ) {\n            ConnectLeftDegenerate(tess, regUp, vEvent)\n            return\n        }\n\n        /* Connect vEvent to rightmost processed vertex of either chain.\n         * e.Sym.Org is the vertex that we will connect to vEvent.\n         */reg = if (Geom.VertLeq(eLo.Sym!!.Org!!, eUp.Sym!!.Org!!)) regUp else regLo\n        if (regUp.inside || reg.fixUpperEdge) {\n            if (reg === regUp) {\n                eNew = Mesh.__gl_meshConnect(vEvent.anEdge!!.Sym!!, eUp.Lnext!!)\n                if (eNew == null) throw RuntimeException()\n            } else {\n                val tempHalfEdge: GLUhalfEdge =\n                    Mesh.__gl_meshConnect(eLo.Sym!!.Onext!!.Sym!!, vEvent.anEdge!!)\n\n                eNew = tempHalfEdge.Sym!!\n            }\n            if (reg.fixUpperEdge) {\n                if (!FixUpperEdge(reg, eNew)) throw RuntimeException()\n            } else {\n                ComputeWinding(tess, AddRegionBelow(tess, regUp, eNew)!!)\n            }\n            SweepEvent(tess, vEvent)\n        } else {\n            /* The new vertex is in a region which does not belong to the polygon.\n             * We don''t need to connect this vertex to the rest of the mesh.\n             */\n            AddRightEdges(tess, regUp, vEvent.anEdge!!, vEvent.anEdge!!, null, true)\n        }\n    }\n\n    fun SweepEvent(\n        tess: GLUtessellatorImpl,\n        vEvent: GLUvertex\n    ) /*\n * Does everything necessary when the sweep line crosses a vertex.\n * Updates the mesh and the edge dictionary.\n */ {\n        val regUp: ActiveRegion?\n        var e: GLUhalfEdge\n        tess.event = vEvent /* for access in EdgeLeq() */\n        DebugEvent(tess)\n\n        /* Check if this vertex is the right endpoint of an edge that is\n         * already in the dictionary.  In this case we don't need to waste\n         * time searching for the location to insert new edges.\n         */\n        e = vEvent.anEdge!!\n        while (e.activeRegion == null) {\n            e = e.Onext!!\n            if (e === vEvent.anEdge) {\n                /* All edges go right -- not incident to any processed edges */\n                ConnectLeftVertex(tess, vEvent)\n                return\n            }\n        }\n\n        /* Processing consists of two phases: first we \"finish\" all the\n         * active regions where both the upper and lower edges terminate\n         * at vEvent (ie. vEvent is closing off these regions).\n         * We mark these faces \"inside\" or \"outside\" the polygon according\n         * to their winding number, and delete the edges from the dictionary.\n         * This takes care of all the left-going edges from vEvent.\n         */regUp = TopLeftRegion(e.activeRegion!!)!!\n        //if (regUp == null) throw RuntimeException()\n        val reg: ActiveRegion = RegionBelow(regUp)!!\n        val eTopLeft: GLUhalfEdge = reg.eUp!!\n        val eBottomLeft: GLUhalfEdge = FinishLeftRegions(tess, reg, null)\n\n        /* Next we process all the right-going edges from vEvent.  This\n         * involves adding the edges to the dictionary, and creating the\n         * associated \"active regions\" which record information about the\n         * regions between adjacent dictionary edges.\n         */if (eBottomLeft.Onext === eTopLeft) {\n            /* No right-going edges -- add a temporary \"fixable\" edge */\n            ConnectRightVertex(tess, regUp, eBottomLeft)\n        } else {\n            AddRightEdges(tess, regUp, eBottomLeft.Onext!!, eTopLeft, eTopLeft, true)\n        }\n    }\n\n    /* Make the sentinel coordinates big enough that they will never be\n * merged with real input features.  (Even with the largest possible\n * input contour and the maximum tolerance of 1.0, no merging will be\n * done with coordinates larger than 3 * GLU_TESS_MAX_COORD).\n */\n    private const val SENTINEL_COORD: Double = 4.0 * GLU.GLU_TESS_MAX_COORD\n    fun AddSentinel(tess: GLUtessellatorImpl, t: Double) /*\n * We add two sentinel edges above and below all other edges,\n * to avoid special cases at the top and bottom.\n */ {\n        val reg = ActiveRegion()\n        val e: GLUhalfEdge = Mesh.__gl_meshMakeEdge(tess.mesh!!)!!\n        if (e == null) throw RuntimeException()\n        e.Org!!.s = SENTINEL_COORD\n        e.Org!!.t = t\n        e.Sym!!.Org!!.s = -SENTINEL_COORD\n        e.Sym!!.Org!!.t = t\n        tess.event = e.Sym!!.Org /* initialize it */\n        reg.eUp = e\n        reg.windingNumber = 0\n        reg.inside = false\n        reg.fixUpperEdge = false\n        reg.sentinel = true\n        reg.dirty = false\n        reg.nodeUp = Dict.dictInsert(tess.dict!!, reg) /* __gl_dictListInsertBefore */\n        if (reg.nodeUp == null) throw RuntimeException()\n    }\n\n    fun InitEdgeDict(tess: GLUtessellatorImpl) /*\n * We maintain an ordering of edge intersections with the sweep line.\n * This order is maintained in a dynamic dictionary.\n */ {\n        /* __gl_dictListNewDict */\n        tess.dict = Dict.dictNewDict(\n            tess,\n            object : Dict.DictLeq {\n                override fun leq(frame: Any, key1: Any, key2: Any): Boolean {\n                    return EdgeLeq(\n                        tess,\n                        key1 as ActiveRegion,\n                        key2 as ActiveRegion\n                    )\n                }\n            })\n        if (tess.dict == null) throw RuntimeException()\n        AddSentinel(tess, -SENTINEL_COORD)\n        AddSentinel(tess, SENTINEL_COORD)\n    }\n\n    fun DoneEdgeDict(tess: GLUtessellatorImpl) {\n        var reg: ActiveRegion?\n        var fixedEdges = 0\n\n        /* __GL_DICTLISTKEY */ /* __GL_DICTLISTMIN */\n\n        while ((Dict.dictKey(\n                Dict.dictMin(\n                    tess.dict!!\n                )\n            ) as ActiveRegion?).also { reg = it } != null\n        ) {\n            /*\n             * At the end of all processing, the dictionary should contain\n             * only the two sentinel edges, plus at most one \"fixable\" edge\n             * created by ConnectRightVertex().\n             */\n            if (!reg!!.sentinel) {\n                require(reg!!.fixUpperEdge)\n                require(++fixedEdges == 1)\n            }\n            require(reg!!.windingNumber == 0)\n            DeleteRegion(tess, reg)\n            /*    __gl_meshDelete( reg.eUp );*/\n        }\n        Dict.dictDeleteDict(tess.dict!!) /* __gl_dictListDeleteDict */\n    }\n\n    fun RemoveDegenerateEdges(tess: GLUtessellatorImpl) /*\n * Remove zero-length edges, and contours with fewer than 3 vertices.\n */ {\n        var e: GLUhalfEdge\n        var eNext: GLUhalfEdge\n        var eLnext: GLUhalfEdge\n        val eHead: GLUhalfEdge = tess.mesh!!.eHead\n\n        /*LINTED*/\n        e = eHead.next!!\n        while (e !== eHead) {\n            eNext = e.next!!\n            eLnext = e.Lnext!!\n            if (Geom.VertEq(e.Org!!, e.Sym!!.Org!!) && e.Lnext!!.Lnext !== e) {\n                /* Zero-length edge, contour has at least 3 edges */\n                SpliceMergeVertices(tess, eLnext, e) /* deletes e.Org */\n                if (!Mesh.__gl_meshDelete(e)) throw RuntimeException() /* e is a self-loop */\n                e = eLnext\n                eLnext = e.Lnext!!\n            }\n            if (eLnext.Lnext === e) {\n                /* Degenerate contour (one or two edges) */\n                if (eLnext !== e) {\n                    if (eLnext === eNext || eLnext === eNext.Sym) {\n                        eNext = eNext.next!!\n                    }\n                    if (!Mesh.__gl_meshDelete(eLnext)) throw RuntimeException()\n                }\n                if (e === eNext || e === eNext.Sym) {\n                    eNext = eNext.next!!\n                }\n                if (!Mesh.__gl_meshDelete(e)) throw RuntimeException()\n            }\n            e = eNext\n        }\n    }\n\n    fun InitPriorityQ(tess: GLUtessellatorImpl): Boolean /*\n * Insert all vertices into the priority queue which determines the\n * order in which vertices cross the sweep line.\n */ {\n        var v: GLUvertex\n\n        /* __gl_pqSortNewPriorityQ */tess.pq = PriorityQ.pqNewPriorityQ(object :\n            PriorityQ.Leq {\n            override fun leq(key1: Any?, key2: Any?): Boolean {\n                return Geom.VertLeq(\n                    key1 as GLUvertex,\n                    key2 as GLUvertex\n                )\n            }\n        })\n        val pq: PriorityQ? = tess.pq\n        if (pq == null) return false\n        val vHead: GLUvertex = tess.mesh!!.vHead\n        v = vHead.next!!\n        while (v !== vHead) {\n            v.pqHandle = pq.pqInsert(v) /* __gl_pqSortInsert */\n            if (v.pqHandle.toLong() == Long.MAX_VALUE) break\n            v = v.next!!\n        }\n        if (v !== vHead || !pq.pqInit()) { /* __gl_pqSortInit */\n            tess.pq!!.pqDeletePriorityQ() /* __gl_pqSortDeletePriorityQ */\n            tess.pq = null\n            return false\n        }\n        return true\n    }\n\n    fun DonePriorityQ(tess: GLUtessellatorImpl) {\n        tess.pq!!.pqDeletePriorityQ() /* __gl_pqSortDeletePriorityQ */\n    }\n\n    fun RemoveDegenerateFaces(mesh: GLUmesh): Boolean /*\n * Delete any degenerate faces with only two edges.  WalkDirtyRegions()\n * will catch almost all of these, but it won't catch degenerate faces\n * produced by splice operations on already-processed edges.\n * The two places this can happen are in FinishLeftRegions(), when\n * we splice in a \"temporary\" edge produced by ConnectRightVertex(),\n * and in CheckForLeftSplice(), where we splice already-processed\n * edges to ensure that our dictionary invariants are not violated\n * by numerical errors.\n *\n * In both these cases it is *very* dangerous to delete the offending\n * edge at the time, since one of the routines further up the stack\n * will sometimes be keeping a pointer to that edge.\n */ {\n        var f: GLUface\n        var fNext: GLUface\n        var e: GLUhalfEdge\n\n        /*LINTED*/\n        f = mesh.fHead.next!!\n        while (f !== mesh.fHead) {\n            fNext = f.next!!\n            e = f.anEdge!!\n            require(e.Lnext !== e)\n            if (e.Lnext!!.Lnext === e) {\n                /* A face with only two edges */\n                AddWinding(e.Onext!!, e)\n                if (!Mesh.__gl_meshDelete(e)) return false\n            }\n            f = fNext\n        }\n        return true\n    }\n\n    fun __gl_computeInterior(tess: GLUtessellatorImpl): Boolean /*\n * __gl_computeInterior( tess ) computes the planar arrangement specified\n * by the given contours, and further subdivides this arrangement\n * into regions.  Each region is marked \"inside\" if it belongs\n * to the polygon, according to the rule given by tess.windingRule.\n * Each interior region is guaranteed be monotone.\n */ {\n        var v: GLUvertex?\n        var vNext: GLUvertex?\n        tess.fatalError = false\n\n        /* Each vertex defines an event for our sweep line.  Start by inserting\n         * all the vertices in a priority queue.  Events are processed in\n         * lexicographic order, ie.\n         *\n         *\te1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)\n         */RemoveDegenerateEdges(tess)\n        if (!InitPriorityQ(tess)) return false /* if error */\n        InitEdgeDict(tess)\n\n        /* __gl_pqSortExtractMin */while ((tess.pq!!.pqExtractMin() as GLUvertex?).also {\n                v = it\n            } != null) {\n            while (true) {\n                vNext = tess.pq!!.pqMinimum() as GLUvertex? /* __gl_pqSortMinimum */\n                if (vNext == null || !Geom.VertEq(vNext, v!!)) break\n\n                /* Merge together all vertices at exactly the same location.\n                 * This is more efficient than processing them one at a time,\n                 * simplifies the code (see ConnectLeftDegenerate), and is also\n                 * important for correct handling of certain degenerate cases.\n                 * For example, suppose there are two identical edges A and B\n                 * that belong to different contours (so without this code they would\n                 * be processed by separate sweep events).  Suppose another edge C\n                 * crosses A and B from above.  When A is processed, we split it\n                 * at its intersection point with C.  However this also splits C,\n                 * so when we insert B we may compute a slightly different\n                 * intersection point.  This might leave two edges with a small\n                 * gap between them.  This kind of error is especially obvious\n                 * when using boundary extraction (GLU_TESS_BOUNDARY_ONLY).\n                 */vNext =\n                    tess.pq!!.pqExtractMin() as GLUvertex /* __gl_pqSortExtractMin*/\n                SpliceMergeVertices(tess, v!!.anEdge!!, vNext.anEdge!!)\n            }\n            SweepEvent(tess, v!!)\n        }\n\n        /* Set tess.event for debugging purposes */\n        /* __GL_DICTLISTKEY */ /* __GL_DICTLISTMIN */tess.event =\n            (Dict.dictKey(Dict.dictMin(tess.dict!!)) as ActiveRegion).eUp!!.Org\n        DebugEvent(tess)\n        DoneEdgeDict(tess)\n        DonePriorityQ(tess)\n        if (!RemoveDegenerateFaces(tess.mesh!!)) return false\n        Mesh.__gl_meshCheckMesh(tess.mesh!!)\n        return true\n    }\n}\n","package org.openrndr.ktessellation\n\ninternal object TessState {\n    const val T_DORMANT = 0\n    const val T_IN_POLYGON = 1\n    const val T_IN_CONTOUR = 2\n}\n","package org.openrndr.ktessellation\n\nimport org.openrndr.ktessellation.GLU.gluErrorString\nimport org.openrndr.math.Vector2\n\nclass Tessellator : GLUtessellatorImpl() {\n    var primitives = mutableListOf<Primitive>()\n\n\n    init {\n        val callback: GLUtessellatorCallbackAdapter =\n            object : GLUtessellatorCallbackAdapter() {\n                override fun begin(type: Int) {\n                    primitives.add(Primitive(type))\n                }\n\n                override fun vertexData(vertexData: Any?, polygonData: Any?) {\n                    val data = vertexData as DoubleArray\n                    primitives[primitives.size - 1].positions.add(Vector2(data[0], data[1]))\n                }\n\n                override fun error(errnum: Int) {\n                    throw RuntimeException(\"GLU Error \" + gluErrorString(errnum))\n                }\n\n                override fun combine(\n                    coords: DoubleArray?,\n                    data: Array<Any?>?,\n                    weight: FloatArray?,\n                    outData: Array<Any?>?\n                ) {\n\n                    coords ?: error(\"coords == null\")\n                    outData ?: error(\"outData == null\")\n                    val result = DoubleArray(3)\n                    result[0] = coords[0]\n                    result[1] = coords[1]\n                    result[2] = coords[2]\n                    outData[0] = coords\n                }\n            }\n        gluTessCallback(GLU.GLU_TESS_BEGIN, callback)\n        gluTessCallback(GLU.GLU_TESS_VERTEX_DATA, callback)\n        gluTessCallback(GLU.GLU_TESS_ERROR, callback)\n        gluTessCallback(GLU.GLU_TESS_COMBINE, callback)\n    }\n}","@file:Suppress(\"SpellCheckingInspection\")\n\npackage org.openrndr.ktessellation\n\nopen class GLUtessellatorCallbackAdapter : GLUtessellatorCallback {\n    override fun begin(type: Int) {}\n    override fun edgeFlag(boundaryEdge: Boolean) {}\n    override fun vertex(vertexData: Any?) {}\n    override fun end() {}\n\n    override fun error(errnum: Int) {}\n    override fun combine(coords: DoubleArray?, data: Array<Any?>?, weight: FloatArray?, outData: Array<Any?>?) {\n    }\n\n    override fun beginData(type: Int, polygonData: Any?) {}\n    override fun edgeFlagData(\n        boundaryEdge: Boolean,\n        polygonData: Any?\n    ) {\n    }\n\n    override fun vertexData(vertexData: Any?, polygonData: Any?) {}\n    override fun endData(polygonData: Any?) {}\n    override fun errorData(errnum: Int, polygonData: Any?) {}\n    override fun combineData(\n        coords: DoubleArray?,\n        data: Array<Any?>?,\n        weight: FloatArray?,\n        outData: Array<Any?>?,\n        polygonData: Any?\n    ) {\n    }\n}\n","@file:Suppress(\"MemberVisibilityCanBePrivate\", \"FunctionName\", \"NAME_SHADOWING\", \"unused\")\n\npackage org.openrndr.ktessellation\n\nimport kotlin.math.abs\n\ninternal object Geom {\n    /* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),\n     * evaluates the t-coord of the edge uw at the s-coord of the vertex v.\n     * Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.\n     * If uw is vertical (and thus passes thru v), the result is zero.\n     *\n     * The calculation is extremely accurate and stable, even when v\n     * is very close to u or w.  In particular if we set v->t = 0 and\n     * let r be the negated result (this evaluates (uw)(v->s)), then\n     * r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).\n     */\n    fun EdgeEval(\n        u: GLUvertex,\n        v: GLUvertex,\n        w: GLUvertex\n    ): Double {\n        require(VertLeq(u, v) && VertLeq(v, w))\n        val gapL = v.s - u.s\n        val gapR = w.s - v.s\n        return if (gapL + gapR > 0) {\n            if (gapL < gapR) {\n                v.t - u.t + (u.t - w.t) * (gapL / (gapL + gapR))\n            } else {\n                v.t - w.t + (w.t - u.t) * (gapR / (gapL + gapR))\n            }\n        } else 0.0\n        /* vertical line */\n    }\n\n    fun EdgeSign(\n        u: GLUvertex,\n        v: GLUvertex,\n        w: GLUvertex\n    ): Double {\n        require(VertLeq(u, v) && VertLeq(v, w))\n        val gapL = v.s - u.s\n        val gapR = w.s - v.s\n        return if (gapL + gapR > 0) {\n            (v.t - w.t) * gapL + (v.t - u.t) * gapR\n        } else 0.0\n        /* vertical line */\n    }\n\n    /***********************************************************************\n     * Define versions of EdgeSign, EdgeEval with s and t transposed.\n     */\n    fun TransEval(\n        u: GLUvertex,\n        v: GLUvertex,\n        w: GLUvertex\n    ): Double {\n        /* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),\n         * evaluates the t-coord of the edge uw at the s-coord of the vertex v.\n         * Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.\n         * If uw is vertical (and thus passes thru v), the result is zero.\n         *\n         * The calculation is extremely accurate and stable, even when v\n         * is very close to u or w.  In particular if we set v->s = 0 and\n         * let r be the negated result (this evaluates (uw)(v->t)), then\n         * r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).\n         */\n        require(TransLeq(u, v) && TransLeq(v, w))\n        val gapL = v.t - u.t\n        val gapR = w.t - v.t\n        return if (gapL + gapR > 0) {\n            if (gapL < gapR) {\n                v.s - u.s + (u.s - w.s) * (gapL / (gapL + gapR))\n            } else {\n                v.s - w.s + (w.s - u.s) * (gapR / (gapL + gapR))\n            }\n        } else 0.0\n        /* vertical line */\n    }\n\n    fun TransSign(\n        u: GLUvertex,\n        v: GLUvertex,\n        w: GLUvertex\n    ): Double {\n        /* Returns a number whose sign matches TransEval(u,v,w) but which\n         * is cheaper to evaluate.  Returns > 0, == 0 , or < 0\n         * as v is above, on, or below the edge uw.\n         */\n        require(TransLeq(u, v) && TransLeq(v, w))\n        val gapL: Double = v.t - u.t\n        val gapR: Double = w.t - v.t\n        return if (gapL + gapR > 0) {\n            (v.s - w.s) * gapL + (v.s - u.s) * gapR\n        } else 0.0\n        /* vertical line */\n    }\n\n    fun VertCCW(\n        u: GLUvertex,\n        v: GLUvertex,\n        w: GLUvertex\n    ): Boolean {\n        /* For almost-degenerate situations, the results are not reliable.\n         * Unless the floating-point arithmetic can be performed without\n         * rounding errors, *any* implementation will give incorrect results\n         * on some degenerate inputs, so the client must have some way to\n         * handle this situation.\n         */\n        return u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t) >= 0\n    }\n\n    /* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),\n * or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces\n * this in the rare case that one argument is slightly negative.\n * The implementation is extremely stable numerically.\n * In particular it guarantees that the result r satisfies\n * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate\n * even when a and b differ greatly in magnitude.\n */\n    fun Interpolate(a: Double, x: Double, b: Double, y: Double): Double {\n        var a = a\n        var b = b\n        a = if (a < 0) 0.0 else a\n        b = if (b < 0) 0.0 else b\n        return if (a <= b) {\n            if (b == 0.0) {\n                (x + y) / 2.0\n            } else {\n                x + (y - x) * (a / (a + b))\n            }\n        } else {\n            y + (x - y) * (b / (a + b))\n        }\n    }\n\n    fun EdgeIntersect(\n        o1: GLUvertex, d1: GLUvertex,\n        o2: GLUvertex, d2: GLUvertex,\n        v: GLUvertex\n    ) /* Given edges (o1,d1) and (o2,d2), compute their point of intersection.\n * The computed point is guaranteed to lie in the intersection of the\n * bounding rectangles defined by each edge.\n */ {\n        var o1: GLUvertex = o1\n        var d1: GLUvertex = d1\n        var o2: GLUvertex = o2\n        var d2: GLUvertex = d2\n        var z1: Double\n        var z2: Double\n\n        /* This is certainly not the most efficient way to find the intersection\n         * of two line segments, but it is very numerically stable.\n         *\n         * Strategy: find the two middle vertices in the VertLeq ordering,\n         * and interpolate the intersection s-value from these.  Then repeat\n         * using the TransLeq ordering to find the intersection t-value.\n         */if (!VertLeq(o1, d1)) {\n            val temp: GLUvertex = o1\n            o1 = d1\n            d1 = temp\n        }\n        if (!VertLeq(o2, d2)) {\n            val temp: GLUvertex = o2\n            o2 = d2\n            d2 = temp\n        }\n        if (!VertLeq(o1, o2)) {\n            var temp: GLUvertex = o1\n            o1 = o2\n            o2 = temp\n            temp = d1\n            d1 = d2\n            d2 = temp\n        }\n        if (!VertLeq(o2, d1)) {\n            /* Technically, no intersection -- do our best */\n            v.s = (o2.s + d1.s) / 2.0\n        } else if (VertLeq(d1, d2)) {\n            /* Interpolate between o2 and d1 */\n            z1 = EdgeEval(o1, o2, d1)\n            z2 = EdgeEval(o2, d1, d2)\n            if (z1 + z2 < 0) {\n                z1 = -z1\n                z2 = -z2\n            }\n            v.s = Interpolate(z1, o2.s, z2, d1.s)\n        } else {\n            /* Interpolate between o2 and d2 */\n            z1 = EdgeSign(o1, o2, d1)\n            z2 = -EdgeSign(o1, d2, d1)\n            if (z1 + z2 < 0) {\n                z1 = -z1\n                z2 = -z2\n            }\n            v.s = Interpolate(z1, o2.s, z2, d2.s)\n        }\n\n        /* Now repeat the process for t */if (!TransLeq(o1, d1)) {\n            val temp: GLUvertex = o1\n            o1 = d1\n            d1 = temp\n        }\n        if (!TransLeq(o2, d2)) {\n            val temp: GLUvertex = o2\n            o2 = d2\n            d2 = temp\n        }\n        if (!TransLeq(o1, o2)) {\n            var temp: GLUvertex = o2\n            o2 = o1\n            o1 = temp\n            temp = d2\n            d2 = d1\n            d1 = temp\n        }\n        if (!TransLeq(o2, d1)) {\n            /* Technically, no intersection -- do our best */\n            v.t = (o2.t + d1.t) / 2.0\n        } else if (TransLeq(d1, d2)) {\n            /* Interpolate between o2 and d1 */\n            z1 = TransEval(o1, o2, d1)\n            z2 = TransEval(o2, d1, d2)\n            if (z1 + z2 < 0) {\n                z1 = -z1\n                z2 = -z2\n            }\n            v.t = Interpolate(z1, o2.t, z2, d1.t)\n        } else {\n            /* Interpolate between o2 and d2 */\n            z1 = TransSign(o1, o2, d1)\n            z2 = -TransSign(o1, d2, d1)\n            if (z1 + z2 < 0) {\n                z1 = -z1\n                z2 = -z2\n            }\n            v.t = Interpolate(z1, o2.t, z2, d2.t)\n        }\n    }\n\n    fun VertEq(u: GLUvertex, v: GLUvertex): Boolean {\n        return u.s == v.s && u.t == v.t\n    }\n\n    fun VertLeq(u: GLUvertex, v: GLUvertex): Boolean {\n        return u.s < v.s || u.s == v.s && u.t <= v.t\n    }\n\n    /* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */\n    fun TransLeq(u: GLUvertex, v: GLUvertex): Boolean {\n        return u.t < v.t || u.t == v.t && u.s <= v.s\n    }\n\n    fun EdgeGoesLeft(e: GLUhalfEdge): Boolean {\n        return VertLeq(e.Sym?.Org ?: error(\"sym.org == null\"), e.Org ?: error(\"e.org == null\"))\n    }\n\n    fun EdgeGoesRight(e: GLUhalfEdge): Boolean {\n        return VertLeq(e.Org ?: error(\"e.org == null\"), e.Sym?.Org ?: error(\"e.sym.org == null\"))\n    }\n\n    fun VertL1dist(u: GLUvertex, v: GLUvertex): Double {\n        return abs(u.s - v.s) + abs(u.t - v.t)\n    }\n}\n","@file:Suppress(\n    \"SENSELESS_COMPARISON\", \"FunctionName\", \"NAME_SHADOWING\", \"UNNECESSARY_NOT_NULL_ASSERTION\",\n    \"MemberVisibilityCanBePrivate\", \"FoldInitializerAndIfToElvis\", \"unused\"\n)\n\npackage org.openrndr.ktessellation\n\ninternal object Mesh {\n    /************************ Utility Routines  */ /* MakeEdge creates a new pair of half-edges which form their own loop.\n * No vertex or face structures are allocated, but these must be assigned\n * before the current edge operation is completed.\n */\n    fun MakeEdge(eNext: GLUhalfEdge): GLUhalfEdge {\n        var eNext: GLUhalfEdge = eNext\n\n//        EdgePair * pair = (EdgePair *)\n//        memAlloc(sizeof(EdgePair));\n//        if (pair == NULL) return NULL;\n//\n//        e = &pair - > e;\n        val e = GLUhalfEdge(true)\n        //        eSym = &pair - > eSym;\n        val eSym = GLUhalfEdge(false)\n\n\n        /* Make sure eNext points to the first edge of the edge pair */if (!eNext.first) {\n            eNext = eNext.Sym ?: error(\"eNext.Sym == null\")\n        }\n\n        /* Insert in circular doubly-linked list before eNext.\n         * Note that the prev pointer is stored in Sym->next.\n         */\n        val ePrev: GLUhalfEdge = eNext.Sym?.next ?: error(\"eNext.Sym.next == null\")\n        eSym.next = ePrev\n        ePrev.Sym!!.next = e\n        e.next = eNext\n        eNext.Sym!!.next = eSym\n        e.Sym = eSym\n        e.Onext = e\n        e.Lnext = eSym\n        e.Org = null\n        e.Lface = null\n        e.winding = 0\n        e.activeRegion = null\n        eSym.Sym = e\n        eSym.Onext = eSym\n        eSym.Lnext = e\n        eSym.Org = null\n        eSym.Lface = null\n        eSym.winding = 0\n        eSym.activeRegion = null\n        return e\n    }\n\n    /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the\n * CS348a notes (see mesh.h).  Basically it modifies the mesh so that\n * a->Onext and b->Onext are exchanged.  This can have various effects\n * depending on whether a and b belong to different face or vertex rings.\n * For more explanation see __gl_meshSplice() below.\n */\n    fun Splice(a: GLUhalfEdge, b: GLUhalfEdge) {\n        val aOnext: GLUhalfEdge = a.Onext ?: error(\"a.Onext == null\")\n        val bOnext: GLUhalfEdge = b.Onext ?: error(\"a.Onext == null\")\n        aOnext.Sym?.Lnext = b\n        bOnext.Sym?.Lnext = a\n        a.Onext = bOnext\n        b.Onext = aOnext\n    }\n\n    /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the\n * origin of all edges in the vertex loop to which eOrig belongs. \"vNext\" gives\n * a place to insert the new vertex in the global vertex list.  We insert\n * the new vertex *before* vNext so that algorithms which walk the vertex\n * list will not see the newly created vertices.\n */\n    fun MakeVertex(\n        newVertex: GLUvertex,\n        eOrig: GLUhalfEdge, vNext: GLUvertex\n    ) {\n        var e: GLUhalfEdge\n        val vNew: GLUvertex = newVertex\n        require(vNew != null)\n\n        /* insert in circular doubly-linked list before vNext */\n        val vPrev: GLUvertex = vNext.prev ?: error(\"vNext.prev == null\")\n        vNew.prev = vPrev\n        vPrev.next = vNew\n        vNew.next = vNext\n        vNext.prev = vNew\n        vNew.anEdge = eOrig\n        vNew.data = null\n        /* leave coords, s, t undefined */\n\n        /* fix other edges on this vertex loop */e = eOrig\n        do {\n            e.Org = vNew\n            e = e.Onext ?: error(e.Onext == null)\n        } while (e !== eOrig)\n    }\n\n    /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left\n * face of all edges in the face loop to which eOrig belongs.  \"fNext\" gives\n * a place to insert the new face in the global face list.  We insert\n * the new face *before* fNext so that algorithms which walk the face\n * list will not see the newly created faces.\n */\n    fun MakeFace(\n        newFace: GLUface,\n        eOrig: GLUhalfEdge,\n        fNext: GLUface\n    ) {\n        var e: GLUhalfEdge\n        val fNew: GLUface = newFace\n        require(fNew != null)\n\n        /* insert in circular doubly-linked list before fNext */\n        val fPrev: GLUface = fNext.prev ?: error(\"fNext.prev == null\")\n        fNew.prev = fPrev\n        fPrev.next = fNew\n        fNew.next = fNext\n        fNext.prev = fNew\n        fNew.anEdge = eOrig\n        fNew.data = null\n        fNew.trail = null\n        fNew.marked = false\n\n        /* The new face is marked \"inside\" if the old one was.  This is a\n         * convenience for the common case where a face has been split in two.\n         */fNew.inside = fNext.inside\n\n        /* fix other edges on this face loop */e = eOrig\n        do {\n            e.Lface = fNew\n            e = e.Lnext ?: error(\"e.Lnext == null\")\n        } while (e !== eOrig)\n    }\n\n    /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),\n * and removes from the global edge list.\n */\n    fun KillEdge(eDel: GLUhalfEdge) {\n        var eDel: GLUhalfEdge = eDel\n\n        /* Half-edges are allocated in pairs, see EdgePair above */if (!eDel.first) {\n            eDel = eDel.Sym ?: error(\"eDel.Sym == null\")\n        }\n\n        /* delete from circular doubly-linked list */\n        val eNext: GLUhalfEdge = eDel.next ?: error(\"eDel.next == null\")\n        val ePrev: GLUhalfEdge = eDel.Sym?.next ?: error(\"eDel.Sym.next == null\")\n        eNext.Sym!!.next = ePrev\n        ePrev.Sym!!.next = eNext\n    }\n\n    /* KillVertex( vDel ) destroys a vertex and removes it from the global\n * vertex list.  It updates the vertex loop to point to a given new vertex.\n */\n    fun KillVertex(vDel: GLUvertex, newOrg: GLUvertex?) {\n        var e: GLUhalfEdge\n        val eStart: GLUhalfEdge = vDel.anEdge ?: error(\"vDel.anEdge == null\")\n\n        /* change the origin of all affected edges */e = eStart\n        do {\n            e.Org = newOrg\n            e = e.Onext ?: error(\"e.Onext == null\")\n        } while (e !== eStart)\n\n        /* delete from circular doubly-linked list */\n        val vPrev: GLUvertex = vDel.prev ?: error(\"vDel.prev == null\")\n        val vNext: GLUvertex = vDel.next ?: error(\"vDel.next == null\")\n        vNext.prev = vPrev\n        vPrev.next = vNext\n    }\n\n    /* KillFace( fDel ) destroys a face and removes it from the global face\n * list.  It updates the face loop to point to a given new face.\n */\n    fun KillFace(fDel: GLUface, newLface: GLUface?) {\n        var e: GLUhalfEdge\n        val eStart: GLUhalfEdge = fDel.anEdge ?: error(\"fDel.anEdge == null\")\n\n        /* change the left face of all affected edges */e = eStart\n        do {\n            e.Lface = newLface\n            e = e.Lnext ?: error(\"e.Lnext == null\")\n        } while (e !== eStart)\n\n        /* delete from circular doubly-linked list */\n        val fPrev: GLUface = fDel.prev ?: error(\"fDel.prev == null\")\n        val fNext: GLUface = fDel.next ?: error(\"fDel.next == null\")\n        fNext.prev = fPrev\n        fPrev.next = fNext\n    }\n\n    /****************** Basic Edge Operations  */ /* __gl_meshMakeEdge creates one edge, two vertices, and a loop (face).\n * The loop consists of the two new half-edges.\n */\n    fun __gl_meshMakeEdge(mesh: GLUmesh): GLUhalfEdge? {\n        val newVertex1 = GLUvertex()\n        val newVertex2 = GLUvertex()\n        val newFace = GLUface()\n        val e: GLUhalfEdge = MakeEdge(mesh.eHead)\n        if (e == null) return null\n        MakeVertex(newVertex1, e, mesh.vHead)\n        MakeVertex(newVertex2, e.Sym ?: error(\"e.Sym == null\"), mesh.vHead)\n        MakeFace(newFace, e, mesh.fHead)\n        return e\n    }\n\n    /* __gl_meshSplice( eOrg, eDst ) is the basic operation for changing the\n * mesh connectivity and topology.  It changes the mesh so that\n *\teOrg->Onext <- OLD( eDst->Onext )\n *\teDst->Onext <- OLD( eOrg->Onext )\n * where OLD(...) means the value before the meshSplice operation.\n *\n * This can have two effects on the vertex structure:\n *  - if eOrg->Org != eDst->Org, the two vertices are merged together\n *  - if eOrg->Org == eDst->Org, the origin is split into two vertices\n * In both cases, eDst->Org is changed and eOrg->Org is untouched.\n *\n * Similarly (and independently) for the face structure,\n *  - if eOrg->Lface == eDst->Lface, one loop is split into two\n *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one\n * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.\n *\n * Some special cases:\n * If eDst == eOrg, the operation has no effect.\n * If eDst == eOrg->Lnext, the new face will have a single edge.\n * If eDst == eOrg->Lprev, the old face will have a single edge.\n * If eDst == eOrg->Onext, the new vertex will have a single edge.\n * If eDst == eOrg->Oprev, the old vertex will have a single edge.\n */\n    fun __gl_meshSplice(\n        eOrg: GLUhalfEdge,\n        eDst: GLUhalfEdge\n    ): Boolean {\n        var joiningLoops = false\n        var joiningVertices = false\n        if (eOrg === eDst) return true\n        if (eDst.Org !== eOrg.Org) {\n            /* We are merging two disjoint vertices -- destroy eDst->Org */\n            joiningVertices = true\n            KillVertex(eDst.Org ?: error(\"eDst.Org == null\"), eOrg.Org ?: error(\"eOrg.Org == null\"))\n        }\n        if (eDst.Lface !== eOrg.Lface) {\n            /* We are connecting two disjoint loops -- destroy eDst.Lface */\n            joiningLoops = true\n            KillFace(eDst.Lface ?: error(\"eDst.Lface == null\"), eOrg.Lface ?: error(\"eOrg.Lface == null\"))\n        }\n\n        /* Change the edge structure */Splice(eDst, eOrg)\n        if (!joiningVertices) {\n            val newVertex = GLUvertex()\n\n            /* We split one vertex into two -- the new vertex is eDst.Org.\n             * Make sure the old vertex points to a valid half-edge.\n             */MakeVertex(newVertex, eDst, eOrg.Org ?: error(\"eOrg.Org == null\"))\n            eOrg.Org!!.anEdge = eOrg\n        }\n        if (!joiningLoops) {\n            val newFace = GLUface()\n\n            /* We split one loop into two -- the new loop is eDst.Lface.\n             * Make sure the old face points to a valid half-edge.\n             */MakeFace(newFace, eDst, eOrg.Lface ?: error(\"eOrg.Lface == null\"))\n            eOrg.Lface!!.anEdge = eOrg\n        }\n        return true\n    }\n\n    /* __gl_meshDelete( eDel ) removes the edge eDel.  There are several cases:\n * if (eDel.Lface != eDel.Rface), we join two loops into one; the loop\n * eDel.Lface is deleted.  Otherwise, we are splitting one loop into two;\n * the newly created loop will contain eDel.Dst.  If the deletion of eDel\n * would create isolated vertices, those are deleted as well.\n *\n * This function could be implemented as two calls to __gl_meshSplice\n * plus a few calls to memFree, but this would allocate and delete\n * unnecessary vertices and faces.\n */\n    fun __gl_meshDelete(eDel: GLUhalfEdge): Boolean {\n        val eDelSym: GLUhalfEdge = eDel.Sym ?: error(\"eDel.Sym == null\")\n        var joiningLoops = false\n\n        /* First step: disconnect the origin vertex eDel.Org.  We make all\n         * changes to get a consistent mesh in this \"intermediate\" state.\n         */if (eDel.Lface !== eDel.Sym!!.Lface) {\n            /* We are joining two loops into one -- remove the left face */\n            joiningLoops = true\n            KillFace(eDel.Lface ?: error(\"eDel.Lface == null\"), eDel.Sym?.Lface ?: error(\"eDel.Sym.Lface == null\"))\n        }\n        if (eDel.Onext === eDel) {\n            KillVertex(eDel.Org ?: error(\"eDel.Org == null\"), null)\n        } else {\n            /* Make sure that eDel.Org and eDel.Sym.Lface point to valid half-edges */\n            eDel.Sym!!.Lface!!.anEdge = eDel.Sym!!.Lnext\n            eDel.Org!!.anEdge = eDel.Onext\n            Splice(eDel, eDel.Sym!!.Lnext!!)\n            if (!joiningLoops) {\n                val newFace = GLUface()\n\n                /* We are splitting one loop into two -- create a new loop for eDel. */MakeFace(\n                    newFace,\n                    eDel,\n                    eDel.Lface ?: error(\"eDel.Lface == null\")\n                )\n            }\n        }\n\n        /* Claim: the mesh is now in a consistent state, except that eDel.Org\n         * may have been deleted.  Now we disconnect eDel.Dst.\n         */if (eDelSym.Onext === eDelSym) {\n            KillVertex(eDelSym.Org ?: error(\"eDelSym.Org == null\"), null)\n            KillFace(eDelSym.Lface ?: error(\"eDelSym.Lface == null\"), null)\n        } else {\n            /* Make sure that eDel.Dst and eDel.Lface point to valid half-edges */\n            eDel.Lface!!.anEdge = eDelSym.Sym!!.Lnext\n            eDelSym.Org!!.anEdge = eDelSym.Onext\n            Splice(eDelSym, eDelSym.Sym!!.Lnext ?: error(\"eDelSym.Lnext == null\"))\n        }\n\n        /* Any isolated vertices or faces have already been freed. */\n        KillEdge(eDel)\n        return true\n    }\n\n    /******************** Other Edge Operations  */ /* All these routines can be implemented with the basic edge\n * operations above.  They are provided for convenience and efficiency.\n */\n    /* __gl_meshAddEdgeVertex( eOrg ) creates a new edge eNew such that\n * eNew == eOrg.Lnext, and eNew.Dst is a newly created vertex.\n * eOrg and eNew will have the same left face.\n */\n    fun __gl_meshAddEdgeVertex(eOrg: GLUhalfEdge): GLUhalfEdge {\n        val eNewSym: GLUhalfEdge\n        val eNew: GLUhalfEdge = MakeEdge(eOrg)\n        eNewSym = eNew.Sym ?: error(\"eNew.Sym == null\")\n\n        /* Connect the new edge appropriately */\n        Splice(eNew, eOrg.Lnext ?: error(\"eOrg.LNext == null\"))\n\n        /* Set the vertex and face information */\n        eNew.Org = eOrg.Sym!!.Org\n        run {\n            val newVertex = GLUvertex()\n            MakeVertex(newVertex, eNewSym, eNew.Org ?: error(\"eNew.Org == null\"))\n        }\n        eNewSym.Lface = eOrg.Lface\n        eNew.Lface = eNewSym.Lface\n        return eNew\n    }\n\n    /* __gl_meshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,\n * such that eNew == eOrg.Lnext.  The new vertex is eOrg.Sym.Org == eNew.Org.\n * eOrg and eNew will have the same left face.\n */\n    fun __gl_meshSplitEdge(eOrg: GLUhalfEdge): GLUhalfEdge {\n        val eNew: GLUhalfEdge\n        val tempHalfEdge: GLUhalfEdge = __gl_meshAddEdgeVertex(eOrg)\n        eNew = tempHalfEdge.Sym ?: error(\"tempHalfEdge.Sym == null\")\n\n        /* Disconnect eOrg from eOrg.Sym.Org and connect it to eNew.Org */\n        Splice(eOrg.Sym ?: error(\"eOrg.sym == null\"), eOrg.Sym?.Sym?.Lnext ?: error(\"eOrg.Sym.Sym.Lnext == null\"))\n        Splice(eOrg.Sym ?: error(\"eOrg.Sym == null\"), eNew)\n\n        /* Set the vertex and face information */\n        eOrg.Sym?.Org = eNew.Org\n        eNew.Sym?.Org?.anEdge = eNew.Sym /* may have pointed to eOrg.Sym */\n        eNew.Sym?.Lface = eOrg.Sym?.Lface ?: error(\"eOrg.Sym.LFace == null\")\n        eNew.winding = eOrg.winding /* copy old winding information */\n        eNew.Sym!!.winding = eOrg.Sym?.winding ?: error(\"eOrg.Sym.window == null\")\n        return eNew\n    }\n\n    /* __gl_meshConnect( eOrg, eDst ) creates a new edge from eOrg.Sym.Org\n * to eDst.Org, and returns the corresponding half-edge eNew.\n * If eOrg.Lface == eDst.Lface, this splits one loop into two,\n * and the newly created loop is eNew.Lface.  Otherwise, two disjoint\n * loops are merged into one, and the loop eDst.Lface is destroyed.\n *\n * If (eOrg == eDst), the new face will have only two edges.\n * If (eOrg.Lnext == eDst), the old face is reduced to a single edge.\n * If (eOrg.Lnext.Lnext == eDst), the old face is reduced to two edges.\n */\n    fun __gl_meshConnect(\n        eOrg: GLUhalfEdge,\n        eDst: GLUhalfEdge\n    ): GLUhalfEdge {\n        val eNewSym: GLUhalfEdge\n        var joiningLoops = false\n        val eNew: GLUhalfEdge = MakeEdge(eOrg)\n        eNewSym = eNew.Sym ?: error(\"eNew.Sym == null\")\n        if (eDst.Lface !== eOrg.Lface) {\n            /* We are connecting two disjoint loops -- destroy eDst.Lface */\n            joiningLoops = true\n            KillFace(eDst.Lface ?: error(\"eDst.Lface == null\"), eOrg.Lface)\n        }\n\n        /* Connect the new edge appropriately */\n        Splice(eNew, eOrg.Lnext ?: error(\"eOrg.Lnext == null\"))\n        Splice(eNewSym, eDst)\n\n        /* Set the vertex and face information */\n        eNew.Org = eOrg.Sym?.Org\n        eNewSym.Org = eDst.Org\n        eNewSym.Lface = eOrg.Lface\n        eNew.Lface = eNewSym.Lface\n\n        /* Make sure the old face points to a valid half-edge */\n        eOrg.Lface!!.anEdge = eNewSym\n        if (!joiningLoops) {\n            val newFace = GLUface()\n\n            /* We split one loop into two -- the new loop is eNew.Lface */\n            MakeFace(newFace, eNew, eOrg.Lface ?: error(\"eOrg.Lface == null\"))\n        }\n        return eNew\n    }\n\n    /******************** Other Operations  */ /* __gl_meshZapFace( fZap ) destroys a face and removes it from the\n * global face list.  All edges of fZap will have a null pointer as their\n * left face.  Any edges which also have a null pointer as their right face\n * are deleted entirely (along with any isolated vertices this produces).\n * An entire mesh can be deleted by zapping its faces, one at a time,\n * in any order.  Zapped faces cannot be used in further mesh operations!\n */\n    fun __gl_meshZapFace(fZap: GLUface) {\n        val eStart: GLUhalfEdge = fZap.anEdge ?: error(\"fZap.anEdge == null\")\n        var e: GLUhalfEdge\n        var eNext: GLUhalfEdge\n        var eSym: GLUhalfEdge\n\n        /* walk around face, deleting edges whose right face is also null */\n        eNext = eStart.Lnext ?: error(\"eStart.Lnext == null\")\n        do {\n            e = eNext\n            eNext = e.Lnext ?: error(e.Lnext == null)\n            e.Lface = null\n            if (e.Sym!!.Lface == null) {\n                /* delete the edge -- see __gl_MeshDelete above */\n                if (e.Onext === e) {\n                    KillVertex(e.Org ?: error(\"e.Org == null\"), null)\n                } else {\n                    /* Make sure that e.Org points to a valid half-edge */\n                    e.Org!!.anEdge = e.Onext\n                    Splice(e, e.Sym?.Lnext ?: error(\"e.Sym.Lnext == null\"))\n                }\n                eSym = e.Sym ?: error(\"e.Sym == null\")\n                if (eSym.Onext === eSym) {\n                    KillVertex(eSym.Org ?: error(\"eSym.Org == null\"), null)\n                } else {\n                    /* Make sure that eSym.Org points to a valid half-edge */\n                    eSym.Org!!.anEdge = eSym.Onext\n                    Splice(eSym, eSym.Sym?.Lnext ?: error(\"eSym.Sym.Lnext == null\"))\n                }\n                KillEdge(e)\n            }\n        } while (e !== eStart)\n\n        /* delete from circular doubly-linked list */\n        val fPrev: GLUface = fZap.prev ?: error(\"fZap.prev == null\")\n        val fNext: GLUface = fZap.next ?: error(\"fZap.next == null\")\n        fNext.prev = fPrev\n        fPrev.next = fNext\n    }\n\n    /* __gl_meshNewMesh() creates a new mesh with no edges, no vertices,\n * and no loops (what we usually call a \"face\").\n */\n    fun __gl_meshNewMesh(): GLUmesh {\n        val v: GLUvertex\n        val f: GLUface\n        val e: GLUhalfEdge\n        val eSym: GLUhalfEdge\n        val mesh = GLUmesh()\n        v = mesh.vHead\n        f = mesh.fHead\n        e = mesh.eHead\n        eSym = mesh.eHeadSym\n        v.prev = v\n        v.next = v.prev\n        v.anEdge = null\n        v.data = null\n        f.prev = f\n        f.next = f.prev\n        f.anEdge = null\n        f.data = null\n        f.trail = null\n        f.marked = false\n        f.inside = false\n        e.next = e\n        e.Sym = eSym\n        e.Onext = null\n        e.Lnext = null\n        e.Org = null\n        e.Lface = null\n        e.winding = 0\n        e.activeRegion = null\n        eSym.next = eSym\n        eSym.Sym = e\n        eSym.Onext = null\n        eSym.Lnext = null\n        eSym.Org = null\n        eSym.Lface = null\n        eSym.winding = 0\n        eSym.activeRegion = null\n        return mesh\n    }\n\n    /* __gl_meshUnion( mesh1, mesh2 ) forms the union of all structures in\n * both meshes, and returns the new mesh (the old meshes are destroyed).\n */\n    fun __gl_meshUnion(\n        mesh1: GLUmesh,\n        mesh2: GLUmesh\n    ): GLUmesh {\n        val f1: GLUface = mesh1.fHead\n        val v1: GLUvertex = mesh1.vHead\n        val e1: GLUhalfEdge = mesh1.eHead\n        val f2: GLUface = mesh2.fHead\n        val v2: GLUvertex = mesh2.vHead\n        val e2: GLUhalfEdge = mesh2.eHead\n\n        /* Add the faces, vertices, and edges of mesh2 to those of mesh1 */\n        if (f2.next !== f2) {\n            f1.prev!!.next = f2.next\n            f2.next!!.prev = f1.prev\n            f2.prev!!.next = f1\n            f1.prev = f2.prev\n        }\n        if (v2.next !== v2) {\n            v1.prev!!.next = v2.next\n            v2.next!!.prev = v1.prev\n            v2.prev!!.next = v1\n            v1.prev = v2.prev\n        }\n        if (e2.next !== e2) {\n            e1.Sym!!.next!!.Sym!!.next = e2.next\n            e2.next!!.Sym!!.next = e1.Sym!!.next\n            e2.Sym!!.next!!.Sym!!.next = e1\n            e1.Sym!!.next = e2!!.Sym!!.next\n        }\n        return mesh1\n    }\n\n    /* __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.\n */\n    fun __gl_meshDeleteMeshZap(mesh: GLUmesh) {\n        val fHead: GLUface = mesh.fHead\n        while (fHead.next !== fHead) {\n            __gl_meshZapFace(fHead.next ?: error(\"fHead.next == null\"))\n        }\n        require(mesh.vHead.next === mesh.vHead)\n    }\n\n    /* __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.\n */\n    fun __gl_meshDeleteMesh(mesh: GLUmesh) {\n        var f: GLUface\n        var fNext: GLUface\n        var v: GLUvertex\n        var vNext: GLUvertex\n        var e: GLUhalfEdge\n        var eNext: GLUhalfEdge\n        f = mesh.fHead.next ?: error(\"mesh.fHead.next == null\")\n        while (f !== mesh.fHead) {\n            fNext = f.next ?: error(\"f.next == null\")\n            f = fNext\n        }\n        v = mesh.vHead.next ?: error(\"mesh.vHead.next == null\")\n        while (v !== mesh.vHead) {\n            vNext = v.next ?: error(\"v.next == null\")\n            v = vNext\n        }\n        e = mesh.eHead.next ?: error(\"mesh.eHead.next == null\")\n        while (e !== mesh.eHead) {\n\n            /* One call frees both e and e.Sym (see EdgePair above) */\n            eNext = e.next ?: error(\"e.next == null\")\n            e = eNext\n        }\n    }\n\n    /* __gl_meshCheckMesh( mesh ) checks a mesh for self-consistency.\n */\n    @Suppress(\"UNUSED_VALUE\")\n    fun __gl_meshCheckMesh(mesh: GLUmesh) {\n        val fHead: GLUface = mesh.fHead\n        val vHead: GLUvertex = mesh.vHead\n        val eHead: GLUhalfEdge = mesh.eHead\n        var f: GLUface\n        var fPrev: GLUface\n        var v: GLUvertex\n        var vPrev: GLUvertex\n        var e: GLUhalfEdge\n        var ePrev: GLUhalfEdge\n        fPrev = fHead\n        fPrev = fHead\n        while (fPrev.next.also { f = it ?: error(\"it == null\") } !== fHead) {\n            require(f.prev === fPrev)\n            e = f.anEdge ?: error(\"f.anEdge == null\")\n            do {\n                require(e.Sym !== e)\n                require(e.Sym!!.Sym === e)\n                require(e.Lnext!!.Onext!!.Sym === e)\n                require(e.Onext!!.Sym!!.Lnext === e)\n                require(e.Lface === f)\n                e = e.Lnext ?: error(\"error e.Lnext == null\")\n            } while (e !== f.anEdge)\n            fPrev = f\n        }\n        require(f.prev === fPrev && f.anEdge == null && f.data == null)\n        vPrev = vHead\n        vPrev = vHead\n        while (vPrev.next.also { v = it ?: error(\"it == null\") } !== vHead) {\n            require(v.prev === vPrev)\n            e = v.anEdge ?: error(\"v.anEdge == null\")\n            do {\n                require(e.Sym !== e)\n                require(e.Sym!!.Sym === e)\n                require(e.Lnext!!.Onext!!.Sym === e)\n                require(e.Onext!!.Sym!!.Lnext === e)\n                require(e.Org === v)\n                e = e.Onext ?: error(\"e.Onext == null\")\n            } while (e !== v.anEdge)\n            vPrev = v\n        }\n        require(v.prev === vPrev && v.anEdge == null && v.data == null)\n        ePrev = eHead\n        ePrev = eHead\n        while (ePrev.next.also { e = it ?: error(\"it == null\") } !== eHead) {\n            require(e.Sym!!.next === ePrev.Sym)\n            require(e.Sym !== e)\n            require(e.Sym!!.Sym === e)\n            require(e.Org != null)\n            require(e.Sym!!.Org != null)\n            require(e.Lnext!!.Onext!!.Sym === e)\n            require(e.Onext!!.Sym!!.Lnext === e)\n            ePrev = e\n        }\n        require(e.Sym!!.next === ePrev.Sym && e.Sym === mesh.eHeadSym && e.Sym!!.Sym === e && e.Org == null && e.Sym!!.Org == null && e.Lface == null && e.Sym!!.Lface == null)\n    }\n}\n","@file:Suppress(\"USELESS_ELVIS\", \"FunctionName\", \"unused\", \"MemberVisibilityCanBePrivate\")\n\npackage org.openrndr.ktessellation\n\ninternal object TessMono {\n    /* __gl_meshTessellateMonoRegion( face ) tessellates a monotone region\n * (what else would it do??)  The region must consist of a single\n * loop of half-edges (see mesh.h) oriented CCW.  \"Monotone\" in this\n * case means that any vertical line intersects the interior of the\n * region in a single interval.\n *\n * Tessellation consists of adding interior edges (actually pairs of\n * half-edges), to split the region into non-overlapping triangles.\n *\n * The basic idea is explained in Preparata and Shamos (which I don''t\n * have handy right now), although their implementation is more\n * complicated than this one.  The are two edge chains, an upper chain\n * and a lower chain.  We process all vertices from both chains in order,\n * from right to left.\n *\n * The algorithm ensures that the following invariant holds after each\n * vertex is processed: the untessellated region consists of two\n * chains, where one chain (say the upper) is a single edge, and\n * the other chain is concave.  The left vertex of the single edge\n * is always to the left of all vertices in the concave chain.\n *\n * Each step consists of adding the rightmost unprocessed vertex to one\n * of the two chains, and forming a fan of triangles from the rightmost\n * of two chain endpoints.  Determining whether we can add each triangle\n * to the fan is a simple orientation test.  By making the fan as large\n * as possible, we restore the invariant (check it yourself).\n */\n    fun __gl_meshTessellateMonoRegion(face: GLUface): Boolean {\n        var up: GLUhalfEdge\n        var lo: GLUhalfEdge\n\n        /* All edges are oriented CCW around the boundary of the region.\n         * First, find the half-edge whose origin vertex is rightmost.\n         * Since the sweep goes from left to right, face->anEdge should\n         * be close to the edge we want.\n         */\n        up = face.anEdge ?: error(\"face.anEdge == null\")\n        require(up.Lnext !== up && up.Lnext?.Lnext !== up)\n        while (Geom.VertLeq(up.Sym?.Org ?: error(\"up.Sym.org == null\"), up.Org ?: error(\"up.Sym.org == null\"))) {\n            up = up.Onext?.Sym ?: error(\"up.Onext.sym = null\")\n        }\n        while (Geom.VertLeq(up.Org ?: error(\"up.Org == null\"), up.Sym?.Org ?: error(\"up.Sym.Org == null\"))) {\n            up = up.Lnext ?: error(\"up.Lnext == null\")\n        }\n        lo = up.Onext?.Sym ?: error(\"up.Onext.Sym == null\")\n        while (up.Lnext !== lo) {\n            if (Geom.VertLeq(up.Sym?.Org ?: error(\"up.Sym.Org == null\"), lo.Org ?: error(\"lo.Org == null\"))) {\n                /* up.Sym.Org is on the left.  It is safe to form triangles from lo.Org.\n                 * The EdgeGoesLeft test guarantees progress even when some triangles\n                 * are CW, given that the upper and lower chains are truly monotone.\n                 */\n                while (lo.Lnext !== up && (Geom.EdgeGoesLeft(lo.Lnext ?: error(\"lo.Lnext == null\"))\n                            || Geom.EdgeSign(\n                        lo.Org ?: error(\"lo.Org == null\"),\n                        lo.Sym?.Org ?: error(\"lo.Sym.Org = null\"),\n                        lo.Lnext?.Sym?.Org ?: error(\"lo.Lnext.Sym.Org == null\")\n                    ) <= 0)\n                ) {\n                    val tempHalfEdge: GLUhalfEdge =\n                        Mesh.__gl_meshConnect(lo.Lnext!!, lo) ?: return false\n                    lo = tempHalfEdge.Sym ?: error(\"tempHalfEdge.Sym == null\")\n                }\n                lo = lo.Onext?.Sym ?: error(\"lo.Onext.Sym == null\")\n            } else {\n                /* lo.Org is on the left.  We can make CCW triangles from up.Sym.Org. */\n                while (lo.Lnext !== up && (Geom.EdgeGoesRight(up.Onext?.Sym ?: error(\"up.Onext.Sym == null\"))\n                            || Geom.EdgeSign(\n                        up.Sym?.Org ?: error(\"up.Sym.Org == null\"), up.Org ?: error(\"up.Org == null\"),\n                        up.Onext?.Sym?.Org ?: error(\"up.Onext.Sym.Org == null\")\n                    ) >= 0)\n                ) {\n                    val tempHalfEdge: GLUhalfEdge =\n                        Mesh.__gl_meshConnect(up, up.Onext?.Sym ?: error(\"up.Onext.Sym == null\"))\n                            ?: return false\n                    up = tempHalfEdge.Sym ?: error(\"tempHalfEdge.Sym == null\")\n                }\n                up = up.Lnext ?: error(\"up.Lnext == null\")\n            }\n        }\n        require(lo.Lnext !== up)\n        while ((lo.Lnext?.Lnext ?: error(\"lo.Lnext.Lnext == null\")) !== up) {\n            val tempHalfEdge: GLUhalfEdge = Mesh.__gl_meshConnect(lo.Lnext!!, lo)\n                ?: return false\n            lo = tempHalfEdge.Sym ?: error(\"tempHalfEdge.Sym == null\")\n        }\n        return true\n    }\n\n    /* __gl_meshTessellateInterior( mesh ) tessellates each region of\n * the mesh which is marked \"inside\" the polygon.  Each such region\n * must be monotone.\n */\n    fun __gl_meshTessellateInterior(mesh: GLUmesh): Boolean {\n        var f: GLUface\n        var next: GLUface\n\n        f = mesh.fHead.next ?: error(\"mesh.fHead.next == null\")\n        while (f !== mesh.fHead) {\n\n            /* Make sure we don''t try to tessellate the new triangles. */\n            next = f.next ?: error(\"f.next == null\")\n            if (f.inside) {\n                if (!__gl_meshTessellateMonoRegion(f)) return false\n            }\n            f = next\n        }\n        return true\n    }\n\n    /* __gl_meshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces\n * which are not marked \"inside\" the polygon.  Since further mesh operations\n * on NULL faces are not allowed, the main purpose is to clean up the\n * mesh so that exterior loops are not represented in the data structure.\n */\n    fun __gl_meshDiscardExterior(mesh: GLUmesh) {\n        var f: GLUface\n        var next: GLUface\n\n        /*LINTED*/\n        f = mesh.fHead.next ?: error(\"mesh.fHead.next == null\")\n        while (f !== mesh.fHead) {\n\n            /* Since f will be destroyed, save its next pointer. */next = f.next ?: error(\"f.next == null\")\n            if (!f.inside) {\n                Mesh.__gl_meshZapFace(f)\n            }\n            f = next\n        }\n    }\n\n    //    private static final int MARKED_FOR_DELETION = 0x7fffffff;\n    /* __gl_meshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the\n * winding numbers on all edges so that regions marked \"inside\" the\n * polygon have a winding number of \"value\", and regions outside\n * have a winding number of 0.\n *\n * If keepOnlyBoundary is TRUE, it also deletes all edges which do not\n * separate an interior region from an exterior one.\n */\n    fun __gl_meshSetWindingNumber(mesh: GLUmesh, value: Int, keepOnlyBoundary: Boolean): Boolean {\n        var e: GLUhalfEdge\n        var eNext: GLUhalfEdge\n        e = mesh.eHead.next ?: error(\"mesh.eHead.next == null\")\n        while (e !== mesh.eHead) {\n            eNext = e.next ?: error(\"e.next == null\")\n            if (e.Sym!!.Lface!!.inside != e.Lface!!.inside) {\n\n                /* This is a boundary edge (one side is interior, one is exterior). */\n                e.winding = if (e.Lface!!.inside) value else -value\n            } else {\n\n                /* Both regions are interior, or both are exterior. */\n                if (!keepOnlyBoundary) {\n                    e.winding = 0\n                } else {\n                    if (!Mesh.__gl_meshDelete(e)) return false\n                }\n            }\n            e = eNext\n        }\n        return true\n    }\n}\n","package org.openrndr.ktessellation\n\ninterface GLUtessellator {\n    fun gluDeleteTess()\n    fun gluTessProperty(which: Int, value: Double)\n    fun gluTessProperty(which: Int, value: Int) {\n        gluTessProperty(which, value.toDouble())\n    }\n\n    /* Returns tessellator property */\n    fun gluGetTessProperty(\n        which: Int, value: DoubleArray,\n        value_offset: Int\n    ) /* gluGetTessProperty() */\n\n    fun gluTessNormal(x: Double, y: Double, z: Double)\n    fun gluTessCallback(\n        which: Int,\n        aCallback: GLUtessellatorCallback?\n    )\n\n    fun gluTessVertex(\n        coords: DoubleArray, coords_offset: Int,\n        vertexData: Any?\n    )\n\n    fun gluTessBeginPolygon(data: Any?)\n    fun gluTessBeginContour()\n    fun gluTessEndContour()\n    fun gluTessEndPolygon()\n\n    /** */ /* Obsolete calls -- for backward compatibility */\n    fun gluBeginPolygon()\n\n    /*ARGSUSED*/\n    fun gluNextContour(type: Int)\n    fun gluEndPolygon()\n}","package org.openrndr.math\n\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\ninterface EuclideanVector<T> : LinearType<T> where T : EuclideanVector<T>, T : LinearType<T> {\n\n    /**\n     * returns the zero vector\n     */\n    val zero: T\n\n    /**\n     * length in Euclidean space\n     */\n    val length: Double\n\n    /**\n     * normalized vector\n     */\n    val normalized: T\n        get() {\n            val l = length\n            return if (l == 0.0) {\n                zero\n            } else {\n                this / l\n            }\n        }\n\n    /**\n     * squared length in Euclidean space\n     */\n    val squaredLength: Double\n\n    /**\n     * distance to [other] in Euclidean space\n     */\n    fun distanceTo(other: T): Double\n\n    /**\n     * squared distance to [other] in Euclidean space\n     */\n    fun squaredDistanceTo(other: T): Double\n\n    /** returns the area of the parallelogram formed by extruding this over [other] */\n    fun areaBetween(other: T): Double {\n        return sqrt(squaredLength * other.squaredLength - dot(other).pow(2.0))\n    }\n\n    /**\n     * dot product between this and [right]\n     */\n    infix fun dot(right: T): Double\n\n    /**\n     * project this vector on [on]\n     */\n    infix fun projectedOn(on: T) = on * ((this dot on) / (on dot on))\n\n    /**\n     * reflect this vector over [surfaceNormal]\n     */\n    infix fun reflectedOver(surfaceNormal: T) = this - surfaceNormal * (this dot surfaceNormal) * 2.0\n\n    /**\n     * atan2 style angle between this and [other]\n     */\n    fun atan2(other: T) : Double {\n        val u = this.normalized\n        val v = other.normalized\n        val x = u dot v\n        val y = sqrt(1.0 - x * x)\n        return kotlin.math.atan2(y, x)\n    }\n\n    /**\n     * apply [function] to all components\n     */\n    fun map(function: (Double)->Double) : T\n\n}\n","package org.openrndr.math\n\nimport kotlin.math.*\n\nprivate const val DISCRIMINANT_EPSILON = 1e-10\nprivate const val SOLUTION_EPSILON = 1e-8\nprivate val MACHINE_EPSILON = 1.0.ulp\nprivate const val EPSILON = 1e-14\n\n// adapted from https://github.com/paperjs/paper.js/blob/develop/src/util/Numerical.js\n// converted from Artifex Equations.java\nprivate fun trim(acc: DoubleArray, len: Int) = acc.copyOf(len)\n\nprivate fun split(n: Double): DoubleArray {\n    val x = n * 134217729\n    val y = n - x\n    val hi = y + x\n    val lo = n - hi\n    return doubleArrayOf(hi, lo)\n}\n\nprivate fun discriminant(a: Double, b: Double, c: Double): Double {\n    var D = b * b - a * c\n    val E = b * b + a * c\n    if (abs(D) * 3 < E) {\n        val ad: DoubleArray = split(a)\n        val bd: DoubleArray = split(b)\n        val cd: DoubleArray = split(c)\n        val p = b * b\n        val dp = bd[0] * bd[0] - p + 2 * bd[0] * bd[1] + bd[1] * bd[1]\n        val q = a * c\n        val dq = ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0] + ad[1] * cd[1]\n        D = p - q + (dp - dq)\n    }\n    return D\n}\n\nfun solveLinear(a: Double, b: Double, acc: DoubleArray): Int {\n    return if (abs(a) < EPSILON) {\n        0\n    } else {\n        acc[0] = -b / a\n        1\n    }\n}\n\nfun solveLinear(a: Double, b: Double): DoubleArray {\n    val acc = DoubleArray(1)\n    return trim(acc, solveLinear(a, b, acc))\n}\n\n@Suppress(\"NAME_SHADOWING\")\nfun solveQuadratic(a: Double, b: Double, c: Double, acc: DoubleArray): Int {\n    var a = a\n    var b = b\n    var c = c\n    if (abs(a) < EPSILON) {\n        return solveLinear(b, c, acc)\n    }\n    b *= -0.5\n    val k: Double = normalizationFactor(a, b, c)\n    a *= k\n    b *= k\n    c *= k\n    val D = discriminant(a, b, c)\n    return if (D >= -DISCRIMINANT_EPSILON) {\n        val Q: Double = if (D < 0) 0.0 else sqrt(D)\n        val R = b + if (b < 0) -Q else Q\n        if (R == 0.0) {\n            acc[0] = c / a\n            acc[1] = -c / a\n        } else {\n            acc[0] = R / a\n            acc[1] = c / R\n        }\n        var writeIdx = 0\n        for (readIdx in 0..1) {\n            val x = acc[readIdx]\n\n            // since the tolerance for the discriminant is fairly large, we check our work\n            val y = a * x * x + -2 * b * x + c\n            if (abs(y) < SOLUTION_EPSILON) {\n                acc[writeIdx++] = x\n            }\n        }\n        writeIdx\n    } else {\n        0\n    }\n}\n\nfun solveQuadratic(a: Double, b: Double, c: Double): DoubleArray {\n    val acc = DoubleArray(2)\n    return trim(acc, solveQuadratic(a, b, c, acc))\n}\n\n@Suppress(\"NAME_SHADOWING\")\nfun solveCubic(a: Double, b: Double, c: Double, d: Double, acc: DoubleArray): Int {\n    var a = a\n    var b = b\n    var c = c\n    var d = d\n    val k: Double = normalizationFactor(a, b, c, d)\n    a *= k\n    b *= k\n    c *= k\n    d *= k\n    var x: Double\n    var b1: Double\n    var c2: Double\n    var qd: Double\n    var q: Double\n    if (abs(a) < EPSILON) {\n        return solveQuadratic(b, c, d, acc)\n    } else if (abs(d) < EPSILON) {\n        b1 = b\n        c2 = c\n        x = 0.0\n    } else {\n        x = -(b / a) / 3\n        b1 = a * x + b\n        c2 = b1 * x + c\n        qd = (a * x + b1) * x + c2\n        q = c2 * x + d\n        val t = q / a\n        val r = abs(t).pow(1 / 3.0)\n        val s = if (t < 0) -1.0 else 1.0\n        val td = -qd / a\n        val rd = if (td > 0) 1.324717957244746 * max(r, sqrt(td)) else r\n        var x0 = x - s * rd\n        if (x0 != x) {\n            do {\n                x = x0\n                b1 = a * x + b\n                c2 = b1 * x + c\n                qd = (a * x + b1) * x + c2\n                q = c2 * x + d\n                x0 = if (qd == 0.0) x else x - q / (qd / (1 + MACHINE_EPSILON))\n            } while (s * x0 > s * x)\n            if (abs(a) * x * x > abs(d / x)) {\n                c2 = -d / x\n                b1 = (c2 - c) / x\n            }\n        }\n    }\n    var solutions: Int = solveQuadratic(a, b1, c2, acc)\n    for (i in 0 until solutions) {\n        if (acc[i] == x) {\n            return solutions\n        }\n    }\n    val y = a * x * x * x + b * x * x + c * x + d\n    if (abs(y) < SOLUTION_EPSILON) {\n        acc[solutions++] = x\n    }\n    return solutions\n}\n\nfun solveCubic(a: Double, b: Double, c: Double, d: Double): DoubleArray {\n    val acc = DoubleArray(3)\n    return trim(acc, solveCubic(a, b, c, d, acc))\n}","package org.openrndr.math\n\nimport kotlin.math.max\nimport kotlin.math.pow\n\nfun normalizationFactor(a: Double, b: Double, c: Double, d: Double): Double {\n    val exponent = max(max(a, b), max(c, d)).asExponent.toDouble()\n    return if (exponent < -8 || exponent > 8) 2.0.pow(-exponent) else 1.0\n}\n\nfun normalizationFactor(a: Double, b: Double, c: Double): Double {\n    val exponent = max(max(a, b), c).asExponent.toDouble()\n    return if (exponent < -8 || exponent > 8) 2.0.pow(-exponent) else 1.0\n}\n\nfun normalizationFactor(a: Double, b: Double): Double {\n    val exponent = max(a, b).asExponent.toDouble()\n    return if (exponent < -8 || exponent > 8) 2.0.pow(-exponent) else 1.0\n}\n","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\nimport kotlin.math.sqrt\n\n/** Integer 2D vector, exclusively for integer calculations. */\n@Suppress(\"unused\")\n@Serializable\ndata class IntVector2(val x: Int, val y: Int) {\n    companion object {\n        val ZERO = IntVector2(0, 0)\n        val UNIT_X = IntVector2(1, 0)\n        val UNIT_Y = IntVector2(0, 1)\n    }\n\n    /** The Euclidean length of the vector. */\n    val length get() = sqrt(1.0 * x * x + y * y)\n\n    /** The squared Euclidean length of the vector. */\n    val squaredLength get() = x * x + y * y\n\n    /** Calculates a dot product between this [Vector2] and [right]. */\n    infix fun dot(right: IntVector2) = x * right.x + y * right.y\n\n    val yx: IntVector2 get() = IntVector2(y, x)\n    val xx: IntVector2 get() = IntVector2(x, x)\n    val yy: IntVector2 get() = IntVector2(y, y)\n    operator fun plus(v: IntVector2) = IntVector2(x + v.x, y + v.y)\n    operator fun minus(v: IntVector2) = IntVector2(x - v.x, y - v.y)\n    operator fun times(d: Int) = IntVector2(x * d, y * d)\n    operator fun div(d: Int) = IntVector2(x / d, y / d)\n\n    /** Casts to [Vector2]. */\n    val vector2 get() = Vector2(this.x.toDouble(), this.y.toDouble())\n}\n\noperator fun Int.times(v: IntVector2) = v * this","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\nimport kotlin.math.sqrt\n\n/** Integer 3D vector, exclusively for integer calculations. */\n@Suppress(\"unused\")\n@Serializable\ndata class IntVector3(val x: Int, val y: Int, val z: Int) {\n    companion object {\n        val ZERO = IntVector3(0, 0, 0)\n        val UNIT_X = IntVector3(1, 0, 0)\n        val UNIT_Y = IntVector3(0, 1, 0)\n        val UNIT_Z = IntVector3(0, 0, 1)\n    }\n\n    /** The Euclidean length of the vector. */\n    val length get() = sqrt(1.0 * x * x + y * y + z * z)\n\n    /** The squared Euclidean length of the vector. */\n    val squaredLength get() = x * x + y * y + z * z\n\n    /** Calculates a dot product between this [Vector3] and [right]. */\n    infix fun dot(right: IntVector3) = x * right.x + y * right.y + z * right.z\n    val xy get() = IntVector2(x, y)\n    val yx get() = IntVector2(y, x)\n    val xx get() = IntVector2(x, x)\n    val yy get() = IntVector2(y, y)\n    operator fun plus(v: IntVector3) = IntVector3(x + v.x, y + v.y, z + v.z)\n    operator fun minus(v: IntVector3) = IntVector3(x - v.x, y - v.y, z - v.z)\n    operator fun times(d: Int) = IntVector3(x * d, y * d, z * d)\n    operator fun div(d: Int) = IntVector3(x / d, y / d, z / d)\n\n    /** Casts to [Vector3]. */\n    val vector3 get() = Vector3(this.x.toDouble(), this.y.toDouble(), this.z.toDouble())\n}\n\noperator fun Int.times(v: IntVector3) = v * this","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\nimport kotlin.math.sqrt\n\n\n/** Integer 4D vector, exclusively for integer calculations. */\n@Suppress(\"unused\")\n@Serializable\ndata class IntVector4(val x: Int, val y: Int, val z: Int, val w: Int) {\n    companion object {\n        val ZERO = IntVector4(0, 0, 0, 0)\n        val UNIT_X = IntVector4(1, 0, 0, 0)\n        val UNIT_Y = IntVector4(0, 1, 0, 0)\n        val UNIT_Z = IntVector4(0, 0, 1, 0)\n        val UNIT_W = IntVector4(0, 0, 0, 1)\n    }\n\n    /** The Euclidean length of the vector. */\n    val length get() = sqrt(1.0 * x * x + y * y + z * z + w * w)\n\n    /** The squared Euclidean length of the vector. */\n    val squaredLength get() = x * x + y * y + z * z + w * w\n\n    /** Calculates a dot product between this [Vector4] and [right]. */\n    infix fun dot(right: IntVector4) = x * right.x + y * right.y + z * right.z + w * right.w\n\n    // don't need to be transient, but otherwise compiler is going into recursive loop\n    val xy get() = IntVector2(x, y)\n\n    val yx get() = IntVector2(y, x)\n    val xx get() = IntVector2(x, x)\n    val yy get() = IntVector2(y, y)\n    operator fun plus(v: IntVector4) = IntVector4(x + v.x, y + v.y, z + v.z, w + v.w)\n    operator fun minus(v: IntVector4) = IntVector4(x - v.x, y - v.y, z - v.z, w - v.w)\n    operator fun times(d: Int) = IntVector4(x * d, y * d, z * d, w * d)\n    operator fun div(d: Int) = IntVector4(x / d, y / d, z / d, w / d)\n\n    /** Casts to [Vector4]. */\n    val vector4 get() = Vector4(this.x.toDouble(), this.y.toDouble(), this.z.toDouble(), this.w.toDouble())\n}\n\noperator fun Int.times(v: IntVector4) = v * this","@file:Suppress(\"unused\")\n\npackage org.openrndr.math\n\nimport kotlin.jvm.JvmName\nimport kotlin.math.*\n\n/**\n * Linearly maps a value, which is given in the before domain to a value in the after domain.\n * @param beforeLeft the lowest value of the before range\n * @param beforeRight the highest value of the before range\n * @param afterLeft the lowest value of the after range\n * @param afterRight the highest value of the after range\n * @param value the value to be mapped\n * @param clamp constrain the result to the after range\n * @return a value in the after range\n */\nfun map(beforeLeft: Double, beforeRight: Double,\n        afterLeft: Double, afterRight: Double,\n        value: Double,\n        clamp: Boolean = false): Double {\n\n    val db = (beforeRight - beforeLeft)\n    val da = (afterRight - afterLeft)\n\n    return if (db != 0.0) {\n        val n = (value - beforeLeft) / db\n        afterLeft + (if (clamp) saturate(n) else n) * da\n    } else {\n        val n = value - beforeLeft\n        afterLeft + (if (clamp) saturate(n) else n) * da\n    }\n}\n\n/**\n * Linearly maps a value, which is given in the before domain to a value in the after domain.\n * @param before the before range\n * @param after the after range\n * @param value the value to be mapped\n * @param clamp constrain the result to the [after] range\n * @return a value in the [after] range\n */\nfun map(\n    before: ClosedFloatingPointRange<Double>,\n    after: ClosedFloatingPointRange<Double>,\n    value: Double,\n    clamp: Boolean = false\n): Double = map(before.start, before.endInclusive, after.start, after.endInclusive, value, clamp)\n\n/**\n * Linearly maps a value, which is given in the before domain to a value in the after domain\n * @param beforeLeft the lowest value of the before range\n * @param beforeRight the highest value of the before range\n * @param afterLeft the lowest value of the after range\n * @param afterRight the highest value of the after range\n * @param clamp constrain the result to the after range\n * @return a value in the after range\n */\n@JvmName(\"doubleMap\")\nfun Double.map(beforeLeft: Double, beforeRight: Double,\n               afterLeft: Double, afterRight: Double,\n               clamp: Boolean = false): Double {\n    return map(beforeLeft, beforeRight, afterLeft, afterRight, this, clamp)\n}\n\n/**\n * Linearly maps a value, which is given in the before domain to a value in the after domain.\n * @param before the before range\n * @param after the after range\n * @param clamp constrain the result to the [after] range\n * @return a value in the [after] range\n */\nfun Double.map(\n    before: ClosedFloatingPointRange<Double>,\n    after: ClosedFloatingPointRange<Double>,\n    clamp: Boolean = false\n): Double = map(before, after, this, clamp)\n\nfun Vector2.map(beforeLeft: Vector2, beforeRight: Vector2,\n                afterLeft: Vector2, afterRight: Vector2,\n                clamp: Boolean = false) =\n        Vector2(x.map(beforeLeft.x, beforeRight.x, afterLeft.x, afterRight.x,\n                clamp),\n                y.map(beforeLeft.y, beforeRight.y, afterLeft.y, afterRight.y,\n                        clamp))\n\nfun Vector3.map(beforeLeft: Vector3, beforeRight: Vector3,\n                afterLeft: Vector3, afterRight: Vector3,\n                clamp: Boolean = false) =\n        Vector3(x.map(beforeLeft.x, beforeRight.x, afterLeft.x, afterRight.x,\n                clamp),\n                y.map(beforeLeft.y, beforeRight.y, afterLeft.y, afterRight.y,\n                        clamp),\n                z.map(beforeLeft.z, beforeRight.z, afterLeft.z, afterRight.z,\n                        clamp))\n\nfun Vector4.map(beforeLeft: Vector4, beforeRight: Vector4,\n                afterLeft: Vector4, afterRight: Vector4,\n                clamp: Boolean = false) =\n        Vector4(x.map(beforeLeft.x, beforeRight.x, afterLeft.x, afterRight.x,\n                clamp),\n                y.map(beforeLeft.y, beforeRight.y, afterLeft.y, afterRight.y,\n                        clamp),\n                z.map(beforeLeft.z, beforeRight.z, afterLeft.z, afterRight.z,\n                        clamp),\n                w.map(beforeLeft.w, beforeRight.w, afterLeft.w, afterRight.w,\n                        clamp))\n\nfun linearstep(edge0: Double, edge1: Double, x: Double): Double = saturate((x - edge0) / (edge1 - edge0))\n\n/**\n * Smoothstep\n * @param edge0\n * @param edge1\n * @param x\n * @return a mapped value in the interval [0, 1]\n */\nfun smoothstep(edge0: Double, edge1: Double, x: Double): Double {\n    // Scale, bias and saturate x to 0..1 range\n    val u = saturate((x - edge0) / (edge1 - edge0))\n    // Evaluate polynomial\n    return u * u * (3 - 2 * u)\n}\n\n@JvmName(\"doubleSmoothstep\")\nfun Double.smoothstep(edge0: Double, edge1: Double) = smoothstep(edge0, edge1, this)\n\nfun Vector2.smoothstep(edge0: Vector2, edge1: Vector2): Vector2 =\n        Vector2(this.x.smoothstep(edge0.x, edge1.x),\n                this.y.smoothstep(edge0.y, edge1.y))\n\nfun Vector3.smoothstep(edge0: Vector3, edge1: Vector3): Vector3 =\n        Vector3(this.x.smoothstep(edge0.x, edge1.x),\n                this.y.smoothstep(edge0.y, edge1.y),\n                this.z.smoothstep(edge0.z, edge1.z))\n\nfun Vector4.smoothstep(edge0: Vector4, edge1: Vector4): Vector4 =\n        Vector4(this.x.smoothstep(edge0.x, edge1.x),\n                this.y.smoothstep(edge0.y, edge1.y),\n                this.z.smoothstep(edge0.z, edge1.z),\n                this.w.smoothstep(edge0.w, edge1.w))\n\n/**\n * Smoothstep\n * @param edge0\n * @param edge1\n * @param x\n * @return a mapped value in the interval [0, 1]\n */\nfun smoothstepIn(edge0: Double, edge1: Double, x: Double): Double {\n    // Scale, bias and saturate x to 0..1 range\n    val u = saturate((x - edge0) / (edge1 - edge0))\n    // Evaluate polynomial\n\n    return if (x < 0.5)\n        u * u * (3 - 2 * u)\n    else {\n        u\n    }\n}\n\n/**\n * Smootherstep\n * @param edge0\n * @param edge1\n * @param x\n * @return a mapped value in the interval [0, 1]\n */\nfun smootherstep(edge0: Double, edge1: Double, x: Double): Double {\n    // Scale, bias and saturate x to 0..1 range\n    val u = saturate((x - edge0) / (edge1 - edge0))\n    // Evaluate polynomial\n    return u * u * u * (u * (u * 6 - 15) + 10)\n}\n\n\nfun saturate(x: Double) = max(0.0, min(1.0, x))\n\n@JvmName(\"doubleSaturate\")\nfun Double.saturate() = saturate(this)\n\nfun Vector2.saturate() = Vector2(x.saturate(), y.saturate())\nfun Vector3.saturate() = Vector3(x.saturate(), y.saturate(), z.saturate())\nfun Vector4.saturate() = Vector4(x.saturate(), y.saturate(), z.saturate(), w.saturate())\n\nfun mix(left: Double, right: Double, x: Double) = left * (1.0 - x) + right * x\n\n/**\n * Similar to mix() but assuming that 355° and 5° are 10° apart, not 350°.\n */\nfun mixAngle(leftAngle: Double, rightAngle: Double, x: Double): Double {\n    val shortestAngle = ((((rightAngle - leftAngle) % 360) + 540) % 360) - 180\n    return (leftAngle + shortestAngle * x) % 360\n}\n","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\n\n/**\n * A 3x3 matrix with double precision\n */\n@Serializable\ndata class Matrix33(\n        val c0r0: Double = 0.0, val c1r0: Double = 0.0, val c2r0: Double = 0.0,\n        val c0r1: Double = 0.0, val c1r1: Double = 0.0, val c2r1: Double = 0.0,\n        val c0r2: Double = 0.0, val c1r2: Double = 0.0, val c2r2: Double = 0.0) : LinearType<Matrix33> {\n\n    companion object {\n        val IDENTITY = Matrix33(c0r0 = 1.0, c1r1 = 1.0, c2r2 = 1.0)\n        val ZERO = Matrix33()\n\n        fun fromColumnVectors(c0: Vector3, c1: Vector3, c2: Vector3): Matrix33 =\n                Matrix33(c0.x, c1.x, c2.x,\n                        c0.y, c1.y, c2.y,\n                        c0.z, c1.z, c2.z)\n\n    }\n\n    /**\n     * Returns a column vector\n     */\n    operator fun get(index: Int) =\n            when (index) {\n                0 -> Vector3(c0r0, c0r1, c0r2)\n                1 -> Vector3(c1r0, c1r1, c1r2)\n                2 -> Vector3(c2r0, c2r1, c2r2)\n\n                else -> throw RuntimeException(\"not implemented\")\n            }\n\n    val trace get() = c0r0 + c1r1 + c2r2\n\n    val determinant: Double\n        get() {\n            val x = c0r0 * (c1r1 * c2r2 - c1r2 * c2r1)\n            val y = -c1r0 * (c0r1 * c2r2 - c0r2 * c2r1)\n            val z = c2r0 * (c0r1 * c1r2 - c1r1 * c0r2)\n            return x + y + z\n        }\n\n    val inversed: Matrix33\n        get() {\n            val invDet = 1.0 / determinant\n            return Matrix33(\n                    invDet * (c1r1 * c2r2 - c2r1 * c1r2),\n                    invDet * (c2r0 * c1r2 - c1r0 * c2r2),\n                    invDet * (c1r0 * c2r1 - c2r0 * c1r1),\n                    invDet * (c2r1 * c0r2 - c0r1 * c2r2),\n                    invDet * (c0r0 * c2r2 - c2r0 * c0r2),\n                    invDet * (c2r0 * c0r1 - c0r0 * c2r1),\n                    invDet * (c0r1 * c1r2 - c1r1 * c0r2),\n                    invDet * (c1r0 * c0r2 - c0r0 * c1r2),\n                    invDet * (c0r0 * c1r1 - c1r0 * c0r1))\n        }\n\n    override operator fun plus(right: Matrix33) = Matrix33(\n            c0r0 + right.c0r0, c1r0 + right.c1r0, c2r0 + right.c2r0,\n            c0r1 + right.c0r1, c1r1 + right.c1r1, c2r1 + right.c2r1,\n            c0r2 + right.c0r2, c1r2 + right.c1r2, c2r2 + right.c2r2)\n\n    override operator fun minus(right: Matrix33) = Matrix33(\n            c0r0 - right.c0r0, c1r0 - right.c1r0, c2r0 - right.c2r0,\n            c0r1 - right.c0r1, c1r1 - right.c1r1, c2r1 - right.c2r1,\n            c0r2 - right.c0r2, c1r2 - right.c1r2, c2r2 - right.c2r2)\n\n    val transposed: Matrix33\n        get() = Matrix33(\n                c0r0, c0r1, c0r2,\n                c1r0, c1r1, c1r2,\n                c2r0, c2r1, c2r2)\n\n    val matrix44\n        get() = Matrix44(c0r0, c1r0, c2r0, 0.0,\n                c0r1, c1r1, c2r1, 0.0,\n                c0r2, c1r2, c2r2, 0.0,\n                0.0, 0.0, 0.0, 1.0)\n\n    operator fun times(v: Vector3) = Vector3(\n            v.x * c0r0 + v.y * c1r0 + v.z * c2r0,\n            v.x * c0r1 + v.y * c1r1 + v.z * c2r1,\n            v.x * c0r2 + v.y * c1r2 + v.z * c2r2)\n\n    override operator fun times(scale: Double) = Matrix33(c0r0 * scale, c1r0 * scale, c2r0 * scale,\n            c0r1 * scale, c1r1 * scale, c2r1 * scale,\n            c0r2 * scale, c1r2 * scale, c2r2 * scale)\n\n    override operator fun div(scale: Double) = Matrix33(c0r0 / scale, c1r0 / scale, c2r0 / scale,\n            c0r1 / scale, c1r1 / scale, c2r1 / scale,\n            c0r2 / scale, c1r2 / scale, c2r2 / scale)\n\n    operator fun times(mat: Matrix33) = Matrix33(\n            this.c0r0 * mat.c0r0 + this.c1r0 * mat.c0r1 + this.c2r0 * mat.c0r2,\n            this.c0r0 * mat.c1r0 + this.c1r0 * mat.c1r1 + this.c2r0 * mat.c1r2,\n            this.c0r0 * mat.c2r0 + this.c1r0 * mat.c2r1 + this.c2r0 * mat.c2r2,\n\n            this.c0r1 * mat.c0r0 + this.c1r1 * mat.c0r1 + this.c2r1 * mat.c0r2,\n            this.c0r1 * mat.c1r0 + this.c1r1 * mat.c1r1 + this.c2r1 * mat.c1r2,\n            this.c0r1 * mat.c2r0 + this.c1r1 * mat.c2r1 + this.c2r1 * mat.c2r2,\n\n            this.c0r2 * mat.c0r0 + this.c1r2 * mat.c0r1 + this.c2r2 * mat.c0r2,\n            this.c0r2 * mat.c1r0 + this.c1r2 * mat.c1r1 + this.c2r2 * mat.c1r2,\n            this.c0r2 * mat.c2r0 + this.c1r2 * mat.c2r1 + this.c2r2 * mat.c2r2)\n\n    override fun toString(): String =\n            \"$c0r0, $c1r0, $c2r0,\\n$c0r1, $c1r1, $c2r1,\\n$c0r2, $c1r2, $c2r2\"\n}\n\noperator fun Double.times(m: Matrix33) = m * this\n","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\n\n/**\n * A 4x4 matrix with double precision\n */\n@Serializable\ndata class Matrix44(\n    val c0r0: Double = 0.0, val c1r0: Double = 0.0, val c2r0: Double = 0.0, val c3r0: Double = 0.0,\n    val c0r1: Double = 0.0, val c1r1: Double = 0.0, val c2r1: Double = 0.0, val c3r1: Double = 0.0,\n    val c0r2: Double = 0.0, val c1r2: Double = 0.0, val c2r2: Double = 0.0, val c3r2: Double = 0.0,\n    val c0r3: Double = 0.0, val c1r3: Double = 0.0, val c2r3: Double = 0.0, val c3r3: Double = 0.0\n) : LinearType<Matrix44> {\n\n    companion object {\n        /**\n         * 4x4 identity matrix\n         */\n        val IDENTITY = Matrix44(c0r0 = 1.0, c1r1 = 1.0, c2r2 = 1.0, c3r3 = 1.0)\n\n        /**\n         * 4x4 zero matrix\n         */\n        val ZERO = Matrix44()\n\n        /**\n         * Creates a 4x4 matrix from column vectors.\n         *\n         * @param c0 The first column vector\n         * @param c1 The second column vector\n         * @param c2 The third column vector\n         * @param c3 The fourth column vector\n         */\n        fun fromColumnVectors(c0: Vector4, c1: Vector4, c2: Vector4, c3: Vector4): Matrix44 =\n            Matrix44(\n                c0.x, c1.x, c2.x, c3.x,\n                c0.y, c1.y, c2.y, c3.y,\n                c0.z, c1.z, c2.z, c3.z,\n                c0.w, c1.w, c2.w, c3.w\n            )\n\n\n        /**\n         * Constructs a matrix from `DoubleArray` with values in row-major order.\n         */\n        fun fromDoubleArray(a: DoubleArray): Matrix44 {\n            require(a.size >= 16) { \"input array is too short (${a.size}}, should have at least a length of 16)\" }\n            return Matrix44(\n                a[0], a[1], a[2], a[3],\n                a[4], a[5], a[6], a[7],\n                a[8], a[9], a[10], a[11],\n                a[12], a[13], a[14], a[15]\n            )\n        }\n    }\n\n    /**\n     * Convert matrix to a `DoubleArray` in row-major order\n     */\n    fun toDoubleArray(): DoubleArray {\n        return doubleArrayOf(\n            c0r0, c1r0, c2r0, c3r0,\n            c0r1, c1r1, c2r1, c3r1,\n            c0r2, c1r2, c2r2, c3r2,\n            c0r3, c1r3, c2r3, c3r3\n        )\n    }\n\n    /**\n     * Returns a column vector\n     */\n    operator fun get(index: Int) =\n        when (index) {\n            0 -> Vector4(c0r0, c0r1, c0r2, c0r3)\n            1 -> Vector4(c1r0, c1r1, c1r2, c1r3)\n            2 -> Vector4(c2r0, c2r1, c2r2, c2r3)\n            3 -> Vector4(c3r0, c3r1, c3r2, c3r3)\n            else -> throw RuntimeException(\"not implemented\")\n        }\n\n    /**\n     * Inversed version of the 4x4 matrix\n     */\n    val inversed: Matrix44\n        get() {\n            if (this === IDENTITY) {\n                return this\n            }\n            val n00 =\n                c1r2 * c2r3 * c3r1 - c1r3 * c2r2 * c3r1 + c1r3 * c2r1 * c3r2 - c1r1 * c2r3 * c3r2 - c1r2 * c2r1 * c3r3 + c1r1 * c2r2 * c3r3\n            val n01 =\n                c0r3 * c2r2 * c3r1 - c0r2 * c2r3 * c3r1 - c0r3 * c2r1 * c3r2 + c0r1 * c2r3 * c3r2 + c0r2 * c2r1 * c3r3 - c0r1 * c2r2 * c3r3\n            val n02 =\n                c0r2 * c1r3 * c3r1 - c0r3 * c1r2 * c3r1 + c0r3 * c1r1 * c3r2 - c0r1 * c1r3 * c3r2 - c0r2 * c1r1 * c3r3 + c0r1 * c1r2 * c3r3\n            val n03 =\n                c0r3 * c1r2 * c2r1 - c0r2 * c1r3 * c2r1 - c0r3 * c1r1 * c2r2 + c0r1 * c1r3 * c2r2 + c0r2 * c1r1 * c2r3 - c0r1 * c1r2 * c2r3\n            val n10 =\n                c1r3 * c2r2 * c3r0 - c1r2 * c2r3 * c3r0 - c1r3 * c2r0 * c3r2 + c1r0 * c2r3 * c3r2 + c1r2 * c2r0 * c3r3 - c1r0 * c2r2 * c3r3\n            val n11 =\n                c0r2 * c2r3 * c3r0 - c0r3 * c2r2 * c3r0 + c0r3 * c2r0 * c3r2 - c0r0 * c2r3 * c3r2 - c0r2 * c2r0 * c3r3 + c0r0 * c2r2 * c3r3\n            val n12 =\n                c0r3 * c1r2 * c3r0 - c0r2 * c1r3 * c3r0 - c0r3 * c1r0 * c3r2 + c0r0 * c1r3 * c3r2 + c0r2 * c1r0 * c3r3 - c0r0 * c1r2 * c3r3\n            val n13 =\n                c0r2 * c1r3 * c2r0 - c0r3 * c1r2 * c2r0 + c0r3 * c1r0 * c2r2 - c0r0 * c1r3 * c2r2 - c0r2 * c1r0 * c2r3 + c0r0 * c1r2 * c2r3\n            val n20 =\n                c1r1 * c2r3 * c3r0 - c1r3 * c2r1 * c3r0 + c1r3 * c2r0 * c3r1 - c1r0 * c2r3 * c3r1 - c1r1 * c2r0 * c3r3 + c1r0 * c2r1 * c3r3\n            val n21 =\n                c0r3 * c2r1 * c3r0 - c0r1 * c2r3 * c3r0 - c0r3 * c2r0 * c3r1 + c0r0 * c2r3 * c3r1 + c0r1 * c2r0 * c3r3 - c0r0 * c2r1 * c3r3\n            val n22 =\n                c0r1 * c1r3 * c3r0 - c0r3 * c1r1 * c3r0 + c0r3 * c1r0 * c3r1 - c0r0 * c1r3 * c3r1 - c0r1 * c1r0 * c3r3 + c0r0 * c1r1 * c3r3\n            val n23 =\n                c0r3 * c1r1 * c2r0 - c0r1 * c1r3 * c2r0 - c0r3 * c1r0 * c2r1 + c0r0 * c1r3 * c2r1 + c0r1 * c1r0 * c2r3 - c0r0 * c1r1 * c2r3\n            val n30 =\n                c1r2 * c2r1 * c3r0 - c1r1 * c2r2 * c3r0 - c1r2 * c2r0 * c3r1 + c1r0 * c2r2 * c3r1 + c1r1 * c2r0 * c3r2 - c1r0 * c2r1 * c3r2\n            val n31 =\n                c0r1 * c2r2 * c3r0 - c0r2 * c2r1 * c3r0 + c0r2 * c2r0 * c3r1 - c0r0 * c2r2 * c3r1 - c0r1 * c2r0 * c3r2 + c0r0 * c2r1 * c3r2\n            val n32 =\n                c0r2 * c1r1 * c3r0 - c0r1 * c1r2 * c3r0 - c0r2 * c1r0 * c3r1 + c0r0 * c1r2 * c3r1 + c0r1 * c1r0 * c3r2 - c0r0 * c1r1 * c3r2\n            val n33 =\n                c0r1 * c1r2 * c2r0 - c0r2 * c1r1 * c2r0 + c0r2 * c1r0 * c2r1 - c0r0 * c1r2 * c2r1 - c0r1 * c1r0 * c2r2 + c0r0 * c1r1 * c2r2\n\n            val d = determinant\n            return Matrix44(\n                n00 / d, n10 / d, n20 / d, n30 / d,\n                n01 / d, n11 / d, n21 / d, n31 / d,\n                n02 / d, n12 / d, n22 / d, n32 / d,\n                n03 / d, n13 / d, n23 / d, n33 / d\n            )\n        }\n\n    /**\n     * The trace of the 4x4 matrix\n     */\n    val trace: Double get() = c0r0 + c1r1 + c2r2 + c3r3\n\n    val determinant: Double\n        get() = c0r3 * c1r2 * c2r1 * c3r0 - c0r2 * c1r3 * c2r1 * c3r0 - c0r3 * c1r1 * c2r2 * c3r0 + c0r1 * c1r3 * c2r2 * c3r0 +\n                c0r2 * c1r1 * c2r3 * c3r0 - c0r1 * c1r2 * c2r3 * c3r0 - c0r3 * c1r2 * c2r0 * c3r1 + c0r2 * c1r3 * c2r0 * c3r1 +\n                c0r3 * c1r0 * c2r2 * c3r1 - c0r0 * c1r3 * c2r2 * c3r1 - c0r2 * c1r0 * c2r3 * c3r1 + c0r0 * c1r2 * c2r3 * c3r1 +\n                c0r3 * c1r1 * c2r0 * c3r2 - c0r1 * c1r3 * c2r0 * c3r2 - c0r3 * c1r0 * c2r1 * c3r2 + c0r0 * c1r3 * c2r1 * c3r2 +\n                c0r1 * c1r0 * c2r3 * c3r2 - c0r0 * c1r1 * c2r3 * c3r2 - c0r2 * c1r1 * c2r0 * c3r3 + c0r1 * c1r2 * c2r0 * c3r3 +\n                c0r2 * c1r0 * c2r1 * c3r3 - c0r0 * c1r2 * c2r1 * c3r3 - c0r1 * c1r0 * c2r2 * c3r3 + c0r0 * c1r1 * c2r2 * c3r3\n\n    /**\n     * Matrix addition\n     * @param right the other matrix\n     */\n    override operator fun plus(right: Matrix44) = Matrix44(\n        c0r0 + right.c0r0, c1r0 + right.c1r0, c2r0 + right.c2r0, c3r0 + right.c3r0,\n        c0r1 + right.c0r1, c1r1 + right.c1r1, c2r1 + right.c2r1, c3r1 + right.c3r1,\n        c0r2 + right.c0r2, c1r2 + right.c1r2, c2r2 + right.c2r2, c3r2 + right.c3r2,\n        c0r3 + right.c0r3, c1r3 + right.c1r3, c2r3 + right.c2r3, c3r3 + right.c3r3\n    )\n\n    /**\n     * Matrix subtraction\n     * @param right the other matrix\n     */\n    override operator fun minus(right: Matrix44) = Matrix44(\n        c0r0 - right.c0r0, c1r0 - right.c1r0, c2r0 - right.c2r0, c3r0 - right.c3r0,\n        c0r1 - right.c0r1, c1r1 - right.c1r1, c2r1 - right.c2r1, c3r1 - right.c3r1,\n        c0r2 - right.c0r2, c1r2 - right.c1r2, c2r2 - right.c2r2, c3r2 - right.c3r2,\n        c0r3 - right.c0r3, c1r3 - right.c1r3, c2r3 - right.c2r3, c3r3 - right.c3r3\n    )\n\n\n    /**\n     * Returns a transposed version of the matrix\n     */\n    val transposed: Matrix44\n        get() = Matrix44(\n            c0r0, c0r1, c0r2, c0r3,\n            c1r0, c1r1, c1r2, c1r3,\n            c2r0, c2r1, c2r2, c2r3,\n            c3r0, c3r1, c3r2, c3r3\n        )\n\n    /**\n     * The 3x3 top-left part of the 4x4 matrix\n     */\n    val matrix33: Matrix33\n        get() = Matrix33(\n            c0r0, c1r0, c2r0,\n            c0r1, c1r1, c2r1,\n            c0r2, c1r2, c2r2\n        )\n\n    /**\n     * Multiplies the 4x4 matrix with a vector 4\n     */\n    operator fun times(v: Vector4) = Vector4(\n        v.x * c0r0 + v.y * c1r0 + v.z * c2r0 + v.w * c3r0,\n        v.x * c0r1 + v.y * c1r1 + v.z * c2r1 + v.w * c3r1,\n        v.x * c0r2 + v.y * c1r2 + v.z * c2r2 + v.w * c3r2,\n        v.x * c0r3 + v.y * c1r3 + v.z * c2r3 + v.w * c3r3\n    )\n\n    /**\n     * Multiplies all the elements in the 4x4 matrix with a scalar\n     */\n    override operator fun times(scale: Double) = Matrix44(\n        c0r0 * scale, c1r0 * scale, c2r0 * scale, c3r0 * scale,\n        c0r1 * scale, c1r1 * scale, c2r1 * scale, c3r1 * scale,\n        c0r2 * scale, c1r2 * scale, c2r2 * scale, c3r2 * scale,\n        c0r3 * scale, c1r3 * scale, c2r3 * scale, c3r3 * scale\n    )\n\n    override operator fun div(scale: Double) = Matrix44(\n        c0r0 / scale, c1r0 / scale, c2r0 / scale, c3r0 / scale,\n        c0r1 / scale, c1r1 / scale, c2r1 / scale, c3r1 / scale,\n        c0r2 / scale, c1r2 / scale, c2r2 / scale, c3r2 / scale,\n        c0r3 / scale, c1r3 / scale, c2r3 / scale, c3r3 / scale\n    )\n\n\n    /**\n     * Matrix concatenation\n     */\n    operator fun times(mat: Matrix44) = when {\n        this === IDENTITY -> mat\n        mat === IDENTITY -> this\n        else -> Matrix44(\n            this.c0r0 * mat.c0r0 + this.c1r0 * mat.c0r1 + this.c2r0 * mat.c0r2 + this.c3r0 * mat.c0r3, // m00\n            this.c0r0 * mat.c1r0 + this.c1r0 * mat.c1r1 + this.c2r0 * mat.c1r2 + this.c3r0 * mat.c1r3, // c1r0\n            this.c0r0 * mat.c2r0 + this.c1r0 * mat.c2r1 + this.c2r0 * mat.c2r2 + this.c3r0 * mat.c2r3, // c2r0\n            this.c0r0 * mat.c3r0 + this.c1r0 * mat.c3r1 + this.c2r0 * mat.c3r2 + this.c3r0 * mat.c3r3, // c3r0\n\n            this.c0r1 * mat.c0r0 + this.c1r1 * mat.c0r1 + this.c2r1 * mat.c0r2 + this.c3r1 * mat.c0r3, // c0r1\n            this.c0r1 * mat.c1r0 + this.c1r1 * mat.c1r1 + this.c2r1 * mat.c1r2 + this.c3r1 * mat.c1r3, // c1r1\n            this.c0r1 * mat.c2r0 + this.c1r1 * mat.c2r1 + this.c2r1 * mat.c2r2 + this.c3r1 * mat.c2r3, // c2r1\n            this.c0r1 * mat.c3r0 + this.c1r1 * mat.c3r1 + this.c2r1 * mat.c3r2 + this.c3r1 * mat.c3r3, // c3r1\n\n            this.c0r2 * mat.c0r0 + this.c1r2 * mat.c0r1 + this.c2r2 * mat.c0r2 + this.c3r2 * mat.c0r3, // c0r2\n            this.c0r2 * mat.c1r0 + this.c1r2 * mat.c1r1 + this.c2r2 * mat.c1r2 + this.c3r2 * mat.c1r3, // c1r2\n            this.c0r2 * mat.c2r0 + this.c1r2 * mat.c2r1 + this.c2r2 * mat.c2r2 + this.c3r2 * mat.c2r3, // c2r2\n            this.c0r2 * mat.c3r0 + this.c1r2 * mat.c3r1 + this.c2r2 * mat.c3r2 + this.c3r2 * mat.c3r3, // c3r2\n\n            this.c0r3 * mat.c0r0 + this.c1r3 * mat.c0r1 + this.c2r3 * mat.c0r2 + this.c3r3 * mat.c0r3, // c0r3\n            this.c0r3 * mat.c1r0 + this.c1r3 * mat.c1r1 + this.c2r3 * mat.c1r2 + this.c3r3 * mat.c1r3, // c1r3\n            this.c0r3 * mat.c2r0 + this.c1r3 * mat.c2r1 + this.c2r3 * mat.c2r2 + this.c3r3 * mat.c2r3, // c2r3\n            this.c0r3 * mat.c3r0 + this.c1r3 * mat.c3r1 + this.c2r3 * mat.c3r2 + this.c3r3 * mat.c3r3 // c3r3\n        )\n    }\n\n    override fun toString(): String =\n        \"$c0r0, $c1r0, $c2r0, $c3r0,\\n$c0r1, $c1r1, $c2r1, $c3r1,\\n$c0r2, $c1r2, $c2r2, $c3r2,\\n$c0r3, $c1r3, $c2r3, $c3r3\"\n}\n\noperator fun Double.times(m: Matrix44) = m * this\n","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\n\n/**\n * A 5x5 matrix with double precision\n */\n@Serializable\ndata class Matrix55(\n        val c0r0: Double = 0.0, val c1r0: Double = 0.0, val c2r0: Double = 0.0, val c3r0: Double = 0.0, val c4r0: Double = 0.0,\n        val c0r1: Double = 0.0, val c1r1: Double = 0.0, val c2r1: Double = 0.0, val c3r1: Double = 0.0, val c4r1: Double = 0.0,\n        val c0r2: Double = 0.0, val c1r2: Double = 0.0, val c2r2: Double = 0.0, val c3r2: Double = 0.0, val c4r2: Double = 0.0,\n        val c0r3: Double = 0.0, val c1r3: Double = 0.0, val c2r3: Double = 0.0, val c3r3: Double = 0.0, val c4r3: Double = 0.0,\n        val c0r4: Double = 0.0, val c1r4: Double = 0.0, val c2r4: Double = 0.0, val c3r4: Double = 0.0, val c4r4: Double = 0.0) {\n\n    companion object {\n        /** A 5x5 identity matrix */\n        val IDENTITY = Matrix55(c0r0 = 1.0, c1r1 = 1.0, c2r2 = 1.0, c3r3 = 1.0, c4r4 = 1.0)\n        /** A 5x5 zero matrix */\n        val ZERO = Matrix55()\n    }\n\n    /**\n     * Convert the 5x5 matrix to an array of floats\n     * @return array of floats in row major format\n     */\n    val floatArray\n        get() = floatArrayOf(c0r0.toFloat(), c0r1.toFloat(), c0r2.toFloat(), c0r3.toFloat(), c0r4.toFloat(),\n                c1r0.toFloat(), c1r1.toFloat(), c1r2.toFloat(), c1r3.toFloat(), c1r4.toFloat(),\n                c2r0.toFloat(), c2r1.toFloat(), c2r2.toFloat(), c2r3.toFloat(), c2r4.toFloat(),\n                c3r0.toFloat(), c3r1.toFloat(), c3r2.toFloat(), c3r3.toFloat(), c3r4.toFloat(),\n                c4r0.toFloat(), c4r1.toFloat(), c4r2.toFloat(), c4r3.toFloat(), c4r4.toFloat()\n        )\n\n    /**\n     * Matrix concatenation\n     */\n    operator fun times(mat: Matrix55) = Matrix55(\n            this.c0r0 * mat.c0r0 + this.c1r0 * mat.c0r1 + this.c2r0 * mat.c0r2 + this.c3r0 * mat.c0r3 + this.c4r0 * mat.c0r4,\n            this.c0r0 * mat.c1r0 + this.c1r0 * mat.c1r1 + this.c2r0 * mat.c1r2 + this.c3r0 * mat.c1r3 + this.c4r0 * mat.c1r4,\n            this.c0r0 * mat.c2r0 + this.c1r0 * mat.c2r1 + this.c2r0 * mat.c2r2 + this.c3r0 * mat.c2r3 + this.c4r0 * mat.c2r4,\n            this.c0r0 * mat.c3r0 + this.c1r0 * mat.c3r1 + this.c2r0 * mat.c3r2 + this.c3r0 * mat.c3r3 + this.c4r0 * mat.c3r4,\n            this.c0r0 * mat.c4r0 + this.c1r0 * mat.c4r1 + this.c2r0 * mat.c4r2 + this.c3r0 * mat.c3r3 + this.c4r0 * mat.c4r4,\n\n            this.c0r1 * mat.c0r0 + this.c1r1 * mat.c0r1 + this.c2r1 * mat.c0r2 + this.c3r1 * mat.c0r3 + this.c4r1 * mat.c0r4,\n            this.c0r1 * mat.c1r0 + this.c1r1 * mat.c1r1 + this.c2r1 * mat.c1r2 + this.c3r1 * mat.c1r3 + this.c4r1 * mat.c1r4,\n            this.c0r1 * mat.c2r0 + this.c1r1 * mat.c2r1 + this.c2r1 * mat.c2r2 + this.c3r1 * mat.c2r3 + this.c4r1 * mat.c2r4,\n            this.c0r1 * mat.c3r0 + this.c1r1 * mat.c3r1 + this.c2r1 * mat.c3r2 + this.c3r1 * mat.c3r3 + this.c4r1 * mat.c3r4,\n            this.c0r1 * mat.c4r0 + this.c1r1 * mat.c4r1 + this.c2r1 * mat.c4r2 + this.c3r1 * mat.c4r3 + this.c4r1 * mat.c4r4,\n\n            this.c0r2 * mat.c0r0 + this.c1r2 * mat.c0r1 + this.c2r2 * mat.c0r2 + this.c3r2 * mat.c0r3 + this.c4r2 * mat.c0r4,\n            this.c0r2 * mat.c1r0 + this.c1r2 * mat.c1r1 + this.c2r2 * mat.c1r2 + this.c3r2 * mat.c1r3 + this.c4r2 * mat.c1r4,\n            this.c0r2 * mat.c2r0 + this.c1r2 * mat.c2r1 + this.c2r2 * mat.c2r2 + this.c3r2 * mat.c2r3 + this.c4r2 * mat.c2r4,\n            this.c0r2 * mat.c3r0 + this.c1r2 * mat.c3r1 + this.c2r2 * mat.c3r2 + this.c3r2 * mat.c3r3 + this.c4r2 * mat.c3r4,\n            this.c0r2 * mat.c4r0 + this.c1r2 * mat.c4r1 + this.c2r2 * mat.c4r2 + this.c3r2 * mat.c4r3 + this.c4r2 * mat.c4r4,\n\n            this.c0r3 * mat.c0r0 + this.c1r3 * mat.c0r1 + this.c2r3 * mat.c0r2 + this.c3r3 * mat.c0r3 + this.c4r3 * mat.c0r4,\n            this.c0r3 * mat.c1r0 + this.c1r3 * mat.c1r1 + this.c2r3 * mat.c1r2 + this.c3r3 * mat.c1r3 + this.c4r3 * mat.c1r4,\n            this.c0r3 * mat.c2r0 + this.c1r3 * mat.c2r1 + this.c2r3 * mat.c2r2 + this.c3r3 * mat.c2r3 + this.c4r3 * mat.c2r4,\n            this.c0r3 * mat.c3r0 + this.c1r3 * mat.c3r1 + this.c2r3 * mat.c3r2 + this.c3r3 * mat.c3r3 + this.c4r3 * mat.c3r4,\n            this.c0r3 * mat.c4r0 + this.c1r3 * mat.c4r1 + this.c2r3 * mat.c4r2 + this.c3r3 * mat.c4r3 + this.c4r3 * mat.c4r4,\n\n            this.c0r4 * mat.c0r0 + this.c1r4 * mat.c0r1 + this.c2r4 * mat.c0r2 + this.c3r4 * mat.c0r3 + this.c4r4 * mat.c0r4,\n            this.c0r4 * mat.c1r0 + this.c1r4 * mat.c1r1 + this.c2r4 * mat.c1r2 + this.c3r4 * mat.c1r3 + this.c4r4 * mat.c1r4,\n            this.c0r4 * mat.c2r0 + this.c1r4 * mat.c2r1 + this.c2r4 * mat.c2r2 + this.c3r4 * mat.c2r3 + this.c4r4 * mat.c2r4,\n            this.c0r4 * mat.c3r0 + this.c1r4 * mat.c3r1 + this.c2r4 * mat.c3r2 + this.c3r4 * mat.c3r3 + this.c4r4 * mat.c3r4,\n            this.c0r4 * mat.c4r0 + this.c1r4 * mat.c4r1 + this.c2r4 * mat.c4r2 + this.c3r4 * mat.c4r3 + this.c4r4 * mat.c4r4\n    )\n\n    /**\n     * Matrix element-wise addition\n     */\n    operator fun plus(mat: Matrix55) = Matrix55(\n            c0r0 + mat.c0r0, c1r0 + mat.c1r0, c2r0 + mat.c2r0, c3r0 + mat.c3r0, c4r0 + mat.c4r0,\n            c0r1 + mat.c0r1, c1r1 + mat.c1r1, c2r1 + mat.c2r1, c3r1 + mat.c3r1, c4r1 + mat.c4r1,\n            c0r2 + mat.c0r2, c1r2 + mat.c1r2, c2r2 + mat.c2r2, c3r2 + mat.c3r2, c4r2 + mat.c4r2,\n            c0r3 + mat.c0r3, c1r3 + mat.c1r3, c2r3 + mat.c2r3, c3r3 + mat.c3r3, c4r3 + mat.c4r3,\n            c0r4 + mat.c0r4, c1r4 + mat.c1r4, c2r4 + mat.c2r4, c3r4 + mat.c3r4, c4r4 + mat.c4r4)\n\n    /**\n     * Matrix element-wise multiplication\n     */\n    operator fun times(s: Double) = Matrix55(\n            c0r0 * s, c1r0 * s, c2r0 * s, c3r0 * s, c4r0 * s,\n            c0r1 * s, c1r1 * s, c2r1 * s, c3r1 * s, c4r1 * s,\n            c0r2 * s, c1r2 * s, c2r2 * s, c3r2 * s, c4r2 * s,\n            c0r3 * s, c1r3 * s, c2r3 * s, c3r3 * s, c4r3 * s,\n            c0r4 * s, c1r4 * s, c2r4 * s, c3r4 * s, c4r4 * s)\n\n    // @formatter:off\n    override fun toString(): String =\n        \"\"\"$c0r0, $c1r0, $c2r0, $c3r0, $c4r0,\n           $c0r1, $c1r1, $c2r1, $c3r1, $c4r1,\n           $c0r2, $c1r2, $c2r2, $c3r2, $c4r2,\n           $c0r3, $c1r3, $c2r3, $c3r3, $c4r3,\n           $c0r4, $c1r4, $c2r4, $c3r4, $c4r4\"\"\".trimIndent()\n    // @formatter:on\n\n}\n\n","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\nimport kotlin.math.atan2\n\n/**\n * A 2D point defined in the\n * [Polar coordinate system](https://en.wikipedia.org/wiki/Polar_coordinate_system).\n *\n * @param theta The angle in degrees.\n */\n@Serializable\ndata class Polar(val theta: Double, val radius: Double = 1.0) : LinearType<Polar> {\n\n    /**\n     * make a safe version by bringing [theta] between 0 and 360\n     */\n    fun makeSafe() = Polar(\n            mod(theta, 360.0),\n            radius\n    )\n\n    companion object {\n        /** Constructs equivalent polar coordinates from the Cartesian coordinate system. */\n        fun fromVector(vector: Vector2): Polar {\n            val r = vector.length\n            return Polar(\n                    if (r == 0.0) 0.0 else atan2(vector.y, vector.x).asDegrees,\n                    r\n            )\n        }\n    }\n\n    /** Constructs equivalent Cartesian coordinates from the polar representation. */\n    val cartesian: Vector2\n        get() {\n            return Vector2.fromPolar(this)\n        }\n\n    override operator fun plus(right: Polar) = Polar(theta + right.theta, radius + right.radius)\n    override operator fun minus(right: Polar) = Polar(theta - right.theta, radius - right.radius)\n    operator fun times(scale: Polar) = Polar(theta * scale.theta, radius * scale.radius)\n\n    override operator fun times(scale: Double) = Polar(theta * scale, radius * scale)\n    override operator fun div(scale: Double) = Polar(theta / scale, radius / scale)\n}\n","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\nimport kotlin.math.acos\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.math.sqrt\n\n/**\n * Quaternion class for representing orientations in 3D space\n */\n@Suppress(\"unused\", \"MemberVisibilityCanBePrivate\")\n@Serializable\ndata class Quaternion(val x: Double, val y: Double, val z: Double, val w: Double) {\n\n    companion object {\n        val IDENTITY: Quaternion = Quaternion(0.0, 0.0, 0.0, 1.0)\n        val ZERO: Quaternion = Quaternion(0.0, 0.0, 0.0, 0.0)\n\n        /**\n         * Construct [Quaternion] using from, to and up vectors\n         */\n        fun fromLookAt(from: Vector3, to: Vector3, up: Vector3 = Vector3.UNIT_Y): Quaternion {\n            val direction = to - from\n            val z = direction.normalized\n            val y = up.normalized\n            val x = (y cross z).normalized\n            val y2 = (z cross x).normalized\n            return fromAxes(x, y2, z).normalized\n        }\n\n        /**\n         * Construct [Quaternion] from axes\n         */\n        fun fromAxes(x: Vector3, y: Vector3, z: Vector3): Quaternion {\n            val m = Matrix33.fromColumnVectors(x, y, z)\n            return fromMatrix(m)\n        }\n\n        /**\n         * Construct [Quaternion] from [Matrix33]\n         * @param m a [Matrix33] that describes an ortho-normal basis\n         */\n        fun fromMatrix(m: Matrix33): Quaternion {\n            val t = m.trace + 1.0\n            val x: Double\n            val y: Double\n            val z: Double\n            val w: Double\n            if (t > 0) {\n                val s = 0.5 / sqrt(t)\n                w = 0.25 / s\n                x = (m.c1r2 - m.c2r1) * s\n                y = (m.c2r0 - m.c0r2) * s\n                z = (m.c0r1 - m.c1r0) * s\n            } else if (m.c0r0 > m.c1r1 && m.c0r0 > m.c2r2) {\n                val s = 0.5 / sqrt(1.0 + m.c0r0 - m.c1r1 - m.c2r2) // S=4*qx\n                w = (m.c1r2 - m.c2r1) * s\n                x = 0.25f / s\n                y = (m.c0r1 + m.c1r0) * s\n                z = (m.c2r0 + m.c0r2) * s\n            } else if (m.c1r1 > m.c2r2) {\n                val s = 0.5f / sqrt(1.0 + m.c1r1 - m.c0r0 - m.c2r2) // S=4*qy\n                w = (m.c2r0 - m.c0r2) * s\n                x = (m.c0r2 + m.c1r0) * s\n                y = 0.25f / s\n                z = (m.c1r2 + m.c2r1) * s\n            } else {\n                val s = 0.5f / sqrt(1.0 + m.c2r2 - m.c0r0 - m.c1r1) // S=4*qz\n                w = (m.c0r1 - m.c1r0) * s\n                x = (m.c2r0 + m.c0r2) * s\n                y = (m.c1r2 + m.c2r1) * s\n                z = 0.25f / s\n            }\n            return Quaternion(x, y, z, w)\n        }\n\n        /**\n         * Construct [Quaternion] from a set of degrees\n         */\n        fun fromAngles(pitch: Double, roll: Double, yaw: Double) =\n                fromAnglesRadian(pitch.asRadians, roll.asRadians, yaw.asRadians)\n\n        /**\n         * Construct [Quaternion] from a set of arc lengths\n         */\n        fun fromAnglesRadian(pitch: Double, roll: Double, yaw: Double): Quaternion {\n            val cy = cos(yaw * 0.5)\n            val sy = sin(yaw * 0.5)\n            val cr = cos(roll * 0.5)\n            val sr = sin(roll * 0.5)\n            val cp = cos(pitch * 0.5)\n            val sp = sin(pitch * 0.5)\n\n            return Quaternion(\n                    cy * sr * cp - sy * cr * sp,\n                    cy * cr * sp + sy * sr * cp,\n                    sy * cr * cp - cy * sr * sp,\n                    cy * cr * cp + sy * sr * sp)\n        }\n    }\n\n    val length: Double get() = sqrt(x * x + y * y + z * z + w * w)\n\n    operator fun times(q: Quaternion): Quaternion {\n        return Quaternion(\n                x * q.w + y * q.z - z * q.y + w * q.x,\n                -x * q.z + y * q.w + z * q.x + w * q.y,\n                x * q.y - y * q.x + z * q.w + w * q.z,\n                -x * q.x - y * q.y - z * q.z + w * q.w)\n    }\n\n    operator fun times(vec: Vector3): Vector3 {\n        val s = 2.0 / norm\n        val xs = x * s\n        val ys = y * s\n        val zs = z * s\n        val xxs = x * xs\n        val yys = y * ys\n        val zzs = z * zs\n        val xys = x * ys\n        val xzs = x * zs\n        val yzs = y * zs\n        val wxs = w * xs\n        val wys = w * ys\n        val wzs = w * zs\n\n        return Vector3((1 - (yys + zzs)) * vec.x + (xys - wzs) * vec.y + (xzs + wys) * vec.z,\n                (xys + wzs) * vec.x + (1 - (xxs + zzs)) * vec.y + (yzs - wxs) * vec.z,\n                (xzs - wys) * vec.x + (yzs + wxs) * vec.y + (1 - (xxs + yys)) * vec.z)\n    }\n\n    val negated: Quaternion\n        get() = Quaternion(-x, -y, -z, -w)\n\n    val inversed: Quaternion\n        get() {\n            val n = norm\n            if (n > 0.0) {\n                val invNorm = 1.0 / n\n                return Quaternion(-x * invNorm, -y * invNorm, -z * invNorm, w * invNorm)\n            } else {\n                error(\"norm <= 0 => quaternion is not invertible\")\n            }\n        }\n\n    val normalized: Quaternion\n        get() {\n            val l = length\n            return Quaternion(x / l, y / l, z / l, w / l)\n        }\n\n    val norm: Double get() = x * x + y * y + z * z + w * w\n\n    /**\n     * An orthonormal basis for the orientation described by the quaternion\n     */\n    val matrix: Matrix33\n        get() {\n            val norm = this.norm\n            // we explicitly test norm against one here, saving a division\n            // at the cost of a test and branch. Is it worth it?\n            val s = if (norm == 1.0) 2.0 else if (norm > 0.0) 2.0 / norm else 0.0\n\n            // compute xs/ys/zs first to save 6 multiplications, since xs/ys/zs\n            // will be used 2-4 times each.\n            val xs = x * s\n            val ys = y * s\n            val zs = z * s\n            val xx = x * xs\n            val xy = x * ys\n            val xz = x * zs\n            val xw = w * xs\n            val yy = y * ys\n            val yz = y * zs\n            val yw = w * ys\n            val zz = z * zs\n            val zw = w * zs\n\n            // using s=2/norm (instead of 1/norm) saves 9 multiplications by 2 here\n            return Matrix33(\n                    1 - (yy + zz), xy - zw, xz + yw,\n                    xy + zw, 1 - (xx + zz), yz - xw,\n                    xz - yw, yz + xw, 1 - (xx + yy))\n\n        }\n}\n\n@Suppress(\"unused\")\nfun dot(q1: Quaternion, q2: Quaternion): Double {\n    return q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q2.z * q2.z\n}\n\n@Suppress(\"unused\")\nfun slerp(q1: Quaternion, q2: Quaternion, x: Double): Quaternion {\n    if (q1.x == q2.x && q1.y == q2.y && q1.z == q2.z && q1.w == q2.w) {\n        return q1\n    }\n\n    var q2e = q2\n    var result = (q1.x * q2.x + q1.y * q2.y + q1.z * q2.z\n            + q1.w * q2.w)\n    if (result < 0.0) {\n        // Negate the second quaternion and the result of the dot product\n        q2e = q2.negated\n        result = -result\n    }\n\n    // Set the first and second scale for the interpolation\n    var scale0 = 1 - x\n    var scale1 = x\n    if (1 - result > 0.1) {\n        // Get the angle between the 2 quaternions, and then store the sin()\n        // of that angle\n        val theta = acos(result)\n        val invSinTheta = 1.0 / sin(theta)\n\n        // Calculate the scale for q1 and q2, according to the angle and its sine value\n        scale0 = sin((1 - x) * theta) * invSinTheta\n        scale1 = sin(x * theta) * invSinTheta\n    }\n\n    return Quaternion(\n            scale0 * q1.x + scale1 * q2e.x,\n            scale0 * q1.y + scale1 * q2e.y,\n            scale0 * q1.z + scale1 * q2e.z,\n            scale0 * q1.w + scale1 * q2e.w)\n}","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\nimport kotlin.math.acos\nimport kotlin.math.atan2\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The poles (phi) are at the positive and negative y-axis.\n * The equator starts at positive z.\n */\n\nprivate const val EPS = 0.000001\n\n@Serializable\ndata class Spherical(val theta: Double, val phi: Double, val radius: Double) : LinearType<Spherical> {\n\n    fun makeSafe() = Spherical(\n            theta,\n            clamp(phi, EPS, 180 - EPS),\n            radius\n    )\n\n    companion object {\n        fun fromVector(vector: Vector3): Spherical {\n            val r = vector.length\n            return Spherical(\n                    if (r == 0.0) 0.0 else atan2(vector.x, vector.z).asDegrees,\n                    if (r == 0.0) 0.0 else acos(clamp(vector.y / r, -1.0, 1.0)).asDegrees,\n                    r)\n        }\n    }\n\n    val cartesian: Vector3\n        get() {\n            return Vector3.fromSpherical(this)\n        }\n\n    override operator fun plus(right: Spherical) = Spherical(theta + right.theta, phi + right.phi, radius + right.radius)\n    override operator fun minus(right: Spherical) = Spherical(theta - right.theta, phi - right.phi, radius - right.radius)\n    operator fun times(scale: Spherical) = Spherical(theta * scale.theta, phi * scale.phi, radius * scale.radius)\n    override operator fun times(scale: Double) = Spherical(theta * scale, phi * scale, radius * scale)\n    override operator fun div(scale: Double) = Spherical(theta / scale, phi / scale, radius / scale)\n}\n","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\nimport kotlin.math.*\n\nenum class YPolarity {\n    CCW_POSITIVE_Y,\n    CW_NEGATIVE_Y\n}\n\n/** Double-precision 2D vector. */\n@Serializable\ndata class Vector2(val x: Double, val y: Double) : LinearType<Vector2>, EuclideanVector<Vector2> {\n\n    constructor(x: Double) : this(x, x)\n\n    /** The Euclidean length of the vector. */\n    override val length: Double\n        get() = sqrt(x * x + y * y)\n\n    /** The squared Euclidean length of the vector. */\n    override val squaredLength: Double\n        get() = x * x + y * y\n\n    override fun map(function: (Double) -> Double): Vector2 {\n        return Vector2(function(x), function(y))\n    }\n\n    /**\n     * Calculates a vector perpendicular to the current one.\n     *\n     * @param polarity The polarity of the new vector, default is [CW_NEGATIVE_Y][YPolarity.CW_NEGATIVE_Y].\n     */\n    fun perpendicular(polarity: YPolarity = YPolarity.CW_NEGATIVE_Y): Vector2 = when (polarity) {\n        YPolarity.CCW_POSITIVE_Y -> Vector2(-y, x)\n        YPolarity.CW_NEGATIVE_Y -> Vector2(y, -x)\n    }\n\n    override val zero:Vector2 get() = ZERO\n\n    /**\n     * Calculates a cross product between this [Vector2] and [right].\n     *\n     * Technically you cannot find the\n     * [cross product of two 2D vectors](https://stackoverflow.com/a/243984)\n     * but it is still possible with clever use of mathematics.\n     */\n    infix fun cross(right: Vector2) = x * right.y - y * right.x\n\n    /** Calculates a dot product between this [Vector2] and [right]. */\n    override infix fun dot(right: Vector2): Double = x * right.x + y * right.y\n\n    infix fun reflect(surfaceNormal: Vector2): Vector2 = this - surfaceNormal * (this dot surfaceNormal) * 2.0\n\n    /**\n     * Creates a new [Vector2] with the given rotation and origin.\n     *\n     * @param degrees The rotation in degrees.\n     * @param origin The point around which the vector is rotated, default is [Vector2.ZERO].\n     */\n    fun rotate(degrees: Double, origin: Vector2 = ZERO): Vector2 {\n        val p = this - origin\n        val a = degrees.asRadians\n\n        val w = Vector2(\n                p.x * cos(a) - p.y * sin(a),\n                p.y * cos(a) + p.x * sin(a)\n        )\n\n        return w + origin\n    }\n\n    val yx:Vector2 get() = Vector2(y, x)\n    val xx:Vector2 get() = Vector2(x, x)\n    val yy: Vector2 get() = Vector2(y, y)\n    val xy0 get() = Vector3(x, y, 0.0)\n    val xy1 get() = Vector3(x, y, 1.0)\n    val xy00 get() = Vector4(x, y, 0.0, 0.0)\n    val xy01 get() = Vector4(x, y, 0.0, 1.0)\n\n    /**\n     * Upcasts to [Vector3].\n     *\n     * @param x The x component value, default is [x].\n     * @param y The y component value, default is [y].\n     * @param z The z component value, default is `0.0`.\n     */\n    fun vector3(x: Double = this.x, y: Double = this.y, z: Double = 0.0): Vector3 {\n        return Vector3(x, y, z)\n    }\n\n    /**\n     * Upcasts to [Vector4].\n     *\n     * @param x The x component value, default is [x].\n     * @param y The y component value, default is [y].\n     * @param z The z component value, default is `0.0`.\n     * @param w The w component value, default is `0.0`.\n     */\n    fun vector4(x: Double = this.x, y: Double = this.y, z: Double = 0.0, w: Double = 0.0): Vector4 {\n        return Vector4(x, y, z, w)\n    }\n\n\n    operator fun get(i: Int): Double {\n        return when (i) {\n            0 -> x\n            1 -> y\n            else -> throw RuntimeException(\"unsupported index\")\n        }\n    }\n\n    operator fun unaryMinus() = Vector2(-x, -y)\n\n    override operator fun plus(right: Vector2) = Vector2(x + right.x, y + right.y)\n    operator fun plus(d: Double) = Vector2(x + d, y + d)\n\n    override operator fun minus(right: Vector2) = Vector2(x - right.x, y - right.y)\n    operator fun minus(d: Double) = Vector2(x - d, y - d)\n\n    override operator fun times(scale: Double) = Vector2(x * scale, y * scale)\n    operator fun times(v: Vector2) = Vector2(x * v.x, y * v.y)\n\n    override operator fun div(scale: Double) = Vector2(x / scale, y / scale)\n    operator fun div(d: Vector2) = Vector2(x / d.x, y / d.y)\n\n    /** Calculates the Euclidean distance to [other]. */\n    override fun distanceTo(other: Vector2): Double {\n        val dx = other.x - x\n        val dy = other.y - y\n        return sqrt(dx * dx + dy * dy)\n    }\n\n    /** Calculates the squared Euclidean distance to [other]. */\n    override fun squaredDistanceTo(other: Vector2): Double {\n        val dx = other.x - x\n        val dy = other.y - y\n        return dx * dx + dy * dy\n    }\n\n    override fun areaBetween(other: Vector2): Double {\n        // here we override the default implementation of areaBetween to make it faster without square root\n        return abs(x * other.y - y * other.x)\n    }\n\n    fun mix(o: Vector2, mix: Double): Vector2 = this * (1 - mix) + o * mix\n\n    companion object {\n        val ZERO = Vector2(0.0, 0.0)\n        val ONE = Vector2(1.0, 1.0)\n        val UNIT_X = Vector2(1.0, 0.0)\n        val UNIT_Y = Vector2(0.0, 1.0)\n\n        /** A [Vector2] representation for infinite values. */\n        val INFINITY = Vector2(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY)\n\n        fun fromPolar(polar: Polar): Vector2 {\n            val theta = polar.theta.asRadians\n            val x = cos(theta)\n            val y = sin(theta)\n            return Vector2(x, y) * polar.radius\n        }\n    }\n\n    /** Casts to [DoubleArray]. */\n    fun toDoubleArray() = doubleArrayOf(x, y)\n\n    /** Casts to [IntVector2]. */\n    fun toInt() = IntVector2(x.toInt(), y.toInt())\n}\n\noperator fun Double.times(v: Vector2) = v * this\n\nfun min(a: Vector2, b: Vector2): Vector2 = Vector2(min(a.x, b.x), min(a.y, b.y))\nfun max(a: Vector2, b: Vector2): Vector2 = Vector2(max(a.x, b.x), max(a.y, b.y))\n\nfun mix(a: Vector2, b: Vector2, mix: Double): Vector2 = a * (1 - mix) + b * mix\n\nfun Iterable<Vector2>.sum() : Vector2 {\n    var x = 0.0\n    var y = 0.0\n    for (v in this) {\n        x += v.x\n        y += v.y\n    }\n    return Vector2(x, y)\n}\n\nfun Iterable<Vector2>.average() : Vector2 {\n    var x = 0.0\n    var y = 0.0\n    var count = 0\n    for (v in this) {\n        x += v.x\n        y += v.y\n        count++\n    }\n    return Vector2(x / count, y / count)\n}","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\nimport kotlin.math.*\n\n/** Double-precision 3D vector. */\n@Serializable\ndata class Vector3(val x: Double, val y: Double, val z: Double) : LinearType<Vector3>, EuclideanVector<Vector3> {\n    constructor(x: Double) : this(x, x, x)\n\n    override val zero: Vector3 get() = ZERO\n\n    companion object {\n        val ZERO = Vector3(0.0, 0.0, 0.0)\n        val ONE = Vector3(1.0, 1.0, 1.0)\n        val UNIT_XYZ = ONE.normalized\n        val UNIT_X = Vector3(1.0, 0.0, 0.0)\n        val UNIT_Y = Vector3(0.0, 1.0, 0.0)\n        val UNIT_Z = Vector3(0.0, 0.0, 1.0)\n        val INFINITY = Vector3(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY)\n\n        fun fromSpherical(s: Spherical): Vector3 {\n\n            val phi = s.phi.asRadians\n            val theta = s.theta.asRadians\n\n            val sinPhiRadius = sin(phi) * s.radius\n            return Vector3(\n                sinPhiRadius * sin(theta),\n                cos(phi) * s.radius,\n                sinPhiRadius * cos(theta)\n            )\n        }\n    }\n\n    val xyz0 get() = Vector4(x, y, z, 0.0)\n    val xyz1 get() = Vector4(x, y, z, 1.0)\n\n    val xy: Vector2 get() = Vector2(x, y)\n    val yx: Vector2 get() = Vector2(y, x)\n    val zx: Vector2 get() = Vector2(z, x)\n\n    val xz: Vector2 get() = Vector2(x, z)\n\n    operator fun get(i: Int): Double {\n        return when (i) {\n            0 -> x\n            1 -> y\n            2 -> z\n            else -> throw RuntimeException(\"unsupported index\")\n        }\n    }\n\n    operator fun unaryMinus() = Vector3(-x, -y, -z)\n    override operator fun plus(right: Vector3) = Vector3(x + right.x, y + right.y, z + right.z)\n    operator fun plus(d: Double) = Vector3(x + d, y + d, z + d)\n    override operator fun minus(right: Vector3) = Vector3(x - right.x, y - right.y, z - right.z)\n    operator fun minus(d: Double) = Vector3(x - d, y - d, z - d)\n    operator fun times(v: Vector3) = Vector3(x * v.x, y * v.y, z * v.z)\n    override operator fun times(scale: Double) = Vector3(x * scale, y * scale, z * scale)\n    override operator fun div(scale: Double) = Vector3(x / scale, y / scale, z / scale)\n    operator fun div(v: Vector3) = Vector3(x / v.x, y / v.y, z / v.z)\n\n    /** Calculates a dot product between this [Vector2] and [right]. */\n    override infix fun dot(right: Vector3): Double = x * right.x + y * right.y + z * right.z\n\n    /** Calculates a cross product between this [Vector2] and [v]. */\n    infix fun cross(v: Vector3) = Vector3(\n        y * v.z - z * v.y,\n        -(x * v.z - z * v.x),\n        x * v.y - y * v.x\n    )\n\n\n    /** The Euclidean length of the vector. */\n    override val length: Double get() = sqrt(x * x + y * y + z * z)\n\n    /** The squared Euclidean length of the vector. */\n    override val squaredLength get() = x * x + y * y + z * z\n\n    override fun map(function: (Double) -> Double): Vector3 {\n        return Vector3(function(x), function(y), function(z))\n    }\n\n    /** Casts to [DoubleArray]. */\n    fun toDoubleArray() = doubleArrayOf(x, y, z)\n\n    override fun distanceTo(other: Vector3): Double {\n        val dx = other.x - x\n        val dy = other.y - y\n        val dz = other.z - z\n        return sqrt(dx * dx + dy * dy + dz * dz)\n    }\n\n    override fun squaredDistanceTo(other: Vector3): Double {\n        val dx = other.x - x\n        val dy = other.y - y\n        val dz = other.z - z\n        return dx * dx + dy * dy + dz * dz\n    }\n\n    fun mix(o: Vector3, mix: Double): Vector3 = this * (1 - mix) + o * mix\n\n    val spherical: Spherical\n        get() {\n            return Spherical.fromVector(this)\n        }\n\n    /** Casts to [IntVector3]. */\n    fun toInt() = IntVector3(x.toInt(), y.toInt(), z.toInt())\n}\n\noperator fun Double.times(v: Vector3) = v * this\n\nfun min(a: Vector3, b: Vector3) = Vector3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z))\nfun max(a: Vector3, b: Vector3) = Vector3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z))\n\nfun mix(a: Vector3, b: Vector3, mix: Double): Vector3 = a * (1 - mix) + b * mix\n\nfun Iterable<Vector3>.sum(): Vector3 {\n    var x = 0.0\n    var y = 0.0\n    var z = 0.0\n    for (v in this) {\n        x += v.x\n        y += v.y\n        z += v.z\n    }\n    return Vector3(x, y, z)\n}\n\nfun Iterable<Vector3>.average(): Vector3 {\n    var x = 0.0\n    var y = 0.0\n    var z = 0.0\n    var count = 0\n    for (v in this) {\n        x += v.x\n        y += v.y\n        z += v.z\n        count++\n    }\n    return Vector3(x / count, y / count, z / count)\n}","package org.openrndr.math\n\nimport kotlinx.serialization.Serializable\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.sqrt\n\n/** Double-precision 4D vector. */\n@Serializable\ndata class Vector4(val x: Double, val y: Double, val z: Double, val w: Double) : LinearType<Vector4>, EuclideanVector<Vector4> {\n    constructor(x: Double) : this(x, x, x, x)\n\n    val xy: Vector2 get() = Vector2(x, y)\n    val yx: Vector2 get() = Vector2(y, x)\n    val xz: Vector2 get() = Vector2(x, z)\n    val yz: Vector2 get() = Vector2(y, z)\n    val zx: Vector2 get() = Vector2(z, x)\n    val zy: Vector2 get() = Vector2(z, y)\n\n    /** Downcasts to [Vector3] by discarding [w]. */\n    val xyz: Vector3 get() = Vector3(x, y, z)\n\n    /** Calculates [Vector3] by dividing [x], [y], [z] by [w]. */\n    val div: Vector3 get() = Vector3(x / w, y / w, z / w)\n\n    /** The Euclidean length of the vector. */\n    override val length get() = sqrt(x * x + y * y + z * z + w * w)\n\n    /** The squared Euclidean length of the vector. */\n    override val squaredLength get() = x * x + y * y + z * z + w * w\n\n    override fun map(function: (Double) -> Double): Vector4 {\n        return Vector4(function(x), function(y), function(z), function(w))\n    }\n\n    override val zero: Vector4 get() = ZERO\n\n    companion object {\n        val UNIT_X = Vector4(1.0, 0.0, 0.0, 0.0)\n        val UNIT_Y = Vector4(0.0, 1.0, 0.0, 0.0)\n        val UNIT_Z = Vector4(0.0, 0.0, 1.0, 0.0)\n        val UNIT_W = Vector4(0.0, 0.0, 0.0, 1.0)\n        val ZERO = Vector4(0.0, 0.0, 0.0, 0.0)\n        val ONE = Vector4(1.0, 1.0, 1.0, 1.0)\n        val INFINITY = Vector4(\n            Double.POSITIVE_INFINITY,\n            Double.POSITIVE_INFINITY,\n            Double.POSITIVE_INFINITY,\n            Double.POSITIVE_INFINITY\n        )\n    }\n\n\n    operator fun unaryMinus() = Vector4(-x, -y, -z, -w)\n\n    override operator fun plus(right: Vector4) = Vector4(x + right.x, y + right.y, z + right.z, w + right.w)\n    operator fun plus(d: Double) = Vector4(x + d, y + d, z + d, w + d)\n    override operator fun minus(right: Vector4) = Vector4(x - right.x, y - right.y, z - right.z, w - right.w)\n    operator fun minus(d: Double) = Vector4(x - d, y - d, z - d, w - d)\n    operator fun times(v: Vector4) = Vector4(x * v.x, y * v.y, z * v.z, w * v.w)\n    override operator fun times(scale: Double) = Vector4(x * scale, y * scale, z * scale, w * scale)\n    operator fun div(v: Vector4) = Vector4(x / v.x, y / v.y, z / v.z, w / v.w)\n    override operator fun div(scale: Double) = Vector4(x / scale, y / scale, z / scale, w / scale)\n\n    /** Calculates a dot product between this [Vector4] and [right]. */\n    override infix fun dot(right: Vector4): Double = x * right.x + y * right.y + z * right.z + w * right.w\n\n    operator fun get(i: Int): Double {\n        return when (i) {\n            0 -> x\n            1 -> y\n            2 -> z\n            3 -> w\n            else -> throw IllegalArgumentException(\"unsupported index\")\n        }\n    }\n\n    /** Calculates the Euclidean distance to [other]. */\n    override fun distanceTo(other: Vector4): Double {\n        val dx = other.x - x\n        val dy = other.y - y\n        val dz = other.z - z\n        val dw = other.z - z\n        return sqrt(dx * dx + dy * dy + dz * dz + dw * dw)\n    }\n\n    /** Calculates the squared Euclidean distance to [other]. */\n    override fun squaredDistanceTo(other: Vector4): Double {\n        val dx = other.x - x\n        val dy = other.y - y\n        val dz = other.z - z\n        val dw = other.w - w\n        return dx * dx + dy * dy + dz * dz + dw * dw\n    }\n\n    fun mix(o: Vector4, mix: Double): Vector4 = this * (1 - mix) + o * mix\n\n    /** Casts to [DoubleArray]. */\n    fun toDoubleArray() = doubleArrayOf(x, y, z, w)\n\n    /** Casts to [IntVector4]. */\n    fun toInt() = IntVector4(x.toInt(), y.toInt(), z.toInt(), w.toInt())\n}\n\noperator fun Double.times(v: Vector4) = v * this\n\nfun min(a: Vector4, b: Vector4): Vector4 = Vector4(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w))\nfun max(a: Vector4, b: Vector4): Vector4 = Vector4(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w))\n\nfun mix(a: Vector4, b: Vector4, mix:Double): Vector4 = a * (1 - mix) + b * mix\n\ninterface CastableToVector4 {\n    fun toVector4() : Vector4\n}\n\nfun Iterable<Vector4>.sum() : Vector4 {\n    var x = 0.0\n    var y = 0.0\n    var z = 0.0\n    var w = 0.0\n    for (v in this) {\n        x += v.x\n        y += v.y\n        z += v.z\n        w += v.w\n    }\n    return Vector4(x, y, z, w)\n}\n\nfun Iterable<Vector4>.average() : Vector4 {\n    var x = 0.0\n    var y = 0.0\n    var z = 0.0\n    var w = 0.0\n    var count = 0\n    for (v in this) {\n        x += v.x\n        y += v.y\n        z += v.z\n        w += v.w\n        count++\n    }\n    return Vector4(x / count, y / count, z / count, w / count)\n}","package org.openrndr.math.transforms\n\nimport org.openrndr.math.Matrix44\nimport org.openrndr.math.Quaternion\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.Vector3\nimport kotlin.contracts.ExperimentalContracts\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\nimport kotlin.reflect.KMutableProperty0\n\nclass TransformBuilder(baseTransform: Matrix44 = Matrix44.IDENTITY) {\n    var transform: Matrix44 = baseTransform\n\n    fun rotate(degrees: Double) = rotate(Vector3.UNIT_Z, degrees)\n\n    fun rotate(axis: Quaternion) {\n        transform *= axis.matrix.matrix44\n    }\n\n    fun rotate(axis: Vector3 = Vector3.UNIT_Z, degrees: Double) {\n        transform *= Matrix44.rotate(axis, degrees)\n    }\n\n    fun translate(offset: Vector3) {\n        transform *= Matrix44.translate(offset)\n    }\n\n    fun translate(offset: Vector2) {\n        transform *= Matrix44.translate(offset.xy0)\n    }\n\n    fun translate(x: Double, y: Double, z: Double = 0.0) {\n        transform *= Matrix44.translate(Vector3(x, y, z))\n    }\n\n    fun scale(scale: Double) {\n        transform *= Matrix44.scale(scale, scale, scale)\n    }\n\n    fun scale(scaleX: Double, scaleY: Double, scaleZ: Double = 1.0) {\n        transform *= Matrix44.scale(scaleX, scaleY, scaleZ)\n    }\n\n    fun scale(scale: Vector3) {\n        transform *= Matrix44.scale(scale.x, scale.y, scale.z)\n    }\n\n    fun multiply(matrix: Matrix44) {\n        transform *= matrix\n    }\n}\n\n/**\n * Build a transform presented by a Matrix44\n * @param baseTransform the transform to start with, default is an identity matrix\n * @param builder a function that is invoke inside the [TransformBuilder] context\n */\n@OptIn(ExperimentalContracts::class)\nfun transform(baseTransform: Matrix44 = Matrix44.IDENTITY, builder: TransformBuilder.() -> Unit): Matrix44 {\n    contract {\n        callsInPlace(builder, InvocationKind.EXACTLY_ONCE)\n    }\n    return TransformBuilder(baseTransform).apply { builder() }.transform\n}\n\n/**\n * An alias for transform, useful for those cases in which the word transform is used too often\n */\nfun buildTransform(baseTransform: Matrix44 = Matrix44.IDENTITY, builder: TransformBuilder.() -> Unit) =\n    transform(baseTransform, builder)\n\n/**\n * Matrix44 transform helper\n */\n@OptIn(ExperimentalContracts::class)\n@JvmName(\"matrix44Transform\")\nfun Matrix44.transform(builder: TransformBuilder.() -> Unit): Matrix44 {\n    contract {\n        callsInPlace(builder, InvocationKind.EXACTLY_ONCE)\n    }\n    return buildTransform(baseTransform = this, builder = builder)\n}\n\n/**\n * Matrix44 property transform helper\n */\n@OptIn(ExperimentalContracts::class)\nfun KMutableProperty0<Matrix44>.transform(builder: TransformBuilder.() -> Unit) {\n    contract {\n        callsInPlace(builder, InvocationKind.EXACTLY_ONCE)\n    }\n    set(get().transform(builder))\n}\n\n","package org.openrndr.math.transforms\n\nimport org.openrndr.math.Matrix44\nimport org.openrndr.math.Vector3\nimport org.openrndr.math.Vector4\nimport org.openrndr.math.asRadians\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.math.tan\n\n/**\n *  Creates an perspective projection matrix\n *\n *  For more on projection matrices please visit http://learnwebgl.brown37.net/08_projections/projections_perspective.html\n *\n *  [fovY] Y field of view in degrees\n *  [aspectRatio] lens aspect ratio\n *  [zNear] The distance to the near clipping plane along the -Z axis.\n *  [zFar]The distance to the far clipping plane along the -Z axis.\n */\nfun perspective(fovY: Double, aspectRatio: Double, zNear: Double, zFar: Double): Matrix44 {\n\n    // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#finite-perspective-projection\n\n    val y = fovY.asRadians\n\n    return Matrix44(\n            1.0 / (aspectRatio * tan(0.5 * y)), 0.0, 0.0, 0.0,\n            0.0, 1.0 / tan(0.5 * y), 0.0, 0.0,\n            0.0, 0.0, (zFar + zNear) / (zNear - zFar), 2 * zFar * zNear / (zNear - zFar),\n            0.0, 0.0, -1.0, 0.0)\n}\n\n/**\n *  Creates an perspective projection matrix with infinite clipping depth\n *\n *  For more on projection matrices please visit http://learnwebgl.brown37.net/08_projections/projections_perspective.html\n *\n *  [fovY] Y field of view in degrees\n *  [aspectRatio] lens aspect ratio\n *  [zNear] The distance to the near clipping plane along the -Z axis.\n */\nfun perspective(fovY: Double, aspectRatio: Double, zNear: Double): Matrix44 {\n\n    // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#infinite-perspective-projection\n\n    val y = fovY.asRadians\n\n    return Matrix44(\n            1.0 / (aspectRatio * tan(0.5 * y)), 0.0, 0.0, 0.0,\n            0.0, 1.0 / tan(0.5 * y), 0.0, 0.0,\n            0.0, 0.0, -1.0, -2.0 * zNear,\n            0.0, 0.0, -1.0, 0.0)\n}\n\n/**\n *  Creates an perspective projection matrix with a shifted apex\n *\n *  For more on projection matrices please visit http://learnwebgl.brown37.net/08_projections/projections_perspective.html\n *\n *  [fovY] Y field of view in degrees\n *  [aspectRatio] lens aspect ratio\n *  [zNear] The distance to the near clipping plane along the -Z axis.\n *  [zFar]The distance to the far clipping plane along the -Z axis.\n */\nfun perspective(fovY: Double, aspectRatio: Double, zNear: Double, zFar: Double, xOffset: Double, yOffset: Double): Matrix44 {\n\n    val fW = tan(fovY.asRadians / 2) * zNear\n    val fH = fW * aspectRatio\n\n    return frustum(-fH + xOffset, fH + xOffset, -fW + yOffset, fW + yOffset, zNear, zFar)\n\n}\n\n/**\n *  Creates an perspective projection matrix locking the horizontal view angle\n *\n *  [fovY] Y field of view in degrees\n *  [aspectRatio] lens aspect ratio\n *  [zNear] The distance to the near clipping plane along the -Z axis.\n *  [zFar]The distance to the far clipping plane along the -Z axis.\n */\nfun perspectiveHorizontal(fovY: Double, aspectRatio: Double, zNear: Double, zFar: Double, xOffset: Double, yOffset: Double): Matrix44 {\n\n    val fW = tan(fovY.asRadians / 2) * zNear\n    val fH = fW / aspectRatio\n\n    return frustum(-fW + xOffset, fW + xOffset, -fH + yOffset, fH + yOffset, zNear, zFar)\n}\n\n/**\n * Creates frustum matrix with the given bounds\n *\n * [left] Left bound of the frustum\n * [right] Right bound of the frustum\n * [bottom] Bottom bound of the frustum\n * [top] Top bound of the frustum\n * [zNear] Near bound of the frustum\n * [zFar] Far bound of the frustum\n */\nfun frustum(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double): Matrix44 {\n    val rl = 1.0 / (right - left)\n    val tb = 1.0 / (top - bottom)\n\n    return Matrix44(\n            (zNear * 2) * rl, 0.0, 0.0, (right + left) * rl,\n            0.0, (zNear * 2) * tb, 0.0, (top + bottom) * tb,\n            0.0, 0.0, (zFar + zNear) / (zNear - zFar), (2 * zFar * zNear) / (zNear - zFar),\n            0.0, 0.0, -1.0, 0.0)\n}\n\n/**\n *  Creates an orthographic projection matrix\n *\n *  [xMag] The horizontal magnification of the view\n *  [yMag] The vertical magnification of the view\n *  [zNear] The distance to the near clipping plane\n *  [zFar] The distance to the far clipping plane\n */\nfun ortho(xMag: Double, yMag: Double, zNear: Double, zFar: Double): Matrix44 =\n\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#orthographic-projection\n\n        Matrix44(\n                1.0 / xMag, 0.0, 0.0, 0.0,\n                0.0, 1.0 / yMag, 0.0, 0.0,\n                0.0, 0.0, 2.0 / (zNear - zFar), (zFar + zNear) / (zNear - zFar),\n                0.0, 0.0, 0.0, 1.0)\n\n/**\n *  Creates an orthographic projection matrix with the given bounds\n *\n * [left] left plane of the clipping volume\n * [right] right plane of the clipping volume\n * [bottom] bottom plane of the clipping volume\n * [top] top plane of the clipping volume\n * [zNear] The distance to the near clipping plane\n * [zFar] The distance to the far clipping plane\n */\nfun ortho(left: Double, right: Double, bottom: Double, top: Double, zNear: Double, zFar: Double): Matrix44 {\n\n    val tx = -(right + left) / (right - left)\n    val ty = -(top + bottom) / (top - bottom)\n    val tz = -(zFar + zNear) / (zFar - zNear)\n\n    return Matrix44(\n            2.0 / (right - left), 0.0, 0.0, tx,\n            0.0, 2.0 / (top - bottom), 0.0, ty,\n            0.0, 0.0, -2.0 / (zFar - zNear), tz,\n            0.0, 0.0, 0.0, 1.0)\n}\n\n/**\n * Create a view matrix from a camera at position [eye] look at [target]\n *\n * [eye] the position of the camera\n * [target] the target the camera looks at\n * [up] direction of up, default direction is Vector3.UNIT_Y\n */\nfun lookAt(eye: Vector3, target: Vector3, up: Vector3 = Vector3.UNIT_Y): Matrix44 {\n\n    val f = target.minus(eye).normalized\n    var u = up.normalized\n    val s = f.cross(u).normalized\n\n    u = s.cross(f)\n\n    return Matrix44(\n            s.x, s.y, s.z, -s.dot(eye),\n            u.x, u.y, u.z, -u.dot(eye),\n            -f.x, -f.y, -f.z, f.dot(eye),\n            0.0, 0.0, 0.0, 1.0)\n}\n\n/**\n * Create a rotation matrix around the given axes\n *\n * [axis] the axis to rotate around\n * [angle] the angle in degrees\n */\nfun Matrix44.Companion.rotate(axis: Vector3, angle: Double): Matrix44 {\n\n    val r = angle.asRadians\n    val cosa = cos(r)\n    val sina = sin(r)\n    val _axis = axis.normalized\n\n    return Matrix44(\n\n            cosa + (1 - cosa) * _axis.x * _axis.x,\n            (1 - cosa) * _axis.x * _axis.y - _axis.z * sina,\n            (1 - cosa) * _axis.x * _axis.z + _axis.y * sina,\n            0.0,\n\n            (1 - cosa) * _axis.x * _axis.y + _axis.z * sina,\n            cosa + (1 - cosa) * _axis.y * _axis.y,\n            (1 - cosa) * _axis.y * _axis.z - _axis.x * sina,\n            0.0,\n\n            (1 - cosa) * _axis.x * _axis.z - _axis.y * sina,\n            (1 - cosa) * _axis.y * _axis.z + _axis.x * sina,\n            cosa + (1 - cosa) * _axis.z * _axis.z,\n            0.0,\n\n            0.0,\n            0.0,\n            0.0,\n            1.0)\n\n}\n\n/**\n * Create a rotation matrix around the X axes\n *\n * [angle] the angle in degrees\n */\nfun Matrix44.Companion.rotateX(angle: Double): Matrix44 {\n    val r = angle.asRadians\n\n    val cr = cos(r)\n    val sr = sin(r)\n    return Matrix44(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, cr, -sr, 0.0,\n            0.0, sr, cr, 0.0,\n            0.0, 0.0, 0.0, 1.0\n    )\n}\n\n/**\n * Create a rotation matrix around the Y axes\n *\n * [angle] the angle in degrees\n */\nfun Matrix44.Companion.rotateY(angle: Double): Matrix44 {\n    val r = angle.asRadians\n\n    val cr = cos(r)\n    val sr = sin(r)\n    return Matrix44(\n            cr, 0.0, sr, 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            -sr, 0.0, cr, 0.0,\n            0.0, 0.0, 0.0, 1.0)\n}\n\n/**\n * Create a rotation matrix around the Z axes\n *\n * [angle] the angle in degrees\n */\nfun Matrix44.Companion.rotateZ(angle: Double): Matrix44 {\n    val r = angle.asRadians\n    val cr = cos(r)\n    val sr = sin(r)\n    return Matrix44(\n            cr, -sr, 0.0, 0.0,\n            sr, cr, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0)\n}\n\n/**\n * Create a translate matrix with the given vector\n *\n * [scale] scale vector\n */\nfun Matrix44.Companion.translate(translation: Vector3): Matrix44 {\n    return translate(translation.x, translation.y, translation.z)\n}\n\n/**\n * Create a scaling matrix with the given components\n *\n * [x] translate direction\n * [y] translate direction\n * [z] translate direction\n */\nfun Matrix44.Companion.translate(x: Double, y: Double, z: Double): Matrix44 {\n    return Matrix44.fromColumnVectors(\n            Vector4.UNIT_X,\n            Vector4.UNIT_Y,\n            Vector4.UNIT_Z,\n            Vector4(x, y, z, 1.0))\n}\n\n/**\n * Create a scaling matrix with the given vector\n *\n * [scale] scale vector\n */\nfun Matrix44.Companion.scale(scaleFactor: Vector3): Matrix44 {\n    return scale(scaleFactor.x, scaleFactor.y, scaleFactor.z)\n}\n\n/**\n * Create a scaling matrix with the given components\n *\n * [x] direction scale factor\n * [y] direction scale factor\n * [z] direction scale factor\n */\nfun Matrix44.Companion.scale(x: Double, y: Double, z: Double): Matrix44 {\n    return Matrix44(\n            x, 0.0, 0.0, 0.0,\n            0.0, y, 0.0, 0.0,\n            0.0, 0.0, z, 0.0,\n            0.0, 0.0, 0.0, 1.0)\n}\n\n/**\n * Project a 3D point on a 2D surface\n *\n * [point] the point to project\n * [projection] the projection matrix\n * [view] the view matrix\n * [width] the width of the projection surface\n * [height] the height of the projection surface\n */\nfun project(point: Vector3, projection: Matrix44, view: Matrix44, width: Int, height: Int): Vector3 {\n\n    val homo = Vector4(point.x, point.y, point.z, 1.0)\n    val projectedHomo = (projection * view) * homo\n\n    // Homogeneous division\n    val rhw = 1 / projectedHomo.w\n\n    return Vector3(\n            (projectedHomo.x * rhw + 1) * width / 2,\n            (1 - projectedHomo.y * rhw) * height / 2,\n            rhw)\n}\n\n\nfun unproject(point: Vector3, projection: Matrix44, view: Matrix44, width: Int, height: Int): Vector3 {\n    val ipm = (projection * view).inversed\n    val v = Vector3(2 * point.x / width - 1, 2 * point.y / height - 1, 2 * point.z - 1)\n    return (ipm * v.xyz1).xyz\n}\n\n/**\n * Construct a normal matrix from the give view matrix\n */\nfun normalMatrix(view: Matrix44): Matrix44 {\n\n    val subView = Matrix44(\n            view.c0r0, view.c1r0, view.c2r0, 0.0,\n            view.c0r1, view.c1r1, view.c2r1, 0.0,\n            view.c0r2, view.c1r2, view.c2r2, 0.0,\n            0.0, 0.0, 0.0, 1.0)\n\n    return subView.inversed.transposed.copy(c3r3 = 0.0)\n}\n\n","package org.openrndr.math\n\nimport kotlin.math.sqrt\n\n\n/* quadratic bezier */\nfun bezier(x0: Double, c0: Double, x1: Double, t: Double): Double {\n    val it = 1.0 - t\n    val it2 = it * it\n    val t2 = t * t\n    return it2 * x0 + 2.0 * it * t * c0 + t2 * x1\n}\n\nfun derivative(x0: Double, c0: Double, x1: Double, t: Double): Double {\n    val it = 1.0 - t\n    return 2.0 * it * (c0 - x0) + 2.0 * t * (x1 - c0)\n}\n\nfun derivative(x0: Vector2, c0: Vector2, x1: Vector2, t: Double): Vector2 {\n    val it = 1.0 - t\n    return Vector2(2 * it * (c0.x - x0.x) + 2 * t * (x1.x - c0.x), 2 * it * (c0.y - x0.y) + 2 * t * (x1.y - c0.y))\n}\n\n/**\n * Similar to [derivative] but handles cases in which [p0] and [p1] coincide.\n */\nfun safeDerivative(p0: Vector2, c0: Vector2, p1: Vector2, t: Double): Vector2 {\n    val epsilon = 10E-6\n    var u = t\n\n    val d10 = c0 - p0\n    val d21 = c0 - p1\n\n    if (u < epsilon && d10.squaredLength < epsilon) {\n        u = epsilon\n    }\n\n    if (u > (1.0 - epsilon) && d21.squaredLength < epsilon) {\n        u = 1.0 - epsilon\n    }\n\n    val iu = 1.0 - u\n    return Vector2(2 * iu * (c0.x - p0.x) + 2 * u * (p1.x - c0.x), 2 * iu * (c0.y - p0.y) + 2 * u * (p1.y - c0.y))\n}\n\nfun derivative(x0: Vector3, c0: Vector3, x1: Vector3, t: Double): Vector3 {\n    val it = 1.0 - t\n    return Vector3(2 * it * (c0.x - x0.x) + 2 * t * (x1.x - c0.x),\n            2 * it * (c0.y - x0.y) + 2 * t * (x1.y - c0.y),\n            2 * it * (c0.z - x0.z) + 2 * t * (x1.z - c0.z)\n    )\n}\n\n\nfun roots(p: List<Double>): List<Double> {\n    //https://github.com/Pomax/bezierjs/blob/gh-pages/lib/utils.js\n    if (p.size == 3) {\n        val a = p[0]\n        val b = p[1]\n        val c = p[2]\n        val d = a - 2 * b + c\n        if (d != 0.0) {\n            val m1 = -sqrt(b * b - a * c)\n            val m2 = -a + b\n            val v1 = -(m1 + m2) / d\n            val v2 = -(-m1 + m2) / d\n            return listOf(v1, v2)\n        } else if (b != c && d == 0.0) {\n            return listOf((2 * b * c) / (2 * (b - c)))\n        }\n        return emptyList()\n    } else if (p.size == 2) {\n        val a = p[0]\n        val b = p[1]\n        return if (a != b) {\n            listOf(a / (a - b))\n        } else {\n            emptyList()\n        }\n    }\n    return emptyList()\n\n}\n\nfun derivative(p0: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, t: Double): Vector3 {\n    val it = 1.0 - t\n    return p1.minus(p0).times(3.0 * it * it).plus(p2.minus(p1).times(6.0 * it * t)).plus(p3.minus(p2).times(3.0 * t * t))\n}\n\n\nfun derivative(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2, t: Double): Vector2 {\n    val it = 1.0 - t\n    return p1.minus(p0).times(3.0 * it * it).plus(p2.minus(p1).times(6.0 * it * t)).plus(p3.minus(p2).times(3.0 * t * t))\n}\n\n/**\n * Similar to [derivative] but handles cases in which [p0] and [p1] or [p2] and [p3] coincide.\n */\nfun safeDerivative(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2, t: Double): Vector2 {\n    val epsilon = 10E-6\n    var u = t\n\n    val d10 = p1 - p0\n    val d32 = p3 - p2\n\n    if (u < epsilon && d10.squaredLength < epsilon) {\n        u = epsilon\n    }\n\n    if (u > (1.0 - epsilon) && d32.squaredLength < epsilon) {\n        u = 1.0 - epsilon\n    }\n\n    val iu = 1.0 - u\n    return ((d10 * (3.0 * iu * iu)) + (p2 - p1) * (6.0 * iu * u)) + d32 * (3.0 * u * u)\n}\n\nfun normal(x0: Vector2, c0: Vector2, x1: Vector2, t: Double): Vector2 {\n    val (x, y) = derivative(x0, c0, x1, t)\n    return Vector2(-y, x).normalized\n}\n\nfun bezier(x0: Vector2, c0: Vector2, x1: Vector2, t: Double): Vector2 {\n    val it = 1.0 - t\n    val it2 = it * it\n    val t2 = t * t\n\n    return Vector2(\n            it2 * x0.x + 2 * it * t * c0.x + t2 * x1.x,\n            it2 * x0.y + 2 * it * t * c0.y + t2 * x1.y\n    )\n}\n\nfun bezier(x0: Vector3, c0: Vector3, x1: Vector3, t: Double): Vector3 {\n    val it = 1.0 - t\n    val it2 = it * it\n    val t2 = t * t\n\n    return Vector3(\n            it2 * x0.x + 2 * it * t * c0.x + t2 * x1.x,\n            it2 * x0.y + 2 * it * t * c0.y + t2 * x1.y,\n            it2 * x0.z + 2 * it * t * c0.z + t2 * x1.z)\n}\n\n/* cubic bezier */\nfun bezier(x0: Double, c0: Double, c1: Double, x1: Double, t: Double): Double {\n    val it = 1.0 - t\n    val it2 = it * it\n    val it3 = it2 * it\n    val t2 = t * t\n    val t3 = t2 * t\n\n    return it3 * x0 + 3.0 * it2 * t * c0 + 3.0 * it * t2 * c1 + t3 * x1\n}\n\nfun bezier(x0: Vector2, c0: Vector2, c1: Vector2, x1: Vector2, t: Double): Vector2 {\n    val it = 1.0 - t\n    val it2 = it * it\n    val it3 = it2 * it\n    val t2 = t * t\n    val t3 = t2 * t\n\n    return Vector2(\n            it3 * x0.x + 3 * it2 * t * c0.x + 3 * it * t2 * c1.x + t3 * x1.x,\n            it3 * x0.y + 3 * it2 * t * c0.y + 3 * it * t2 * c1.y + t3 * x1.y)\n}\n\n/**\n * Samples a single point based on the provided\n * [t](https://pomax.github.io/bezierinfo/#explanation) value\n * from given 3D cubic Bézier curve.\n *\n * @param x0 The starting anchor point of the curve.\n * @param c0 The first control point.\n * @param c1 The second control point.\n * @param x1 The ending anchor point of the curve.\n * @param t The value of *t* in the range of `0.0` to `1.0`.\n * @return A sample on the curve.\n */\nfun bezier(x0: Vector3, c0: Vector3, c1: Vector3, x1: Vector3, t: Double): Vector3 {\n    val it = 1.0 - t\n    val it2 = it * it\n    val it3 = it2 * it\n    val t2 = t * t\n    val t3 = t2 * t\n\n    return Vector3(\n            it3 * x0.x + 3 * it2 * t * c0.x + 3 * it * t2 * c1.x + t3 * x1.x,\n            it3 * x0.y + 3 * it2 * t * c0.y + 3 * it * t2 * c1.y + t3 * x1.y,\n            it3 * x0.z + 3 * it2 * t * c0.z + 3 * it * t2 * c1.z + t3 * x1.z)\n}\n\n// linear type bezier\n\n/* quadratic bezier */\nfun <T: LinearType<T>> bezier(x0: T, c0: T, x1: T, t: Double): T {\n    val it = 1.0 - t\n    val it2 = it * it\n    val t2 = t * t\n    return x0 * it2 + c0 * (2.0 * it * t) + x1 * t2\n}\n\nfun <T : LinearType<T>> bezier(x0: T, c0: T, c1: T, x1: T, t: Double): T {\n    val it = 1.0 - t\n    val it2 = it * it\n    val it3 = it2 * it\n    val t2 = t * t\n    val t3 = t2 * t\n    return x0 * (it3) + c0 * (3 * it2 * t) + c1 * (3 * it * t2) + x1 * (t3)\n}\n","package org.openrndr.platform\n\nenum class PlatformType {\n    GENERIC,\n    WINDOWS,\n    MAC,\n    BROWSER\n}\n\nenum class PlatformArchitecture {\n    X86_64,\n    AARCH64,\n    UNKNOWN\n}\n\nexpect object Platform {\n    val type: PlatformType\n    val architecture: PlatformArchitecture\n    fun property(key: String): String?\n}","package org.openrndr.platform\n\nactual object Platform {\n    actual val type: PlatformType\n        get() = PlatformType.BROWSER\n\n    actual val architecture: PlatformArchitecture\n        get() = PlatformArchitecture.UNKNOWN\n\n    actual fun property(key: String): String? {\n        return null\n    }\n}","package org.openrndr.shape\n\nimport org.openrndr.math.*\n\nsealed interface Movable {\n    /** Creates a new shape with the same size but the current position [offset] by the given amount. */\n    fun movedBy(offset: Vector2): Movable\n\n    /** Creates a new shape with the same size but the current position is set to [position]. */\n    fun movedTo(position: Vector2): Movable\n}\n\nsealed interface Scalable1D {\n    /** Current scale of this shape. Generally equivalent to its dimensions. */\n    val scale: Vector2\n\n    /**\n     * Returns a position in the bounding box for parameterized\n     * values [u] and [v] between `0.0` and `1.0` where\n     * (`0.5`, `0.5`) is the center of the bounding box.\n     */\n    fun position(u: Double, v: Double): Vector2\n\n    /**\n     * Returns a position in the bounding box for a parameterized\n     * [uv] value between (`0.0`, `0.0`) and (`1.0`, `1.0`) where\n     * (`0.5`, `0.5`) is the center of the bounding box.\n     */\n    fun position(uv: Vector2) = position(uv.x, uv.y)\n\n    /**\n     * Creates a new shape with dimensions scaled by [scale].\n     *\n     * @param scale the scale factor\n     * @param uAnchor x coordinate of the scaling anchor in u parameter space, default is 0.5 (center)\n     * @param vAnchor y coordinate of the scaling anchor in v parameter space, default is 0.5 (center)\n     */\n    fun scaledBy(scale: Double, uAnchor: Double = 0.5, vAnchor: Double = 0.5): Scalable1D\n\n    /** Creates a new shape at the same position with the given dimension, scaled uniformly. */\n    fun scaledTo(size: Double): Scalable1D\n}\n\nsealed interface Scalable2D : Scalable1D {\n    /**\n     * Creates a new shape with dimensions scaled by [xScale] and [yScale].\n     *\n     * @param xScale the x scale factor\n     * @param yScale the y scale factor\n     * @param uAnchor x coordinate of the scaling anchor in u parameter space, default is 0.5 (center)\n     * @param vAnchor y coordinate of the scaling anchor in v parameter space, default is 0.5 (center)\n     */\n    fun scaledBy(xScale: Double, yScale: Double, uAnchor: Double = 0.5, vAnchor: Double = 0.5): Scalable2D\n\n    /** Creates a new shape at the same position with the given dimensions. */\n    fun scaledTo(width: Double, height: Double): Scalable2D\n}","package org.openrndr.shape\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Polar\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.asDegrees\nimport kotlin.math.acos\nimport kotlin.math.sqrt\nimport kotlin.math.abs\nimport kotlin.math.PI\n\n/**\n * Creates a [Circle].\n *\n * Alternatively, see [Ellipse].\n */\n@Serializable\ndata class Circle(val center: Vector2, val radius: Double): Movable, Scalable1D, ShapeProvider, ShapeContourProvider {\n\n    companion object {\n        val INVALID = Circle(Vector2.INFINITY, 0.0)\n\n        /**\n         * Creates a [Circle] passing through two points.\n         *\n         * The diameter of the circle equals the distance between the points.\n         */\n        fun fromPoints(a: Vector2, b: Vector2): Circle {\n            val center = (a + b) * 0.5\n            return Circle(center, b.minus(center).length)\n        }\n\n        /**\n         * Constructs a [Circle] where the perimeter passes through the three points.\n         */\n        fun fromPoints(a: Vector2, b: Vector2, c: Vector2): Circle {\n            val det = (a.x - b.x) * (b.y - c.y) - (b.x - c.x) * (a.y - b.y)\n\n            if (abs(det) < 1E-7) {\n                return INVALID\n            }\n\n            val offset = b.x * b.x + b.y * b.y\n            val bc = (a.x * a.x + a.y * a.y - offset) / 2\n            val cd = (offset - c.x * c.x - c.y * c.y) / 2\n            val x = (bc * (b.y - c.y) - cd * (a.y - b.y)) / det\n            val y = (cd * (a.x - b.x) - bc * (b.x - c.x)) / det\n            val radius = sqrt(\n                (b.x - x) * (b.x - x) + (b.y - y) * (b.y - y)\n            )\n\n            return Circle(x, y, radius)\n        }\n    }\n\n    /** The top-left corner of the [Circle]. */\n    val corner: Vector2\n        get() = center - scale\n\n    override val scale: Vector2\n        get() = Vector2(radius)\n\n    /** Creates a new [Circle] with the current [center] offset by [offset]. */\n    @Deprecated(\"Vague naming\", ReplaceWith(\"movedBy(offset)\"))\n    fun moved(offset: Vector2): Circle = Circle(center + offset, radius)\n\n    override fun movedBy(offset: Vector2): Circle = Circle(center + offset, radius)\n\n    /** Creates a new [Circle] with center at [center]. */\n    @Suppress(\"PARAMETER_NAME_CHANGED_ON_OVERRIDE\")\n    override fun movedTo(center: Vector2) = Circle(center, radius)\n\n    /** Creates a new [Circle] with the [scale] specified as a multiplier for the current radius. */\n    @Deprecated(\"Vague naming\", ReplaceWith(\"scaledBy(scale)\"))\n    fun scaled(scale: Double): Circle = Circle(center, radius * scale)\n\n    override fun scaledBy(scale: Double, uAnchor: Double, vAnchor: Double): Circle {\n        val anchorPosition = position(uAnchor, vAnchor)\n        return Circle(anchorPosition, radius * scale)\n    }\n\n    /** Creates a new [Circle] at the same position with the given [radius]. */\n    @Suppress(\"PARAMETER_NAME_CHANGED_ON_OVERRIDE\")\n    override fun scaledTo(radius: Double) = Circle(center, radius)\n\n    override fun position(u: Double, v: Double): Vector2 {\n        return corner + Vector2(u * 2 * radius, v * 2 * radius)\n    }\n\n    /** Returns true if given [point] lies inside the [Shape]. */\n    operator fun contains(point: Vector2): Boolean = point.minus(center).squaredLength < radius * radius\n\n    val area: Double\n        get() = radius * radius * PI\n\n    /** Returns [Shape] representation of the [Circle]. */\n    override val shape get() = Shape(listOf(contour))\n\n    /** Returns [ShapeContour] representation of the [Circle]. */\n    override val contour: ShapeContour\n        get() {\n            if(this == INVALID) {\n                return ShapeContour.EMPTY\n            }\n            val x = center.x - radius\n            val y = center.y - radius\n            val width = radius * 2.0\n            val height = radius * 2.0\n            val kappa = 0.5522848\n            val ox = width / 2 * kappa        // control point offset horizontal\n            val oy = height / 2 * kappa        // control point offset vertical\n            val xe = x + width        // x-end\n            val ye = y + height        // y-end\n            val xm = x + width / 2        // x-middle\n            val ym = y + height / 2       // y-middle\n\n            return contour {\n                moveTo(Vector2(x, ym))\n                curveTo(Vector2(x, ym - oy), Vector2(xm - ox, y), Vector2(xm, y))\n                curveTo(Vector2(xm + ox, y), Vector2(xe, ym - oy), Vector2(xe, ym))\n                curveTo(Vector2(xe, ym + oy), Vector2(xm + ox, ye), Vector2(xm, ye))\n                curveTo(Vector2(xm - ox, ye), Vector2(x, ym + oy), Vector2(x, ym))\n                close()\n            }\n        }\n\n    /**\n     * Calculates the tangent lines between two [Circle]s.\n     *\n     * Defaults to returning the outer tangents.\n     *\n     * @param isInner If true, returns the inner tangents instead.\n     */\n    fun tangents(other: Circle, isInner: Boolean = false): List<Pair<Vector2, Vector2>> {\n        if (this == INVALID || other == INVALID) {\n            return listOf()\n        }\n\n        val distSq = center.squaredDistanceTo(other.center)\n\n        if (isInner) {\n            if (sqrt(distSq) <= radius + other.radius) {\n                return listOf() // circles too close\n            }\n        } else {\n            val rDiff = radius - other.radius\n            if (distSq <= rDiff * rDiff) {\n                return listOf() // nested circles\n            }\n        }\n\n        val otherRadiusSigned = if (isInner) -other.radius else other.radius\n        val hyp = other.center - center // hypotenuse\n        val adj = radius - otherRadiusSigned // adjacent\n        val a = hyp * adj\n        val b = hyp.perpendicular() * sqrt(distSq - adj * adj)\n        val v1 = (a - b) / distSq\n        val v2 = (a + b) / distSq\n\n        return listOf(\n            Pair(center + v1 * radius, other.center + v1 * otherRadiusSigned),\n            Pair(center + v2 * radius, other.center + v2 * otherRadiusSigned)\n        )\n    }\n\n    /** Calculates the tangent lines through an external point. **/\n    fun tangents(point: Vector2): Pair<Vector2, Vector2> {\n        if(this == INVALID) {\n            return Pair(Vector2.INFINITY, Vector2.INFINITY)\n        }\n        val v = Polar.fromVector(point - center)\n        val b = v.radius\n        val theta = (acos(radius / b)).asDegrees\n        val d1 = v.theta + theta\n        val d2 = v.theta - theta\n\n        val tp = center + Polar(d1, radius).cartesian\n        val tp2 = center + Polar(d2, radius).cartesian\n\n        return Pair(tp, tp2)\n    }\n\n    operator fun times(scale: Double) = Circle(center * scale, radius * scale)\n\n    operator fun div(scale: Double) = Circle(center / scale, radius / scale)\n\n    operator fun plus(right: Circle) =\n        Circle(center + right.center, radius + right.radius)\n\n    operator fun minus(right: Circle) =\n        Circle(center - right.center, radius - right.radius)\n\n}\n\nfun Circle(x: Double, y: Double, radius: Double) =  Circle(Vector2(x, y), radius)\n","package org.openrndr.shape\n\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.Transient\nimport org.openrndr.math.IntVector2\n\n/**\n * Creates a new [IntRectangle].\n *\n * Uses [IntVector2]s which require whole numbers (integers) for position and dimensions.\n *\n * Also see [Rectangle].\n */\n@Suppress(\"MemberVisibilityCanBePrivate\", \"unused\")\n@Serializable\ndata class IntRectangle(val corner: IntVector2, val width: Int, val height: Int) {\n    val x get() = corner.x\n\n    val y get() = corner.y\n\n    val center get() = corner + IntVector2(width / 2, height / 2)\n\n    /** The unitless area covered by this [IntRectangle]. */\n    val area get() = width * height\n\n    /** The dimensions of the [IntRectangle]. */\n    val dimensions get() = IntVector2(width, height)\n\n    /** Casts [IntRectangle] to [Rectangle]. */\n    val rectangle get() = Rectangle(corner.vector2, width.toDouble(), height.toDouble())\n}\n\nfun IntRectangle(x: Int, y: Int, width: Int, height: Int) = IntRectangle(IntVector2(x, y), width, height)\n","@file:Suppress(\"unused\")\n\npackage org.openrndr.shape\n\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.Transient\nimport org.openrndr.math.LinearType\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.YPolarity\nimport org.openrndr.math.map\nimport kotlin.jvm.JvmOverloads\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.sign\n\n/**\n * A strictly linear 2D segment.\n *\n * Think of [LineSegment] as a more limited representation of the [Segment], .\n * While both [LineSegment] and [Segment] are capable of describing straight lines, [LineSegment] is only capable of dealing with straight lines\n * you'd generally only use [LineSegment] if you strictly\n * want to work with problems in the linear segment domain.\n *\n * [LineSegment]s are easy to extend in length\n * thanks to their simple two-point construction.\n *\n * @param start Start of the line segment.\n * @param end End of the line segment.\n */\n@Suppress(\"MemberVisibilityCanBePrivate\", \"unused\")\n@Serializable\ndata class LineSegment(val start: Vector2, val end: Vector2) : LinearType<LineSegment>,\n    ShapeProvider,\n    ShapeContourProvider {\n\n\n    /** Direction of the line segment */\n    val direction get() = (end - start)\n\n\n    /** The normal of the line segment, a unit vector. */\n    val normal get() = (end - start).normalized.perpendicular(YPolarity.CW_NEGATIVE_Y)\n\n    /**\n     * Finds point on the [LineSegment] that is nearest to the given point.\n     * @param query The query point.\n     */\n    fun nearest(query: Vector2): Vector2 {\n        val l2 = end.minus(start).squaredLength\n        if (l2 == 0.0) return start\n\n        var t = ((query.x - start.x) * (end.x - start.x) + (query.y - start.y) * (end.y - start.y)) / l2\n        t = max(0.0, min(1.0, t))\n        return Vector2(\n            start.x + t * (end.x - start.x),\n            start.y + t * (end.y - start.y)\n        )\n    }\n\n    /**\n     * Finds the shortest distance to the [LineSegment] from given point.\n     * @param query The query point.\n     */\n    fun distance(query: Vector2): Double = nearest(query).distanceTo(query)\n\n    /**\n     * Samples a new [LineSegment] from the current [LineSegment] starting at [t0] and ending at [t1].\n     *\n     * @param t0 The [t](https://pomax.github.io/bezierinfo/#explanation) value marking the start of the subsegment, in the range of `0.0` to `1.0`.\n     * @param t1 The *t* value marking the end of the subsegment, in the range of `0.0` to `1.0`.\n     */\n    fun sub(t0: Double, t1: Double): LineSegment {\n        var z0 = t0\n        var z1 = t1\n\n        if (t0 > t1) {\n            z1 = t0\n            z0 = t1\n        }\n        return when {\n            z0 == 0.0 -> split(z1)[0]\n            z1 == 1.0 -> split(z0)[1]\n            else -> split(z0)[1].split(map(z0, 1.0, 0.0, 1.0, z1))[0]\n        }\n    }\n\n    /**\n     * Splits line segment at given [t](https://pomax.github.io/bezierinfo/#explanation) value.\n     * @param t The *t* value in the range of `0.0` to `1.0`.\n     */\n    fun split(t: Double): Array<LineSegment> {\n        val u = t.coerceIn(0.0, 1.0)\n        val cut = start + (end.minus(start) * u)\n        return arrayOf(LineSegment(start, cut), LineSegment(cut, end))\n    }\n\n    /**\n     * Calculates [Vector2] position at given [t](https://pomax.github.io/bezierinfo/#explanation) value.\n     * @param t The *t* value in the range of `0.0` to `1.0`.\n     */\n    fun position(t: Double) = start + (end.minus(start) * t)\n\n    /**\n     * Rotates the [LineSegment] around a point on the segment.\n     * @param degrees The rotation in degrees.\n     * @param t The [t](https://pomax.github.io/bezierinfo/#explanation) value\n     *      of the point on the segment to rotate around, default is `0.5` (mid-point).\n     */\n    @JvmOverloads\n    @Deprecated(\"t value is not according to convention\", replaceWith = ReplaceWith(\"rotateBy\"))\n    fun rotate(degrees: Double, t: Double = 0.5): LineSegment {\n        val anchorPoint = end.mix(start, t.coerceIn(0.0, 1.0))\n\n        return LineSegment(\n            start.rotate(degrees, anchorPoint),\n            end.rotate(degrees, anchorPoint)\n        )\n    }\n\n    /**\n     * Rotates the [LineSegment] around a point on the segment.\n     * @param degrees The rotation in degrees.\n     * @param t The [t](https://pomax.github.io/bezierinfo/#explanation) value\n     *      of the point on the segment to rotate around, default is `0.5` (mid-point).\n     */\n    fun rotateBy(degrees: Double, t: Double = 0.5): LineSegment {\n        val anchorPoint = start.mix(end, t.coerceIn(0.0, 1.0))\n\n        return LineSegment(\n            start.rotate(degrees, anchorPoint),\n            end.rotate(degrees, anchorPoint)\n        )\n    }\n\n    /** Extends the length of the segment by given multiplier. */\n    @Deprecated(\"extends by twice the amount\", replaceWith = ReplaceWith(\"extendBy\"))\n    fun extend(times: Double): LineSegment {\n        return LineSegment(start - direction * times, end + direction * times)\n    }\n\n    /** Extends the length of the segment by the given [length].\n     * @since openrndr 0.4.4\n     * */\n    fun extendBy(length: Double, anchorT: Double = 0.5): LineSegment {\n        val tangent = direction.normalized\n        return LineSegment(start - tangent * length * (1.0-anchorT), end + tangent * length * anchorT)\n    }\n\n    /** Extends the length of the segment to the given [targetLength].\n     * @since openrndr 0.4.4\n     * */\n    fun extendTo(targetLength: Double, anchorT: Double = 0.5): LineSegment {\n        return extendBy(targetLength - length, anchorT)\n    }\n    /**\n     * Calculates the point at a given distance along this [LineSegment].\n     * @param length the distance along the [LineSegment].\n     */\n    fun pointAtLength(length: Double): Vector2 {\n        return when {\n            length <= 0.0 -> start\n            length >= this.length -> end\n            else -> start + direction / this.length * length\n        }\n    }\n\n    val length: Double\n        get() = start.distanceTo(end)\n\n    val squaredLength: Double\n        get() = start.squaredDistanceTo(end)\n\n    /** Returns [Segment] representation of the [LineSegment]. */\n    val segment: Segment\n        get() = Segment(start, end)\n\n    /** Returns [ShapeContour] representation of the [LineSegment]. */\n    override val contour: ShapeContour\n        get() = ShapeContour.fromPoints(listOf(start, end), false, YPolarity.CW_NEGATIVE_Y)\n\n    /** Returns [Shape] representation of the [LineSegment]. */\n    override val shape: Shape\n        get() = Shape(listOf(contour))\n\n    override operator fun times(scale: Double): LineSegment {\n        return LineSegment(start * scale, end * scale)\n    }\n\n    override operator fun div(scale: Double): LineSegment {\n        return LineSegment(start / scale, end / scale)\n    }\n\n    override operator fun plus(right: LineSegment): LineSegment {\n        return LineSegment(start + right.start, end + right.end)\n    }\n\n    override operator fun minus(right: LineSegment): LineSegment {\n        return LineSegment(start - right.start, end - right.end)\n    }\n\n    fun side(v: Vector2): Double {\n        return sign((end.x - start.x) * (v.y - start.y) - (end.y - start.y) * (v.x - start.x))\n    }\n}\n\n/**\n * Finds the intersection point between two [LineSegment]s.\n *\n * Returns [Vector2.INFINITY] if none exists.\n *\n * @param a The first line segment.\n * @param b The second line segment.\n * @param eps How far outside the [t](https://pomax.github.io/bezierinfo/#explanation) value are intersections considered.\n */\n@JvmOverloads\nfun intersection(a: LineSegment, b: LineSegment, eps: Double = 0.0): Vector2 =\n    intersection(a.start, a.end, b.start, b.end, eps)\n\n/**\n * Finds the intersection point between two [LineSegment]s.\n *\n * Returns [Vector2.INFINITY] if none exists.\n *\n * @param a0 The start of the first line segment.\n * @param a1 The end of the first line segment.\n * @param b0 The start of the second line segment.\n * @param b1 The end of the second line segment.\n * @param eps How far outside the [t](https://pomax.github.io/bezierinfo/#explanation) value are intersections considered.\n */\n@JvmOverloads\nfun intersection(a0: Vector2, a1: Vector2, b0: Vector2, b1: Vector2, eps: Double = 0.0): Vector2 {\n    val x0 = a0.x\n    val x1 = a1.x\n    val x2 = b0.x\n    val x3 = b1.x\n\n    val y0 = a0.y\n    val y1 = a1.y\n    val y2 = b0.y\n    val y3 = b1.y\n\n    val den = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3)\n\n    return if (abs(den) > 10E-6) {\n        val px = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / den\n        val py = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / den\n\n        val s = (-(y1 - y0) * (x0 - x2) + (x1 - x0) * (y0 - y2)) / den\n        val t = ((x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2)) / den\n\n        if (t >= 0 - eps && t <= 1 + eps && s >= 0 - eps && s <= 1 + eps) {\n            Vector2(px, py)\n        } else {\n            Vector2.INFINITY\n        }\n    } else {\n        Vector2.INFINITY\n    }\n}\n\nfun LineSegment(x0: Double, y0: Double, x1: Double, y1: Double) = LineSegment(Vector2(x0, y0), Vector2(x1, y1))","package org.openrndr.shape\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Matrix44\nimport org.openrndr.math.Vector3\nimport kotlin.math.abs\nimport kotlin.math.min\n\nclass PathProjection3D(val segmentProjection: SegmentProjection3D, val projection: Double, val distance: Double, val point: Vector3)\n\n@Serializable\nclass Path3D(val segments: List<Segment3D>, val closed: Boolean) {\n    companion object {\n        fun fromPoints(points: List<Vector3>, closed: Boolean) =\n                if (!closed)\n                    Path3D((0 until points.size - 1).map { Segment3D(points[it], points[it + 1]) }, closed)\n                else\n                    Path3D((points.indices).map { Segment3D(points[it], points[(it + 1) % points.size]) }, closed)\n    }\n\n    val exploded: List<Path3D>\n        get() = segments.map { Path3D(listOf(it), false) }\n\n    operator fun plus(other: Path3D): Path3D {\n        val epsilon = 0.001\n        val segments = mutableListOf<Segment3D>()\n        segments.addAll(this.segments)\n        if ((this.segments[this.segments.size - 1].end - other.segments[0].start).length > epsilon) {\n            segments.add(Segment3D(this.segments[this.segments.size - 1].end, other.segments[0].start))\n        }\n        segments.addAll(other.segments)\n        return Path3D(segments, false)\n    }\n\n\n    fun position(ut: Double): Vector3 {\n        return when(val t = ut.coerceIn(0.0, 1.0)) {\n            0.0 -> segments[0].start\n            1.0 -> segments.last().end\n            else -> {\n                val segment = (t * segments.size).toInt()\n                val segmentOffset = (t * segments.size) - segment\n                segments[min(segments.size - 1, segment)].position(segmentOffset)\n            }\n        }\n    }\n\n    fun adaptivePositions(distanceTolerance: Double = 0.5): List<Vector3> {\n        val adaptivePoints = mutableListOf<Vector3>()\n        var last: Vector3? = null\n        for (segment in this.segments) {\n            val samples = segment.adaptivePositions(distanceTolerance)\n            if (samples.isNotEmpty()) {\n                val r = samples[0]\n                if (last == null || last.minus(r).length > 0.01) {\n                    adaptivePoints.add(r)\n                }\n                for (i in 1 until samples.size) {\n                    adaptivePoints.add(samples[i])\n                    last = samples[i]\n                }\n            }\n        }\n        return adaptivePoints\n    }\n\n    fun adaptivePositionsWithT(distanceTolerance: Double = 0.5): List<Pair<Vector3, Double>> {\n        val adaptivePoints = mutableListOf<Pair<Vector3, Double>>()\n        var last: Vector3? = null\n        for (segment in this.segments) {\n            val samples = segment.adaptivePositionsWithT(distanceTolerance)\n            if (samples.isNotEmpty()) {\n                val r = samples[0]\n                if (last == null || last.minus(r.first).length > 0.01) {\n                    adaptivePoints.add(r)\n                }\n                for (i in 1 until samples.size) {\n                    adaptivePoints.add(samples[i])\n                    last = samples[i].first\n                }\n            }\n        }\n        return adaptivePoints\n    }\n\n\n\n    /**\n     *\n     */\n    fun equidistantPositions(pointCount: Int, distanceTolerance: Double = 0.5): List<Vector3> {\n        return sampleEquidistant(adaptivePositions(distanceTolerance), pointCount)\n    }\n\n    fun equidistantPositionsWithT(pointCount: Int, distanceTolerance: Double = 0.5): List<Pair<Vector3, Double>> {\n        return sampleEquidistantWithT(adaptivePositionsWithT(distanceTolerance), pointCount)\n    }\n\n\n    /**\n     * Adaptively sample the contour into line segments while still approximating the original contour\n     * @param distanceTolerance controls the quality of the approximation\n     * @return a ShapeContour composed of linear segments\n     */\n    fun sampleLinear(distanceTolerance: Double = 0.5) =\n            fromPoints(adaptivePositions(distanceTolerance), closed)\n\n    /**\n     * Sample the shape contour into line segments\n     */\n    fun sampleEquidistant(pointCount: Int, distanceTolerance: Double = 0.5): Path3D {\n        val points = equidistantPositions(pointCount, distanceTolerance)\n        val segments = (0 until points.size - 1).map { Segment3D(points[it], points[it + 1]) }\n        return Path3D(segments, closed)\n    }\n\n\n    fun transform(transform: Matrix44) = Path3D(segments.map { it.transform(transform) }, closed)\n\n    private fun mod(a: Double, b: Double) = ((a % b) + b) % b\n\n    /**\n     * Sample a sub contour\n     * @param t0 starting point in [0, 1)\n     * @param t1 ending point in [0, 1)\n     * @return sub contour\n     */\n    fun sub(t0: Double, t1: Double): Path3D {\n        var u0 = t0\n        var u1 = t1\n\n        if (closed && (u1 < u0 || u1 > 1.0 || u0 > 1.0 || u0 < 0.0 || u1 < 0.0)) {\n            val diff = u1 - u0\n            u0 = mod(u0, 1.0)\n            if (abs(diff) < 1.0 - 2.0 * 10E-17) {\n                return if (diff > 0.0) {\n                    u1 = u0 + diff\n                    if (u1 > 1.0) {\n                        sub(u0, 1.0) + sub(0.0, u1 - 1.0)\n                    } else {\n                        sub(u0, u1)\n                    }\n                } else {\n                    u1 = u0 + diff\n                    if (u1 < 0) {\n                        sub(u1 + 1.0, 1.0) + sub(0.0, u0)\n                    } else {\n                        sub(u1, u0)\n                    }\n                }\n            } else {\n                u1 = if (diff < 0.0) {\n                    u0 - 1.0\n                } else {\n                    u0 + 1.0\n                }\n                if (u1 > 1.0) {\n                    return sub(u0, 1.0) + sub(0.0, u1 - 1.0)\n                }\n                if (u1 < 1.0) {\n                    return sub(u0, 1.0) + sub(0.0, u1 + 1.0)\n                }\n            }\n        }\n\n        u0 = u0.coerceIn(0.0, 1.0)\n        u1 = u1.coerceIn(0.0, 1.0)\n\n        var z0 = u0\n        var z1 = u1\n\n        if (u0 > u1) {\n            z0 = u1\n            z1 = u0\n        }\n\n        val length = segments.size.toDouble()\n        var segment0 = (z0 * length).toInt()\n        val segmentOffset0 = if (segment0 < segments.size) z0 * length % 1.0 else 1.0\n        var segment1 = (z1 * length).toInt()\n        val segmentOffset1 = if (segment1 < segments.size) z1 * length % 1.0 else 1.0\n\n        segment1 = min(segments.size - 1, segment1)\n        segment0 = min(segments.size - 1, segment0)\n\n\n        val newSegments = mutableListOf<Segment3D>()\n        val epsilon = 0.000001\n\n        for (s in segment0..segment1) {\n            if (s == segment0 && s == segment1) {\n                //if (Math.abs(segmentOffset0-segmentOffset1) > epsilon)\n                newSegments.add(segments[s].sub(segmentOffset0, segmentOffset1))\n            } else if (s == segment0) {\n                if (segmentOffset0 < 1.0 - epsilon)\n                    newSegments.add(segments[s].sub(segmentOffset0, 1.0))\n            } else if (s == segment1) {\n                if (segmentOffset1 > epsilon)\n                    newSegments.add(segments[s].sub(0.0, segmentOffset1))\n            } else {\n                newSegments.add(segments[s])\n            }\n        }\n        return Path3D(newSegments, false)\n    }\n\n\n    /**\n     * Checks if a give point lies on the contour\n     * @param point the point to check\n     * @param error what is the allowed error (unitless, but likely in pixels)\n     * @return the contour parameter in [0..1.0) if the point is within error `null` otherwise\n     *\n     */\n    fun on(point: Vector3, error: Double = 5.0): Double? {\n        for (i in segments.indices) {\n            val st = segments[i].on(point, error)\n            if (st != null) {\n                return (i + st) / segments.size\n            }\n        }\n        return null\n    }\n\n    /**\n     * Project a point on the contour\n     * @param point the point to project\n     * @return a projected point that lies on the contour\n     */\n    fun project(point: Vector3): PathProjection3D {\n        val nearest = segments.mapIndexed { index, it -> Pair(index, it.project(point)) }.minByOrNull { it.second.distance }!!\n\n        return PathProjection3D(\n            nearest.second, (nearest.first + nearest.second.projection) /\n                    segments.size, nearest.second.distance, nearest.second.point\n        )\n\n    }\n\n    val reversed: Path3D get() = Path3D(segments.map { it.reverse }.reversed(), closed)\n\n    val length get() = segments.sumOf { it.length }\n\n\n    fun map(closed: Boolean = this.closed, mapper: (Segment3D) -> Segment3D): Path3D {\n        val segments = segments.map(mapper)\n        val fixedSegments = mutableListOf<Segment3D>()\n\n        if (segments.size > 1) {\n            for (i in 0 until segments.size - 1) {\n                val left = segments[i]\n                val right = segments[i + 1]\n                val fixLeft = Segment3D(left.start, left.control, right.start)\n                fixedSegments.add(fixLeft)\n            }\n            if (closed) {\n                val left = segments.last()\n                val right = segments.first()\n                fixedSegments.add(Segment3D(left.start, left.control, right.start))\n            } else {\n                fixedSegments.add(segments.last())\n            }\n        }\n\n        return Path3D(if (segments.size > 1) fixedSegments else segments, closed)\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (this::class != other!!::class)\n\n        other as Path3D\n\n        if (segments != (other as Path3D).segments) return false\n        return closed == other.closed\n    }\n\n    override fun hashCode(): Int {\n        var result = segments.hashCode()\n        result = 31 * result + closed.hashCode()\n        return result\n    }\n}\n\n","@file:Suppress(\"unused\")\n\npackage org.openrndr.shape\n\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.Transient\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.YPolarity\nimport org.openrndr.math.clamp\nimport kotlin.jvm.JvmName\nimport kotlin.math.absoluteValue\nimport kotlin.math.max\nimport kotlin.math.min\n\n/**\n * Creates a new axis-aligned [Rectangle].\n *\n * [Rectangle] is only a data structure with no visible representation,\n * although it can be drawn by calling [org.openrndr.draw.Drawer.rectangle].\n *\n * Also see [IntRectangle].\n */\n@Serializable\ndata class Rectangle(val corner: Vector2, val width: Double, val height: Double = width) : Movable, Scalable2D,\n    ShapeProvider, ShapeContourProvider {\n\n\n    /** The center of the [Rectangle]. */\n    val center: Vector2\n        get() = corner + Vector2(width / 2, height / 2)\n\n    /** The unitless area covered by this [Rectangle]. */\n    val area: Double\n        get() = width * height\n\n    /** The dimensions of the [Rectangle]. */\n    val dimensions: Vector2\n        get() = Vector2(width, height)\n\n    override val scale: Vector2\n        get() = dimensions\n\n    override fun position(u: Double, v: Double): Vector2 {\n        return corner + Vector2(u * width, v * height)\n    }\n\n    /** The [x]-coordinate of the top-left corner. */\n    val x: Double get() = corner.x\n\n    /** The [y]-coordinate of the top-left corner. */\n    val y: Double get() = corner.y\n\n    /** Returns [Shape] representation of the [Rectangle]. */\n    override val shape:Shape get() = Shape(listOf(contour))\n\n    /** Returns [ShapeContour] representation of the [Rectangle]. */\n    override val contour: ShapeContour\n        get() {\n            return if (corner == Vector2.INFINITY || corner.x != corner.x || corner.y != corner.y || width != width || height != height) {\n                ShapeContour.EMPTY\n            } else {\n                ShapeContour.fromPoints(\n                    listOf(\n                        corner, corner + Vector2(width, 0.0),\n                        corner + Vector2(width, height),\n                        corner + Vector2(0.0, height)\n                    ), true, YPolarity.CW_NEGATIVE_Y\n                )\n            }\n        }\n\n    /**\n     * Creates a new [Rectangle] with sides offset both horizontally and vertically by specified amount.\n     *\n     * The [Rectangle] sides are shifted outwards if [offset] values are > 0 or inwards if the values are < 0.\n     */\n    fun offsetEdges(offset: Double, offsetY: Double = offset): Rectangle {\n        return Rectangle(Vector2(corner.x - offset, corner.y - offsetY), width + 2 * offset, height + 2 * offsetY)\n    }\n\n    /**\n     * Creates a new [Rectangle] with dimensions scaled by [scale] and [scaleY].\n     *\n     * @param scale the x scale factor\n     * @param scaleY the y scale factor, default is [scale]\n     * @param anchorU x coordinate of the scaling anchor in u parameter space, default is 0.5 (center)\n     * @param anchorV y coordinate of the scaling anchor in v parameter space, default is 0.5 (center)\n     */\n    @Deprecated(\"Vague naming\", ReplaceWith(\"scaledBy(scale, scaleY)\"))\n    fun scale(scale: Double, scaleY: Double = scale, anchorU: Double = 0.5, anchorV: Double = 0.5): Rectangle {\n        return scaledBy(scale, scaleY, anchorU, anchorV)\n    }\n\n    @Deprecated(\"Doesn't account for anchor placement\", ReplaceWith(\"scaledBy(scale, scaleY)\"))\n    fun scaled(scale: Double, scaleY: Double = scale): Rectangle {\n        return Rectangle(corner, width * scale, height * scaleY)\n    }\n\n    /** Creates a new [Rectangle] with width set to [fitWidth] and height scaled proportionally. */\n    fun widthScaledTo(fitWidth: Double): Rectangle {\n        val scale = fitWidth / width\n        return Rectangle(corner, fitWidth, height * scale)\n    }\n\n    /** Creates a new [Rectangle] with height set to [fitHeight] and width scaled proportionally. */\n    fun heightScaledTo(fitHeight: Double): Rectangle {\n        val scale = fitHeight / height\n        return Rectangle(corner, width * scale, fitHeight)\n    }\n\n    /** Creates a new [Rectangle] with the same size but the current position offset by [offset] amount. */\n    @Deprecated(\"Vague naming\", ReplaceWith(\"movedBy(offset)\"))\n    fun moved(offset: Vector2): Rectangle {\n        return Rectangle(corner + offset, width, height)\n    }\n\n    override fun movedBy(offset: Vector2): Rectangle = Rectangle(corner + offset, width, height)\n\n    override fun movedTo(position: Vector2): Rectangle = Rectangle(position, width, height)\n\n    override fun scaledBy(xScale: Double, yScale: Double, uAnchor: Double, vAnchor: Double): Rectangle {\n        val anchorPosition = position(uAnchor, vAnchor)\n        val d = corner - anchorPosition\n        val nd = anchorPosition + d * Vector2(xScale, yScale)\n        return Rectangle(nd, width * xScale, height * yScale)\n    }\n\n    override fun scaledBy(scale: Double, uAnchor: Double, vAnchor: Double): Rectangle =\n        scaledBy(scale, scale, uAnchor, vAnchor)\n\n    override fun scaledTo(width: Double, height: Double): Rectangle = Rectangle(corner, width, height)\n\n    override fun scaledTo(size: Double): Rectangle = scaledTo(size, size)\n\n    /**\n     * Creates a Rectangle mirrored around a vertical axis. [u] specifies the axis position.\n     * Defaults to 0.5 (center). Left edge = 0.0, right edge = 1.0.\n     * Frequently used for mirroring images or video.\n     */\n    fun flippedHorizontally(u: Double = 0.5): Rectangle = if (u == 0.5) {\n        scaledBy(xScale = -1.0, 1.0)\n    } else {\n        scaledBy(xScale = -1.0, 1.0).movedBy(Vector2((u * 2 - 1) * width, 0.0))\n    }\n\n    /**\n     * Creates a Rectangle mirrored around a horizontal axis. [v] specifies the axis position.\n     * Defaults to 0.5 (center). Top edge = 0.0, bottom edge = 1.0.\n     * Frequently used for mirroring images or video.\n     */\n    fun flippedVertically(v: Double = 0.5): Rectangle = if (v == 0.5) {\n        scaledBy(xScale = 1.0, -1.0)\n    } else {\n        scaledBy(xScale = 1.0, -1.0).movedBy(Vector2(0.0, (v * 2 - 1) * height))\n    }\n\n    /**\n     * Returns a horizontal [LineSegment] specified by [v].\n     * Top edge [v] = 0.0, bottom edge [v] = 1.0.\n     */\n    fun horizontal(v: Double = 0.5): LineSegment = LineSegment(\n        position(0.0, v), position(1.0, v)\n    )\n\n    /**\n     * Returns a vertical [LineSegment] specified by [u].\n     * Left edge [u] = 0.0, right edge [u] = 1.0.\n     */\n    fun vertical(u: Double = 0.5): LineSegment = LineSegment(\n        position(u, 0.0), position(u, 1.0)\n    )\n\n    /**\n     * Returns true if given [point] is inside the [Rectangle].\n     */\n    operator fun contains(point: Vector2): Boolean {\n        return (point.x >= corner.x &&\n                point.x < corner.x + width &&\n                point.y >= corner.y &&\n                point.y < corner.y + height)\n    }\n\n    /**\n     * Tests if the **areas** of two rectangles intersect.\n     */\n    fun intersects(other: Rectangle): Boolean {\n        val above = y + height < other.y\n        val below = y > other.y + other.height\n        val rightOf = x > other.x + other.width\n        val leftOf = x + width < other.x\n        return !(above || below || leftOf || rightOf)\n    }\n\n    companion object {\n        /** Creates a new [Rectangle] by specifying the [center] position with dimensions [width] and [height]. */\n        fun fromCenter(center: Vector2, width: Double, height: Double = width) =\n            fromAnchor(Vector2(0.5, 0.5), center, width, height)\n\n\n        /** Creates a new [Rectangle] by specifying the [anchorUV], [anchor] positions with dimensions [width] and [height]. */\n        fun fromAnchor(anchorUV: Vector2, anchor: Vector2, width: Double, height: Double = width) =\n            Rectangle(anchor.x - width * anchorUV.x, anchor.y - height * anchorUV.y, width, height)\n\n        /** A zero-length [Rectangle]. */\n        val EMPTY = Rectangle(0.0, 0.0, 0.0, 0.0)\n    }\n\n    operator fun times(scale: Double) = Rectangle(corner * scale, width * scale, height * scale)\n\n    operator fun div(scale: Double) = Rectangle(corner / scale, width / scale, height / scale)\n\n    operator fun plus(right: Rectangle) =\n        Rectangle(corner + right.corner, width + right.width, height + right.height)\n\n    operator fun minus(right: Rectangle) =\n        Rectangle(corner - right.corner, width - right.width, height - right.height)\n\n    fun sub(u0: Double, v0: Double, u1: Double, v1: Double): Rectangle {\n        val p0 = position(u0, v0)\n        val p1 = position(u1, v1)\n        val width = p1.x - p0.x\n        val height = p1.y - p0.y\n        return Rectangle(p0.x, p0.y, width, height)\n    }\n\n    /**\n     * Casts to [IntRectangle].\n     */\n    fun toInt() = IntRectangle(x.toInt(), y.toInt(), width.toInt(), height.toInt())\n\n\n    val normalized: Rectangle\n        get() {\n            var nx = x\n            var ny = y\n            if (width < 0) {\n                nx += width\n            }\n            if (height < 0) {\n                ny += height\n            }\n            return Rectangle(nx, ny, width.absoluteValue, height.absoluteValue)\n        }\n}\n\n/** calculates [Rectangle]-bounds for a list of [Vector2] instances */\n@Deprecated(\"use List<Vector2>.bounds instead\", ReplaceWith(\"points.bounds\"))\nfun vector2Bounds(points: List<Vector2>) = points.bounds\n\n/**\n * Calculates [Rectangle]-bounds from a [List] of [Vector2] instances.\n *\n * The provided list should consist of more than one item for optimal results.\n */\nval List<Vector2>.bounds: Rectangle\n    @JvmName(\"getVector2Bounds\") get() {\n        var minX = Double.POSITIVE_INFINITY\n        var minY = Double.POSITIVE_INFINITY\n        var maxX = Double.NEGATIVE_INFINITY\n        var maxY = Double.NEGATIVE_INFINITY\n\n        this.forEach {\n            minX = min(minX, it.x)\n            maxX = max(maxX, it.x)\n            minY = min(minY, it.y)\n            maxY = max(maxY, it.y)\n        }\n        return Rectangle(Vector2(minX, minY), maxX - minX, maxY - minY)\n    }\n\n/** calculates [Rectangle]-bounds for a list of [Rectangle] instances */\n@Deprecated(\n    \"use List<Rectangle>.bounds instead\",\n    ReplaceWith(\"rectangles.bounds\")\n)\nfun rectangleBounds(rectangles: List<Rectangle>): Rectangle {\n    return rectangles.bounds\n}\n\n/** Calculates [Rectangle]-bounds for a list of [Rectangle] instances. */\nval List<Rectangle>.bounds: Rectangle\n    @JvmName(\"getRectangleBounds\") get() {\n        var minX = Double.POSITIVE_INFINITY\n        var minY = Double.POSITIVE_INFINITY\n        var maxX = Double.NEGATIVE_INFINITY\n        var maxY = Double.NEGATIVE_INFINITY\n\n        this.forEach {\n            if (it != Rectangle.EMPTY) {\n                minX = min(minX, it.x)\n                maxX = max(maxX, it.x + it.width)\n                minY = min(minY, it.y)\n                maxY = max(maxY, it.y + it.height)\n            }\n        }\n        return Rectangle(Vector2(minX, minY), maxX - minX, maxY - minY)\n    }\n\n/** Determines whether rectangles [a] and [b] intersect. */\n@Deprecated(\n    \"use Rectangle.intersects(Rectangle) instead\",\n    ReplaceWith(\"a.intersects(b)\")\n)\nfun intersects(a: Rectangle, b: Rectangle) = a.intersects(b)\n\n/**\n * Clamps a [Vector2] within the bounds of the [bounds] `Rectangle`.\n */\nfun Vector2.clamp(bounds: Rectangle) =\n    this.clamp(bounds.corner, bounds.corner + bounds.dimensions)\n\n/**\n * Remaps [Vector2] from a position on the [sourceRectangle] to\n * a proportionally equivalent position on the [targetRectangle].\n *\n * @param clamp Clamps remapped value within the bounds of [targetRectangle].\n */\nfun Vector2.map(sourceRectangle: Rectangle, targetRectangle: Rectangle, clamp: Boolean = false): Vector2 {\n    val remapped =\n        (this - sourceRectangle.corner) / sourceRectangle.dimensions * targetRectangle.dimensions + targetRectangle.corner\n    return if (clamp) remapped.clamp(targetRectangle) else remapped\n}\n\n/**\n * Maps all elements in a `List<Vector2>`\n * from [sourceRectangle] to [targetRectangle].\n * If [clamp] is true all elements are clamped within the bounds of [targetRectangle].\n */\nfun List<Vector2>.map(sourceRectangle: Rectangle, targetRectangle: Rectangle, clamp: Boolean = false): List<Vector2> =\n    this.map { it.map(sourceRectangle, targetRectangle, clamp) }\n\n\nfun Rectangle(x: Double, y: Double, width: Double, height: Double = width) = Rectangle(Vector2(x, y), width, height)\n\n\n","package org.openrndr.shape\n\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.Transient\nimport org.openrndr.math.*\n\nimport org.openrndr.shape.internal.BezierCubicSamplerT\nimport org.openrndr.shape.internal.BezierQuadraticSamplerT\nimport kotlin.math.*\n\n/**\n * Creates a new [Segment], which specifies a linear\n * or a Bézier curve path between two anchor points\n * (and up to two control points for curvature).\n */\n@Serializable\ndata class Segment(\n    val start: Vector2,\n    val control: List<Vector2>,\n    val end: Vector2,\n    val corner: Boolean = false\n) : ShapeContourProvider {\n    /** The start point of the [Segment]. */\n\n    /**\n     * Indicates whether the [Segment] is [linear][SegmentType.LINEAR].\n     */\n    val linear: Boolean get() = control.isEmpty()\n\n    /**\n     * Returns the type of the segment.\n     */\n    val type: SegmentType\n        get() {\n            return if (linear) {\n                SegmentType.LINEAR\n            } else {\n                if (control.size == 1) {\n                    SegmentType.QUADRATIC\n                } else {\n                    SegmentType.CUBIC\n                }\n            }\n        }\n\n    @Transient\n    private var lut: List<Vector2>? = null\n\n\n    @Suppress(\"unused\")\n    fun lut(size: Int = 100): List<Vector2> {\n        if (lut == null || lut!!.size != size) {\n            lut = (0..size).map { position((it.toDouble() / size)) }\n        }\n        return lut!!\n    }\n\n    fun on(point: Vector2, error: Double = 5.0): Double? {\n        val lut = lut()\n        var hits = 0\n        var t = 0.0\n        for (i in lut.indices) {\n            if ((lut[i] - point).squaredLength < error * error) {\n                hits++\n                t += i.toDouble() / lut.size\n            }\n        }\n        return if (hits > 0) t / hits else null\n    }\n\n    /**\n     * Estimate [t](https://pomax.github.io/bezierinfo/#explanation) value for a given length\n     * @return A value between `0.0` and `1.0`.\n     */\n    fun tForLength(length: Double): Double {\n        if (type == SegmentType.LINEAR) {\n            return (length / this.length).coerceIn(0.0, 1.0)\n        }\n\n        val segmentLength = this.length\n        val cLength = length.coerceIn(0.0, segmentLength)\n\n        if (cLength == 0.0) {\n            return 0.0\n        }\n        if (cLength >= segmentLength) {\n            return 1.0\n        }\n        var summedLength = 0.0\n        lut(100)\n        val cLut = lut ?: error(\"no lut\")\n        val partitionCount = cLut.size - 1\n\n        val dt = 1.0 / partitionCount\n        for ((index, _ /*point*/) in lut!!.withIndex()) {\n            if (index < lut!!.size - 1) {\n                val p0 = cLut[index]\n                val p1 = cLut[index + 1]\n                val partitionLength = p0.distanceTo(p1)\n                summedLength += partitionLength\n                if (summedLength >= length) {\n                    val localT = index.toDouble() / partitionCount\n                    val overshoot = summedLength - length\n                    return localT + (overshoot / partitionLength) * dt\n                }\n            }\n        }\n        return 1.0\n    }\n\n    /**\n     * Calculates the point at a given distance along this [Segment].\n     * @param length the distance along the [Segment].\n     * @param distanceTolerance the tolerance used for simplifying the [Segment], lower values\n     * result in more accurate results, but slower calculation.\n     *\n     * @see [Segment.adaptivePositions]\n     */\n    fun pointAtLength(length: Double, distanceTolerance: Double = 0.5): Vector2 {\n        when {\n            length <= 0.0 -> return start\n            length >= this.length -> return end\n        }\n        var remainingLength = length\n        var currentPoint = start\n        val points = adaptivePositions(distanceTolerance)\n        for (point in points) {\n            val segmentLength = currentPoint.distanceTo(point)\n            if (remainingLength <= segmentLength) {\n                val currentVector = point - currentPoint\n                val tangent = currentVector / segmentLength\n                return currentPoint + tangent * remainingLength\n            }\n            remainingLength -= segmentLength\n            currentPoint = point\n        }\n        return end\n    }\n\n    @Suppress(\"unused\")\n    private fun closest(points: List<Vector2>, query: Vector2): Pair<Int, Vector2> {\n        var closestIndex = 0\n        var closestValue = points[0]\n\n        var closestDistance = Double.POSITIVE_INFINITY\n        for (i in points.indices) {\n            val distance = (points[i] - query).squaredLength\n            if (distance < closestDistance) {\n                closestIndex = i\n                closestValue = points[i]\n                closestDistance = distance\n            }\n        }\n        return Pair(closestIndex, closestValue)\n    }\n\n    /**\n     * Find point on segment nearest to given [point].\n     * @param point The query point.\n     */\n    fun nearest(point: Vector2): SegmentPoint {\n        val t = when (type) {\n            SegmentType.LINEAR -> {\n                val dir = end - start\n                val relativePoint = point - start\n                ((dir dot relativePoint) / dir.squaredLength).coerceIn(0.0, 1.0)\n            }\n\n            SegmentType.QUADRATIC -> {\n                val qa = start - point\n                val ab = control[0] - start\n                val bc = end - control[0]\n                val qc = end - point\n                val ac = end - start\n                val br = start + end - control[0] - control[0]\n\n                var minDistance = sign(ab cross qa) * qa.length\n                var param = -(qa dot ab) / (ab dot ab)\n\n                val distance = sign(bc cross qc) * qc.length\n                if (abs(distance) < abs(minDistance)) {\n                    minDistance = distance\n                    param =\n                        max(1.0, ((point - control[0]) dot bc) / (bc dot bc))\n                }\n\n                val a = br dot br\n                val b = 3.0 * (ab dot br)\n                val c = (2.0 * (ab dot ab)) + (qa dot br)\n                val d = qa dot ab\n                val ts = solveCubic(a, b, c, d)\n\n                for (t in ts) {\n                    if (t > 0 && t < 1) {\n                        val endpoint = position(t)\n                        val distance2 = sign(ac cross (endpoint - point)) * (endpoint - point).length\n                        if (abs(distance2) < abs(minDistance)) {\n                            minDistance = distance2\n                            param = t\n                        }\n                    }\n                }\n                param.coerceIn(0.0, 1.0)\n            }\n\n            SegmentType.CUBIC -> {\n                fun sign(n: Double): Double {\n                    val s = n.sign\n                    return if (s == 0.0) -1.0 else s\n                }\n\n                val qa = start - point\n                val ab = control[0] - start\n                val bc = control[1] - control[0]\n                val cd = end - control[1]\n                val qd = end - point\n                val br = bc - ab\n                val ax = (cd - bc) - br\n\n                var minDistance = sign(ab cross qa) * qa.length\n                var param = -(qa dot ab) / (ab dot ab)\n\n                var distance = sign(cd cross qd) * qd.length\n                if (abs(distance) < abs(minDistance)) {\n                    minDistance = distance\n                    param = max(1.0, (point - control[1] dot cd) / (cd dot cd))\n                }\n                val searchStarts = 4\n                val searchSteps = 8\n\n                for (i in 0 until searchStarts) {\n                    var t = i.toDouble() / (searchStarts - 1)\n                    var step = 0\n                    while (true) {\n                        val qpt = position(t) - point\n                        distance = sign(direction(t) cross qpt) * qpt.length\n                        if (abs(distance) < abs(minDistance)) {\n                            minDistance = distance\n                            param = t\n                        }\n                        if (step == searchSteps) {\n                            break\n                        }\n                        val d1 = (ax * (3 * t * t)) + br * (6 * t) + ab * 3.0\n                        val d2 = (ax * (6 * t)) + br * 6.0\n                        val dt = (qpt dot d1) / ((d1 dot d1) + (qpt dot d2))\n                        if (abs(dt) < 1e-14) {\n                            break\n                        }\n                        t -= dt\n                        if (t < 0 || t > 1) {\n                            break\n                        }\n                        step++\n                    }\n                }\n                param.coerceIn(0.0, 1.0)\n            }\n        }\n        val closest = position(t)\n        return SegmentPoint(this, t, closest)\n    }\n\n    /**\n     * Applies given linear transformation.\n     */\n    fun transform(transform: Matrix44): Segment {\n        return if (transform === Matrix44.IDENTITY) {\n            this\n        } else {\n            val tStart = (transform * (start.xy01)).div.xy\n            val tEnd = (transform * (end.xy01)).div.xy\n            val tControl = when (control.size) {\n                2 -> listOf((transform * control[0].xy01).div.xy, (transform * control[1].xy01).div.xy)\n                1 -> listOf((transform * control[0].xy01).div.xy)\n                else -> emptyList()\n            }\n            copy(start = tStart, control = tControl, end = tEnd)\n        }\n    }\n\n    /**\n     * Recursively subdivides [Segment] to approximate Bézier curve.\n     *\n     * @param distanceTolerance The square of the maximal distance of each point from curve.\n     */\n    fun adaptivePositions(distanceTolerance: Double = 0.5): List<Vector2> =\n        adaptivePositionsWithT(distanceTolerance).map { it.first }\n\n\n    fun adaptivePositionsWithT(distanceTolerance: Double = 0.5): List<Pair<Vector2, Double>> = when (control.size) {\n        0 -> listOf(start to 0.0, end to 1.0)\n        1 -> BezierQuadraticSamplerT<Vector2>().apply { this.distanceTolerance = distanceTolerance }\n            .sample(start, control[0], end)\n\n        2 -> BezierCubicSamplerT<Vector2>().apply { this.distanceTolerance = distanceTolerance }\n            .sample(start, control[0], control[1], end)\n\n        else -> throw RuntimeException(\"unsupported number of control points\")\n    }\n\n    /**\n     * Samples specified amount of points on the [Segment].\n     * @param pointCount The number of points to sample.\n     */\n    fun equidistantPositions(pointCount: Int, distanceTolerance: Double = 0.5): List<Vector2> {\n        return sampleEquidistant(adaptivePositions(distanceTolerance), pointCount)\n    }\n\n    fun equidistantPositionsWithT(pointCount: Int, distanceTolerance: Double = 0.5): List<Pair<Vector2, Double>> {\n        return sampleEquidistantWithT(adaptivePositionsWithT(distanceTolerance), pointCount)\n    }\n\n\n    // work around length-by-lazy property being initialized before the secondary constructor initializes the relevant fields\n    private val internalLength: Double\n        get() = when (control.size) {\n            0 -> (end - start).length\n            1, 2 -> sumDifferences(adaptivePositions())\n            else -> throw RuntimeException(\"unsupported number of control points\")\n        }\n\n    /** Calculates approximate Euclidean length of the [Segment]. */\n    val length by lazy {\n        internalLength\n    }\n\n    /**\n     * Returns a point on the segment.\n     *\n     * @param ut unfiltered [t](https://pomax.github.io/bezierinfo/#explanation), will be clamped between 0.0 and 1.0.\n     * @return [Vector2] that lies on the [Segment].\n     */\n    fun position(ut: Double): Vector2 {\n        val t = ut.coerceIn(0.0, 1.0)\n        return when (control.size) {\n            0 -> Vector2(\n                start.x * (1.0 - t) + end.x * t,\n                start.y * (1.0 - t) + end.y * t\n            )\n\n            1 -> bezier(start, control[0], end, t)\n            2 -> bezier(start, control[0], control[1], end, t)\n            else -> error(\"unsupported number of control points\")\n        }\n    }\n\n    /** Returns the direction [Vector2] of between the [Segment] anchor points. */\n    fun direction(): Vector2 = (end - start).normalized\n\n    fun direction(t: Double): Vector2 = derivative(t).normalized\n\n    /**\n     * Calculates the pose [Matrix44] (i.e. translation and rotation) that describes an orthonormal basis\n     * formed by normal and tangent of the contour at [t](https://pomax.github.io/bezierinfo/#explanation).\n     *\n     * Which means it returns a [Matrix44],\n     * that you can use to orient an object\n     * the same way the curve is oriented at\n     * given value of *t*.\n     *\n     * @param t The value of t in the range of `0.0` to `1.0` at which to return the pose at.\n     */\n    @Suppress(\"unused\")\n    fun pose(t: Double, polarity: YPolarity = YPolarity.CW_NEGATIVE_Y): Matrix44 {\n        val dx = direction(t).xy0.xyz0\n        val dy = direction(t).perpendicular(polarity).xy0.xyz0\n        val dt = position(t).xy01\n        return Matrix44.fromColumnVectors(dx, dy, Vector4.UNIT_Z, dt)\n    }\n\n    /**\n     * Returns the [t](https://pomax.github.io/bezierinfo/#explanation)\n     * values of the extrema for the current [Segment].\n     *\n     * Either one or two *t* values in which the curve\n     * is the most distant from an imaginary\n     * straight line between the two anchor points.\n     */\n    fun extrema(): List<Double> {\n        val dPoints = dPoints()\n        return when {\n            linear -> emptyList()\n            control.size == 1 -> {\n                val xRoots = roots(dPoints[0].map { it.x })\n                val yRoots = roots(dPoints[0].map { it.y })\n                (xRoots + yRoots).distinct().sorted().filter { it in 0.0..1.0 }\n            }\n\n            control.size == 2 -> {\n                val xRoots = roots(dPoints[0].map { it.x }) + roots(dPoints[1].map { it.x })\n                val yRoots = roots(dPoints[0].map { it.y }) + roots(dPoints[1].map { it.y })\n                (xRoots + yRoots).distinct().sorted().filter { it in 0.0..1.0 }\n            }\n\n            else -> throw RuntimeException(\"not supported\")\n        }\n    }\n\n    /** Returns the extrema points as [Vector2]s for current [Segment] */\n    @Suppress(\"unused\")\n    fun extremaPoints(): List<Vector2> = extrema().map { position(it) }\n\n    /** Returns the bounding box. */\n    val bounds: Rectangle\n        get() = (listOf(start, end) + extremaPoints()).bounds\n\n\n    private fun dPoints(): List<List<Vector2>> {\n        val points = listOf(start) + control + listOf(end)\n        var d = points.size\n        var c = d - 1\n        val dPoints = mutableListOf<List<Vector2>>()\n        var p = points\n        while (d > 1) {\n            val list = mutableListOf<Vector2>()\n            for (j in 0 until c) {\n                list.add(\n                    Vector2(\n                        c * (p[j + 1].x - p[j].x),\n                        c * (p[j + 1].y - p[j].y)\n                    )\n                )\n            }\n            dPoints.add(list)\n            p = list\n            d--\n            c--\n        }\n        return dPoints\n    }\n\n\n    private fun angle(o: Vector2, v1: Vector2, v2: Vector2): Double {\n        val dx1 = v1.x - o.x\n        val dy1 = v1.y - o.y\n        val dx2 = v2.x - o.x\n        val dy2 = v2.y - o.y\n        val cross = dx1 * dy2 - dy1 * dx2\n        val dot = dx1 * dx2 + dy1 * dy2\n        return atan2(cross, dot)\n    }\n\n    /**\n     * Determines if the [Segment] forms a straight line.\n     *\n     * If the given [Segment] has control points,\n     * the function verifies that they do not add any curvature to the path.\n     *\n     * @param tolerance The margin of error for what's considered a straight line.\n     */\n    @Suppress(\"unused\")\n    fun isStraight(tolerance: Double = 0.01): Boolean {\n        return when (control.size) {\n            2 -> {\n                val dl = (end - start).normalized\n                val d0 = (control[0] - start).normalized\n                val d1 = (end - control[0]).normalized\n\n                val dp0 = dl.dot(d0)\n                val dp1 = (-dl).dot(d1)\n\n                dp0 * dp0 + dp1 * dp1 > (2.0 - 2 * tolerance)\n            }\n\n            1 -> {\n                val dl = (end - start).normalized\n                val d0 = (control[0] - start).normalized\n\n                val dp0 = dl.dot(d0)\n                dp0 * dp0 > (1.0 - tolerance)\n            }\n\n            else -> {\n                true\n            }\n        }\n\n    }\n\n    val simple: Boolean\n        get() {\n            if (linear) {\n                return true\n            }\n            if (control.size == 2) {\n                val a1 = angle(start, end, control[0])\n                val a2 = angle(start, end, control[1])\n\n                if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0))\n                    return false\n            }\n            val n1 = normal(0.0, YPolarity.CW_NEGATIVE_Y)\n            val n2 = normal(1.0, YPolarity.CW_NEGATIVE_Y)\n            val s = n1 dot n2\n            return s >= 0.9\n        }\n\n\n\n    val clockwise\n        get() = angle(start, end, control[0]) > 0\n\n    /** Converts the [Segment] to a cubic Bézier curve. */\n    val cubic: Segment\n        get() = when {\n            control.size == 2 -> this\n            control.size == 1 -> {\n                Segment(\n                    start,\n                    start * (1.0 / 3.0) + control[0] * (2.0 / 3.0),\n                    control[0] * (2.0 / 3.0) + end * (1.0 / 3.0),\n                    end,\n                    corner\n                )\n            }\n\n            linear -> {\n                val delta = end - start\n                Segment(\n                    start,\n                    start + delta * (1.0 / 3.0),\n                    start + delta * (2.0 / 3.0),\n                    end,\n                    corner\n                )\n            }\n\n            else -> error(\"cannot convert to cubic segment\")\n        }\n\n\n    /** Converts the [Segment] to a quadratic Bézier curve. */\n    val quadratic: Segment\n        get() = when {\n            control.size == 1 -> this\n            linear -> {\n                val delta = end - start\n                Segment(start, start + delta * (1.0 / 2.0), end, corner)\n            }\n\n            else -> error(\"cannot convert to quadratic segment\")\n        }\n\n\n    fun derivative(t: Double): Vector2 = when {\n        linear -> end - start\n        control.size == 1 -> safeDerivative(start, control[0], end, t)\n        control.size == 2 -> safeDerivative(\n            start,\n            control[0],\n            control[1],\n            end,\n            t\n        )\n\n        else -> throw RuntimeException(\"not implemented\")\n    }\n\n    /**\n     * Returns a normal [Vector2] at given value of\n     * [t](https://pomax.github.io/bezierinfo/#explanation)\n     * in the range of `0.0` to `1.0`.\n     */\n    fun normal(ut: Double, polarity: YPolarity = YPolarity.CW_NEGATIVE_Y): Vector2 {\n        return direction(ut).perpendicular(polarity)\n    }\n\n    /** Reverses the order of control points of the given path [Segment]. */\n    val reverse: Segment\n        get() {\n            return when (control.size) {\n                0 -> Segment(end, start)\n                1 -> Segment(end, control[0], start)\n                2 -> Segment(end, control[1], control[0], start)\n                else -> throw RuntimeException(\"unsupported number of control points\")\n            }\n        }\n\n    /**\n     * Samples a new [Segment] from the current [Segment] starting at [t0] and ending at [t1].\n     *\n     * @param t0 The starting value of [t](https://pomax.github.io/bezierinfo/#explanation) in the range of `0.0` to `1.0`.\n     * @param t1 The ending value of *t* in the range of `0.0` to `1.0`.\n     */\n    fun sub(t0: Double, t1: Double): Segment {\n        // ftp://ftp.fu-berlin.de/tex/CTAN/dviware/dvisvgm/src/Bezier.cpp\n        var z0 = t0\n        var z1 = t1\n\n        if (t0 > t1) {\n            z1 = t0\n            z0 = t1\n        }\n\n        return when {\n            z0 == 0.0 -> split(z1)[0]\n            z1 == 1.0 -> split(z0).last()\n            else -> split(z0).last().split(map(z0, 1.0, 0.0, 1.0, z1))[0]\n        }\n    }\n\n    /**\n     * Splits the path into one or two parts, depending on if the cut was successful.\n     *\n     * @param t The point at which to split the [Segment] at.\n     * @return An array of parts, depending on the split point this is one or two entries long.\n     */\n    fun split(t: Double): Array<Segment> {\n        val u = t.clamp(0.0, 1.0)\n        val splitSigma = 10E-6\n\n        if (u < splitSigma) {\n            return arrayOf(Segment(start, start), this)\n        }\n\n        if (u >= 1.0 - splitSigma) {\n            return arrayOf(this, Segment(end, end))\n        }\n\n        if (linear) {\n            val cut = start + (end.minus(start) * u)\n            return arrayOf(Segment(start, cut), Segment(cut, end))\n        } else {\n            when (control.size) {\n                2 -> {\n                    @Suppress(\"UnnecessaryVariable\") val z = u\n                    val z2 = z * z\n                    val z3 = z * z * z\n                    val iz = 1 - z\n                    val iz2 = iz * iz\n                    val iz3 = iz * iz * iz\n\n                    val lsm = Matrix44(\n                        1.0, 0.0, 0.0, 0.0,\n                        iz, z, 0.0, 0.0,\n                        iz2, 2.0 * iz * z, z2, 0.0,\n                        iz3, 3.0 * iz2 * z, 3.0 * iz * z2, z3\n                    )\n\n                    val px = Vector4(start.x, control[0].x, control[1].x, end.x)\n                    val py = Vector4(start.y, control[0].y, control[1].y, end.y)\n\n                    val plx = lsm * px//.multiply(lsm)\n                    val ply = lsm * py// py.multiply(lsm)\n\n                    val pl0 = Vector2(plx.x, ply.x)\n                    val pl1 = Vector2(plx.y, ply.y)\n                    val pl2 = Vector2(plx.z, ply.z)\n                    val pl3 = Vector2(plx.w, ply.w)\n\n                    val left = Segment(pl0, pl1, pl2, pl3)\n\n                    val rsm = Matrix44(\n                        iz3, 3.0 * iz2 * z, 3.0 * iz * z2, z3,\n                        0.0, iz2, 2.0 * iz * z, z2,\n                        0.0, 0.0, iz, z,\n                        0.0, 0.0, 0.0, 1.0\n                    )\n\n                    val prx = rsm * px\n                    val pry = rsm * py\n\n                    val pr0 = Vector2(prx.x, pry.x)\n                    val pr1 = Vector2(prx.y, pry.y)\n                    val pr2 = Vector2(prx.z, pry.z)\n                    val pr3 = Vector2(prx.w, pry.w)\n\n                    val right = Segment(pr0, pr1, pr2, pr3)\n\n                    return arrayOf(left, right)\n                }\n\n                1 -> {\n                    @Suppress(\"UnnecessaryVariable\") val z = u\n                    val iz = 1 - z\n                    val iz2 = iz * iz\n                    val z2 = z * z\n\n                    val lsm = Matrix44(\n                        1.0, 0.0, 0.0, 0.0,\n                        iz, z, 0.0, 0.0,\n                        iz2, 2.0 * iz * z, z2, 0.0,\n                        0.0, 0.0, 0.0, 0.0\n                    )\n\n                    val px = Vector4(start.x, control[0].x, end.x, 0.0)\n                    val py = Vector4(start.y, control[0].y, end.y, 0.0)\n\n                    val plx = lsm * px\n                    val ply = lsm * py\n\n                    val left = Segment(\n                        Vector2(plx.x, ply.x),\n                        Vector2(plx.y, ply.y),\n                        Vector2(plx.z, ply.z)\n                    )\n\n                    val rsm = Matrix44(\n                        iz2, 2.0 * iz * z, z2, 0.0,\n                        0.0, iz, z, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        0.0, 0.0, 0.0, 0.0\n                    )\n\n                    val prx = rsm * px\n                    val pry = rsm * py\n\n                    val rdx0 = prx.y - prx.x\n                    val rdy0 = pry.y - pry.x\n\n                    val rdx1 = prx.z - prx.y\n                    val rdy1 = pry.z - pry.y\n\n\n                    require(rdx0 * rdx0 + rdy0 * rdy0 > 0.0) {\n                        \"Q start/c0 overlap after split on $t $this\"\n                    }\n                    require(rdx1 * rdx1 + rdy1 * rdy1 > 0.0) {\n                        \"Q end/c0 overlap after split on $t $this\"\n                    }\n\n                    val right = Segment(\n                        Vector2(prx.x, pry.x),\n                        Vector2(prx.y, pry.y),\n                        Vector2(prx.z, pry.z)\n                    )\n\n                    return arrayOf(left, right)\n                }\n\n                else -> error(\"unsupported number of control points\")\n            }\n        }\n    }\n\n    override fun toString(): String {\n        return \"Segment(start=$start, end=$end, control=${control})\"\n    }\n\n\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other == null) return false\n        if (this::class != other::class) return false\n\n        other as Segment\n\n        if (start != other.start) return false\n        if (end != other.end) return false\n        return control == other.control\n    }\n\n    override fun hashCode(): Int {\n        var result = start.hashCode()\n        result = 31 * result + end.hashCode()\n        result = 31 * result + control.hashCode()\n        return result\n    }\n\n    operator fun times(scale: Double): Segment {\n        return when (type) {\n            SegmentType.LINEAR -> Segment(start * scale, end * scale)\n            SegmentType.QUADRATIC -> Segment(\n                start * scale,\n                control[0] * scale,\n                end * scale\n            )\n\n            SegmentType.CUBIC -> Segment(\n                start * scale,\n                control[0] * scale,\n                control[1] * scale,\n                end * scale\n            )\n        }\n    }\n\n    operator fun div(scale: Double): Segment {\n        return when (type) {\n            SegmentType.LINEAR -> Segment(start / scale, end / scale)\n            SegmentType.QUADRATIC -> Segment(\n                start / scale,\n                control[0] / scale,\n                end / scale\n            )\n\n            SegmentType.CUBIC -> Segment(\n                start / scale,\n                control[0] / scale,\n                control[1] / scale,\n                end / scale\n            )\n        }\n    }\n\n    operator fun minus(right: Segment): Segment {\n        return if (this.type == right.type) {\n            when (type) {\n                SegmentType.LINEAR -> Segment(\n                    start - right.start,\n                    end - right.end\n                )\n\n                SegmentType.QUADRATIC -> Segment(\n                    start - right.start,\n                    control[0] - right.control[0],\n                    end - right.end\n                )\n\n                SegmentType.CUBIC -> Segment(\n                    start - right.start,\n                    control[0] - right.control[0],\n                    control[1] - right.control[1],\n                    end - right.end\n                )\n            }\n        } else {\n            if (this.type.ordinal > right.type.ordinal) {\n                when (type) {\n                    SegmentType.LINEAR -> error(\"impossible?\")\n                    SegmentType.QUADRATIC -> this - right.quadratic\n                    SegmentType.CUBIC -> this - right.cubic\n                }\n            } else {\n                when (right.type) {\n                    SegmentType.LINEAR -> error(\"impossible?\")\n                    SegmentType.QUADRATIC -> this.quadratic - right\n                    SegmentType.CUBIC -> this.cubic - right\n                }\n            }\n        }\n    }\n\n    operator fun plus(right: Segment): Segment {\n        return if (this.type == right.type) {\n            when (type) {\n                SegmentType.LINEAR -> Segment(\n                    start + right.start,\n                    end + right.end\n                )\n\n                SegmentType.QUADRATIC -> Segment(\n                    start + right.start,\n                    control[0] + right.control[0],\n                    end + right.end\n                )\n\n                SegmentType.CUBIC -> Segment(\n                    start + right.start,\n                    control[0] + right.control[0],\n                    control[1] + right.control[1],\n                    end + right.end\n                )\n            }\n        } else {\n            if (this.type.ordinal > right.type.ordinal) {\n                when (type) {\n                    SegmentType.LINEAR -> error(\"impossible?\")\n                    SegmentType.QUADRATIC -> this + right.quadratic\n                    SegmentType.CUBIC -> this + right.cubic\n                }\n            } else {\n                when (right.type) {\n                    SegmentType.LINEAR -> error(\"impossible?\")\n                    SegmentType.QUADRATIC -> this.quadratic + right\n                    SegmentType.CUBIC -> this.cubic + right\n                }\n            }\n        }\n    }\n\n    override val contour: ShapeContour\n        get() = ShapeContour(listOf(this), false)\n\n}\n\nprivate fun sumDifferences(points: List<Vector2>) =\n    (0 until points.size - 1).sumOf { (points[it] - points[it + 1]).length }\n\n\n/**\n * Linear segment constructor.\n *\n * @param start The starting anchor point.\n * @param end The ending anchor point.\n */\n\nfun Segment(start: Vector2, end: Vector2, corner: Boolean = true) = Segment(\n    start,\n    emptyList<Vector2>(),\n    end,\n    corner\n)\n\n/**\n * Quadratic Bézier segment constructor.\n *\n * @param start The starting anchor point.\n * @param c0 The control point.\n * @param end The ending anchor point.\n */\nfun Segment(start: Vector2, c0: Vector2, end: Vector2, corner: Boolean = true) = Segment(\n    start,\n    listOf(c0),\n    end,\n    corner\n)\n\n/**\n * Cubic Bézier segment constructor.\n *\n * @param start The starting anchor point.\n * @param c0 The first control point.\n * @param c1 The second control point\n * @param end The ending anchor point.\n */\nfun Segment(start: Vector2, c0: Vector2, c1: Vector2, end: Vector2, corner: Boolean = true) = Segment(\n    start,\n    listOf(c0, c1),\n    end,\n    corner\n)\n","package org.openrndr.shape\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.*\nimport org.openrndr.shape.internal.BezierCubicSamplerT\nimport org.openrndr.shape.internal.BezierQuadraticSamplerT\n\nprivate fun sumDifferences(points: List<Vector3>) =\n        (0 until points.size - 1).sumOf { (points[it] - points[it + 1]).length }\n\n\nclass SegmentProjection3D(val segment: Segment3D, val projection: Double, val distance: Double, val point: Vector3)\n\n@Serializable\nclass Segment3D(val start: Vector3, val control: Array<Vector3>, val end: Vector3) {\n\n\n    val linear: Boolean get() = control.isEmpty()\n\n    private var lut: List<Vector3>? = null\n\n    /**\n     * Linear segment constructor\n     * @param start starting point of the segment\n     * @param end end point of the segment\n     */\n\n    fun lut(size: Int = 100): List<Vector3> {\n        if (lut == null || lut!!.size != size) {\n            lut = (0..size).map { position((it.toDouble() / size)) }\n        }\n        return lut!!\n    }\n\n    fun on(point: Vector3, error: Double = 5.0): Double? {\n        val lut = lut()\n        var hits = 0\n        var t = 0.0\n        for (i in lut.indices) {\n            if ((lut[i] - point).squaredLength < error * error) {\n                hits++\n                t += i.toDouble() / lut.size\n            }\n        }\n        return if (hits > 0) t / hits else null\n    }\n\n    private fun closest(points: List<Vector3>, query: Vector3): Pair<Int, Vector3> {\n        var closestIndex = 0\n        var closestValue = points[0]\n\n        var closestDistance = Double.POSITIVE_INFINITY\n        for (i in 0 until points.size) {\n            val distance = (points[i] - query).squaredLength\n            if (distance < closestDistance) {\n                closestIndex = i\n                closestValue = points[i]\n                closestDistance = distance\n            }\n        }\n        return Pair(closestIndex, closestValue)\n    }\n\n    fun project(point: Vector3): SegmentProjection3D {\n        // based on bezier.js\n        val lut = lut()\n        val l = (lut.size - 1).toDouble()\n        val closest = closest(lut, point)\n\n        var closestDistance = (point - closest.second).squaredLength\n\n        if (closest.first == 0 || closest.first == lut.size - 1) {\n            val t = closest.first.toDouble() / l\n            return SegmentProjection3D(this, t, closestDistance, closest.second)\n        } else {\n            val t1 = (closest.first - 1) / l\n            val t2 = (closest.first + 1) / l\n            val step = 0.1 / l\n\n            var t = t1\n            var ft = t1\n\n            while (t < t2 + step) {\n                val p = position(t)\n                val d = (p - point).squaredLength\n                if (d < closestDistance) {\n                    closestDistance = d\n                    ft = t\n                }\n                t += step\n            }\n            val p = position(ft)\n            return SegmentProjection3D(this, ft, closestDistance, p)\n        }\n    }\n\n    fun transform(transform: Matrix44): Segment3D {\n        val tstart = (transform * (start.xyz1)).div\n        val tend = (transform * (end.xyz1)).div\n        val tcontrol = when (control.size) {\n            2 -> arrayOf((transform * control[0].xyz1).div, (transform * control[1].xyz1).div)\n            1 -> arrayOf((transform * control[0].xyz1).div)\n            else -> emptyArray()\n        }\n        return Segment3D(tstart, tcontrol, tend)\n    }\n    @Deprecated(\"inconsistent naming\", replaceWith = ReplaceWith(\"adaptivePositions\"))\n    fun sampleAdaptive(distanceTolerance: Double = 0.5): List<Vector3> = adaptivePositions(distanceTolerance)\n\n    fun adaptivePositions(distanceTolerance: Double = 0.5): List<Vector3> =\n        adaptivePositionsWithT(distanceTolerance).map { it.first }\n\n    fun adaptivePositionsWithT(distanceTolerance: Double = 0.5): List<Pair<Vector3, Double>> = when (control.size) {\n        0 -> listOf(start to 0.0, end to 1.0)\n        1 -> BezierQuadraticSamplerT<Vector3>().apply { this.distanceTolerance = distanceTolerance }.sample(start, control[0], end)\n        2 -> BezierCubicSamplerT<Vector3>().apply { this.distanceTolerance = distanceTolerance }.sample(start, control[0], control[1], end)\n        else -> throw RuntimeException(\"unsupported number of control points\")\n    }\n\n    /**\n     * Samples specified amount of points on the [Segment3D].\n     * @param pointCount The number of points to sample.\n     */\n    fun equidistantPositions(pointCount: Int, distanceTolerance: Double = 0.5): List<Vector3> {\n        return sampleEquidistant(adaptivePositions(distanceTolerance), pointCount)\n    }\n\n    fun equidistantPositionsWithT(pointCount: Int, distanceTolerance: Double = 0.5): List<Pair<Vector3, Double>> {\n        return sampleEquidistantWithT(adaptivePositionsWithT(distanceTolerance), pointCount)\n    }\n\n\n    val length: Double\n        get() = when (control.size) {\n            0 -> (end - start).length\n            1, 2 -> sumDifferences(adaptivePositions())\n            else -> throw RuntimeException(\"unsupported number of control points\")\n        }\n\n    fun position(ut: Double): Vector3 {\n        val t = ut.coerceIn(0.0, 1.0)\n        return when (control.size) {\n            0 -> Vector3(start.x * (1.0 - t) + end.x * t, start.y * (1.0 - t) + end.y * t, start.z * (1.0 - t) + end.z * t)\n            1 -> bezier(start, control[0], end, t)\n            2 -> bezier(start, control[0], control[1], end, t)\n            else -> throw RuntimeException(\"unsupported number of control points\")\n        }\n    }\n\n    fun direction(): Vector3 {\n        return (start - end).normalized\n    }\n\n    fun direction(t: Double): Vector3 {\n        return derivative(t).normalized\n    }\n\n    fun extrema(): List<Double> {\n        val dpoints = dpoints()\n        return when {\n            linear -> emptyList()\n            control.size == 1 -> {\n                val xRoots = roots(dpoints[0].map { it.x })\n                val yRoots = roots(dpoints[0].map { it.y })\n                (xRoots + yRoots).distinct().sorted().filter { it in 0.0..1.0 }\n            }\n            control.size == 2 -> {\n                val xRoots = roots(dpoints[0].map { it.x }) + roots(dpoints[1].map { it.x })\n                val yRoots = roots(dpoints[0].map { it.y }) + roots(dpoints[1].map { it.y })\n                (xRoots + yRoots).distinct().sorted().filter { it in 0.0..1.0 }\n            }\n            else -> throw RuntimeException(\"not supported\")\n        }\n    }\n\n    fun extremaPoints(): List<Vector3> = extrema().map { position(it) }\n\n\n    private fun dpoints(): List<List<Vector3>> {\n        val points = listOf(start, *control, end)\n        var d = points.size\n        var c = d - 1\n        val dpoints = mutableListOf<List<Vector3>>()\n        var p = points\n        while (d > 1) {\n            val list = mutableListOf<Vector3>()\n            for (j in 0 until c) {\n                list.add(Vector3(c * (p[j + 1].x - p[j].x), c * (p[j + 1].y - p[j].y), c * (p[j + 1].z - p[j].z)))\n            }\n            dpoints.add(list)\n            p = list\n            d--\n            c--\n        }\n        return dpoints\n    }\n\n\n    /**\n     * Cubic version of segment\n     */\n    val cubic: Segment3D\n        get() = when {\n            control.size == 2 -> this\n            control.size == 1 -> {\n                Segment3D(\n                    start,\n                    start * (1.0 / 3.0) + control[0] * (2.0 / 3.0),\n                    control[0] * (2.0 / 3.0) + end * (1.0 / 3.0),\n                    end\n                )\n            }\n            linear -> {\n                val delta = end - start\n                Segment3D(\n                    start,\n                    start + delta * (1.0 / 3.0),\n                    start + delta * (2.0 / 3.0),\n                    end\n                )\n            }\n            else -> throw RuntimeException(\"cannot convert to cubic segment\")\n        }\n\n    fun derivative(t: Double): Vector3 = when {\n        linear -> start - end\n        control.size == 1 -> derivative(start, control[0], end, t)\n        control.size == 2 -> derivative(start, control[0], control[1], end, t)\n        else -> throw RuntimeException(\"not implemented\")\n    }\n\n    val reverse: Segment3D\n        get() {\n            return when (control.size) {\n                0 -> Segment3D(end, start)\n                1 -> Segment3D(end, control[0], start)\n                2 -> Segment3D(end, control[1], control[0], start)\n                else -> throw RuntimeException(\"unsupported number of control points\")\n            }\n        }\n\n    fun sub(t0: Double, t1: Double): Segment3D {\n        // ftp://ftp.fu-berlin.de/tex/CTAN/dviware/dvisvgm/src/Bezier.cpp\n        var z0 = t0\n        var z1 = t1\n\n        if (t0 > t1) {\n            z1 = t0\n            z0 = t1\n        }\n\n        return when {\n            z0 == 0.0 -> split(z1)[0]\n            z1 == 1.0 -> split(z0)[1]\n            else -> split(z0)[1].split(map(z0, 1.0, 0.0, 1.0, z1))[0]\n        }\n    }\n\n    /**\n     * Split the contour\n     * @param t the point to split the contour at\n     * @return array of parts, depending on the split point this is one or two entries long\n     */\n    fun split(t: Double): Array<Segment3D> {\n        val u = t.coerceIn(0.0, 1.0)\n\n        if (linear) {\n            val cut = start + (end.minus(start) * u)\n            return arrayOf(Segment3D(start, cut), Segment3D(cut, end))\n        } else {\n            when (control.size) {\n                2 -> {\n                    val z = u\n                    val z2 = z * z\n                    val z3 = z * z * z\n                    val iz = 1 - z\n                    val iz2 = iz * iz\n                    val iz3 = iz * iz * iz\n\n                    val lsm = Matrix44(\n                        1.0, 0.0, 0.0, 0.0,\n                        iz, z, 0.0, 0.0,\n                        iz2, 2.0 * iz * z, z2, 0.0,\n                        iz3, 3.0 * iz2 * z, 3.0 * iz * z2, z3)\n\n                    val px = Vector4(start.x, control[0].x, control[1].x, end.x)\n                    val py = Vector4(start.y, control[0].y, control[1].y, end.y)\n                    val pz = Vector4(start.z, control[0].z, control[1].z, end.z)\n\n                    val plx = lsm * px//.multiply(lsm)\n                    val ply = lsm * py// py.multiply(lsm)\n                    val plz = lsm * pz// py.multiply(lsm)\n\n                    val pl0 = Vector3(plx.x, ply.x, plz.x)\n                    val pl1 = Vector3(plx.y, ply.y, plz.y)\n                    val pl2 = Vector3(plx.z, ply.z, plz.z)\n                    val pl3 = Vector3(plx.w, ply.w, plz.w)\n\n                    val left = Segment3D(pl0, pl1, pl2, pl3)\n\n                    val rsm = Matrix44(\n                        iz3, 3.0 * iz2 * z, 3.0 * iz * z2, z3,\n                        0.0, iz2, 2.0 * iz * z, z2,\n                        0.0, 0.0, iz, z,\n                        0.0, 0.0, 0.0, 1.0\n                    )\n\n                    val prx = rsm * px\n                    val pry = rsm * py\n                    val prz = rsm * pz\n\n                    val pr0 = Vector3(prx.x, pry.x, prz.x)\n                    val pr1 = Vector3(prx.y, pry.y, prz.y)\n                    val pr2 = Vector3(prx.z, pry.z, prz.z)\n                    val pr3 = Vector3(prx.w, pry.w, prz.w)\n\n                    val right = Segment3D(pr0, pr1, pr2, pr3)\n\n                    return arrayOf(left, right)\n                }\n                1 -> {\n                    val z = u\n                    val iz = 1 - z\n                    val iz2 = iz * iz\n                    val z2 = z * z\n\n                    val lsm = Matrix44(\n                        1.0, 0.0, 0.0, 0.0,\n                        iz, z, 0.0, 0.0,\n                        iz2, 2.0 * iz * z, z2, 0.0,\n                        0.0, 0.0, 0.0, 0.0)\n\n                    val px = Vector4(start.x, control[0].x, end.x, 0.0)\n                    val py = Vector4(start.y, control[0].y, end.y, 0.0)\n                    val pz = Vector4(start.z, control[0].z, end.z, 0.0)\n\n                    val plx = lsm * px\n                    val ply = lsm * py\n                    val plz = lsm * pz\n\n                    val left = Segment3D(\n                        Vector3(plx.x, ply.x, plz.x),\n                        Vector3(plx.y, ply.y, plz.y),\n                        Vector3(plx.z, ply.z, plz.z)\n                    )\n\n                    val rsm = Matrix44(\n                        iz2, 2.0 * iz * z, z2, 0.0,\n                        0.0, iz, z, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        0.0, 0.0, 0.0, 0.0)\n\n                    val prx = rsm * px\n                    val pry = rsm * py\n                    val prz = rsm * pz\n\n                    val right = Segment3D(\n                        Vector3(prx.x, pry.x, prz.x),\n                        Vector3(prx.y, pry.y, prz.y),\n                        Vector3(prx.z, pry.z, prz.z)\n                    )\n\n                    return arrayOf(left, right)\n\n                }\n                else -> throw RuntimeException(\"not implemented\")\n            }\n        }\n    }\n\n    override fun toString(): String {\n        return \"Segment(start=$start, end=$end, control=${control.contentToString()})\"\n    }\n\n    fun copy(start: Vector3 = this.start, control: Array<Vector3> = this.control, end: Vector3 = this.end): Segment3D {\n        return Segment3D(start, control, end)\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other == null) return false\n        if (this::class != other::class) return false\n\n        other as Segment3D\n\n        if (start != other.start) return false\n        if (end != other.end) return false\n        return control.contentEquals(other.control)\n    }\n\n    override fun hashCode(): Int {\n        var result = start.hashCode()\n        result = 31 * result + end.hashCode()\n        result = 31 * result + control.contentHashCode()\n        return result\n    }\n\n\n}\n\nfun Segment3D(start: Vector3, end: Vector3) = Segment3D(start, emptyArray(), end)\n\n\n/**\n * Quadratic bezier segment constructor\n * @param start starting point of the segment\n * @param c0 control point\n * @param end end point of the segment\n */\nfun Segment3D(start: Vector3, c0: Vector3, end: Vector3) = Segment3D(start, arrayOf(c0), end)\n\n\n/**\n * Cubic bezier segment constructor\n * @param start starting point of the segment\n * @param c0 first control point\n * @param c1 second control point\n * @param end end point of the segment\n */\nfun Segment3D(start: Vector3, c0: Vector3, c1: Vector3, end: Vector3) = Segment3D(start, arrayOf(c0, c1), end)\n\n","@file:Suppress(\"unused\", \"MemberVisibilityCanPrivate\", \"MemberVisibilityCanBePrivate\")\n\npackage org.openrndr.shape\n\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.Transient\nimport org.openrndr.kartifex.Region2\nimport org.openrndr.math.*\nimport org.openrndr.utils.resettableLazy\nimport kotlin.random.Random\n\n@Serializable\n/**\n * A simple interface for managing a [List] of [ShapeContour].\n */\nclass Shape(val contours: List<ShapeContour>) : ShapeProvider {\n    companion object {\n        /**\n         * An empty [Shape] object.\n         *\n         * It is advised to use this instance whenever an empty shape is needed.\n         */\n        val EMPTY: Shape = Shape(emptyList())\n\n        /** Creates a [Shape] from combining a [List] of Shapes */\n        fun compound(shapes: List<Shape>) = Shape(shapes.flatMap { it.contours })\n    }\n\n    /** Returns [Shape] bounding box. */\n    @Transient\n    private val boundsDelegate = resettableLazy {\n        if (empty) {\n            Rectangle(0.0, 0.0, 0.0, 0.0)\n        } else {\n            val result: List<Rectangle> = contours.mapNotNull {\n                if (it.empty) {\n                    null\n                } else {\n                    it.bounds\n                }\n            }\n            result.bounds\n        }\n    }\n\n    val bounds by boundsDelegate\n\n    /** Indicates the [Shape] topology. */\n    @Transient\n    val topology = when {\n        contours.isEmpty() -> ShapeTopology.OPEN\n        contours.all { it.closed } -> ShapeTopology.CLOSED\n        contours.all { !it.closed } -> ShapeTopology.OPEN\n        else -> ShapeTopology.MIXED\n    }\n\n    @Transient\n            /** Lists all [ShapeContour]s with an [open topology][ShapeTopology.OPEN]. */\n    val openContours: List<ShapeContour> =\n        when (topology) {\n            ShapeTopology.OPEN -> contours\n            ShapeTopology.CLOSED -> emptyList()\n            ShapeTopology.MIXED -> contours.filter { !it.closed }\n        }\n\n\n    /** Lists all [ShapeContour]s with a [closed topology][ShapeTopology.CLOSED]. */\n    @Transient\n    val closedContours: List<ShapeContour> =\n        when (topology) {\n            ShapeTopology.OPEN -> emptyList()\n            ShapeTopology.CLOSED -> contours\n            ShapeTopology.MIXED -> contours.filter { it.closed }\n        }\n\n    /** Returns true if [Shape] contains no [ShapeContour]s. */\n    val empty get() = this === EMPTY || contours.isEmpty()\n\n\n    /**\n     * Projects a point on the contours of a [Shape]\n     * @param point The point to project.\n     * @return a projected point that lies on the [ShapeContour].\n     */\n    fun nearest(point: Vector2): ContourPoint {\n        require(!empty) {\n            \"\"\"cannot perform nearest point query on empty shape\"\"\"\n        }\n        return contours.map { it.nearest(point) }.minByOrNull { it.position.squaredDistanceTo(point) }\n            ?: error(\"no nearest segment\")\n    }\n\n    /**\n     * Returns true if [Shape] consists solely of [ShapeContour]s,\n     * where each [Segment] is a [line segment][SegmentType.LINEAR].\n     */\n    val linear get() = contours.all { it.segments.all { segment -> segment.linear } }\n    fun polygon(distanceTolerance: Double = 0.5) =\n        if (empty) {\n            EMPTY\n        } else {\n            Shape(contours.map { it.sampleLinear(distanceTolerance) })\n        }\n\n    @Transient\n    private val triangulationDelegate = resettableLazy {\n        triangulate(this).windowed(3, 3).map {\n            Triangle(it[0], it[1], it[2])\n        }\n    }\n\n\n    /** Triangulates [Shape] into a [List] of [Triangle]s. */\n    val triangulation by triangulationDelegate\n\n    @Transient\n    private val areaDelegate = resettableLazy {\n        triangulation.sumOf { it.area }\n    }\n\n    /** Calculates approximate area for this shape (through triangulation). */\n    val area by areaDelegate\n\n    @Transient\n    private val region2Delegate = resettableLazy {\n        Region2(contours.map { it.ring2 })\n    }\n\n    internal val region2 by region2Delegate\n\n    @Transient\n    private val path2Delegate = resettableLazy {\n        contours.map { it.path2 }\n    }\n\n    internal val path2 by path2Delegate\n\n    fun resetCache() {\n        boundsDelegate.reset()\n        triangulationDelegate.reset()\n        areaDelegate.reset()\n        region2Delegate.reset()\n        path2Delegate.reset()\n        contours.forEach { it.resetCache() }\n    }\n\n    /**\n     * Generates specified amount of random points that lie inside the [Shape].\n     *\n     * @param pointCount The number of points to generate.\n     * @param random The [Random] number generator to use, defaults to [Random.Default].\n     */\n    fun randomPoints(pointCount: Int, random: Random = Random.Default): List<Vector2> {\n        val randomValues = List(pointCount) { random.nextDouble() * area }.sortedDescending().toMutableList()\n        var sum = 0.0\n        val result = mutableListOf<Vector2>()\n        for (triangle in triangulation) {\n            sum += triangle.area\n            if (randomValues.isEmpty()) {\n                break\n            }\n            while (sum > randomValues.last()) {\n                result.add(triangle.randomPoint())\n                randomValues.removeLastOrNull()\n                if (randomValues.isEmpty()) {\n                    break\n                }\n            }\n        }\n        return result\n    }\n\n\n    /** The outline of the shape. */\n    val outline get() = contours[0]\n\n    /**\n     * The indexed hole of the shape.\n     * @param index\n     */\n    fun hole(index: Int) = contours[index + 1]\n\n    /**\n     * Applies a linear transformation to the [Shape].\n     *\n     * @param transform A [Matrix44] that represents the transform.\n     * @return A transformed [Shape] instance\n     */\n    fun transform(transform: Matrix44) = when {\n        empty -> EMPTY\n        transform === Matrix44.IDENTITY -> this\n        else -> Shape(contours.map { it.transform(transform) })\n    }\n\n    /** Applies a map to the shape. Maps every contour. */\n    fun map(mapper: (ShapeContour) -> ShapeContour) = Shape(contours.map { mapper(it) })\n\n    /**\n     * Checks whether the [Shape] is org.openrndr.shape.compound or not.\n     *\n     * Returns true when there's multiple [ShapeContour]s with a [clockwise winding][Winding.CLOCKWISE]\n     * because the function only counts non-hole ShapeContours (which are clockwise).\n     */\n    val compound: Boolean\n        get() {\n            return if (contours.isEmpty()) {\n                false\n            } else {\n                contours.count { it.winding == Winding.CLOCKWISE } > 1\n            }\n        }\n\n    /** Splits an org.openrndr.shape.compound shape into separate shapes. */\n    fun splitCompounds(winding: Winding = Winding.CLOCKWISE): List<Shape> {\n        return if (contours.isEmpty()) {\n            emptyList()\n        } else {\n            val (cw, ccw) = closedContours.partition { it.winding == winding }\n            val candidates = cw.map { outer ->\n                val cs = ccw.filter { it.bounds.intersects(outer.bounds) }\n                listOf(outer) + cs\n            }\n            (candidates + openContours.map { listOf(it) }).map { Shape(it) }\n        }\n    }\n\n    override val shape: Shape\n        get() = this\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other !is Shape) return false\n\n        if (contours != other.contours) return false\n\n        return true\n    }\n\n    override fun hashCode(): Int {\n        return contours.hashCode()\n    }\n\n    override fun toString(): String {\n        return \"Shape(org.openrndr.shape.contours=$contours, topology=$topology)\"\n    }\n}\n\n/** Converts a [List] of [Shape] items into a single org.openrndr.shape.compound [Shape]. */\n@Transient\nval List<Shape>.compound\n    get() = Shape.compound(this)\n\n","package org.openrndr.shape\n\n\nimport org.openrndr.kartifex.*\nimport org.openrndr.kartifex.utils.Intersections\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.YPolarity\nimport kotlin.jvm.JvmName\nimport kotlin.math.abs\n\nprivate fun Vector2.toVec2(): Vec2 {\n    return Vec2(x, y)\n}\n\nprivate fun Vec2.toVector2(): Vector2 {\n    return Vector2(x, y)\n}\n\ninternal fun Segment.toCurve2(): Curve2 {\n    return when (control.size) {\n        0 -> Line2.line(start.toVec2(), end.toVec2())\n        1 -> Bezier2.curve(start.toVec2(), control[0].toVec2(), end.toVec2())\n        2 -> Bezier2.curve(start.toVec2(), control[0].toVec2(), control[1].toVec2(), end.toVec2())\n        else -> throw IllegalArgumentException(\"unsupported control count ${control.size}\")\n    }\n}\n\nprivate fun Region2.toShape(): Shape {\n    return if (rings.isEmpty()) {\n        Shape.EMPTY\n    } else {\n        Shape(rings.map { it.toShapeContour() }.filter { !it.empty })\n    }\n}\n\nprivate fun Region2.toShapes(): List<Shape> {\n    val shapes = mutableListOf<Shape>()\n    if (rings.isNotEmpty()) {\n\n        val contours = mutableListOf<ShapeContour>()\n        rings.forEach { ring ->\n            contours.add(ring.toShapeContour())\n\n            if (!ring.isClockwise) {\n                if (contours.isNotEmpty()) {\n                    shapes.add(Shape(contours.reversed()))\n                }\n                contours.clear()\n            }\n        }\n        if (contours.isNotEmpty()) {\n            shapes.add(Shape(contours.reversed()))\n        }\n\n        if (rings.size != shapes.sumOf { it.contours.size }) {\n            throw RuntimeException(\"conversion broken\")\n        }\n    }\n    return shapes\n}\n\nprivate fun Curve2.toSegment(): Segment {\n    return when (this) {\n        is Line2 -> Segment(this.start().toVector2(), this.end().toVector2())\n        is Bezier2.QuadraticBezier2 -> Segment(this.p0.toVector2(), this.p1.toVector2(), this.p2.toVector2())\n        is Bezier2.CubicBezier2 -> Segment(\n            this.p0.toVector2(),\n            this.p1.toVector2(),\n            this.p2.toVector2(),\n            this.p3.toVector2()\n        )\n        else -> throw IllegalArgumentException()\n    }\n}\n\nprivate fun Ring2.toShapeContour(): ShapeContour {\n    if (curves.isEmpty()) {\n        return ShapeContour.EMPTY\n    }\n    return ShapeContour(this.curves.map { it.toSegment() }, true, YPolarity.CW_NEGATIVE_Y)\n}\n\nprivate fun List<Shape>.toRegion2(): Region2 {\n    return Region2(flatMap { shape ->\n        shape.contours.map { it.ring2 }\n    })\n}\n\n\n/**\n * Applies a boolean difference operation between two [ShapeContour]s.\n */\nfun difference(from: ShapeContour, subtract: ShapeContour): Shape {\n    return if (from.closed) {\n        val result = from.ring2.region().difference(subtract.ring2.region())\n        result.toShape()\n    } else {\n        return if (subtract.closed) {\n            val ints = intersections(from, subtract)\n            return if (ints.isNotEmpty()) {\n                val sortedInts = ints.sortedBy { it.a.contourT }.map { it.a.contourT }\n                val weldedInts = (listOf(if (sortedInts.first() > 0.0) 0.0 else null) + sortedInts + (if (sortedInts.last() < 1.0) 1.0 else null)).filterNotNull().merge { a, b ->\n                    abs(a - b) < 1E-6\n                }\n                val partitions = weldedInts.zipWithNext().mapNotNull {\n                    val partition = from.sub(it.first, it.second)\n                    if (partition.position(0.5) !in subtract) {\n                        partition\n                    } else {\n                        null\n                    }\n                }\n                Shape(partitions)\n            } else {\n                if (from.position(0.0) !in subtract) from.shape else Shape.EMPTY\n            }\n        } else {\n            from.shape\n        }\n    }\n}\n\n/**\n * Applies a boolean difference operation between a [Shape] and a [ShapeContour].\n */\nfun difference(from: Shape, subtract: ShapeContour): Shape {\n    return when (from.topology) {\n        ShapeTopology.CLOSED -> {\n            if (subtract.closed) {\n                val result = from.region2.difference(subtract.ring2.region())\n                result.toShape()\n            } else {\n                return from\n            }\n        }\n        ShapeTopology.OPEN -> {\n            if (subtract.closed) {\n                Shape.compound(from.contours.map {\n                    difference(it, subtract)\n                })\n            } else {\n                return from\n            }\n        }\n        ShapeTopology.MIXED -> {\n            if (subtract.closed) {\n                Shape.compound(from.splitCompounds().map {\n                    difference(it, subtract)\n                })\n            } else {\n                return from\n            }\n        }\n    }\n}\n\n/**\n * Applies a boolean difference operation between a [ShapeContour] and a [Shape].\n */\nfun difference(from: ShapeContour, subtract: Shape): Shape {\n    return if (from.closed) {\n        val result = from.ring2.region().difference(subtract.region2)\n        result.toShape()\n    } else {\n        when (subtract.topology) {\n            ShapeTopology.CLOSED -> {\n                val ints = subtract.contours.flatMap { intersections(from, it) }\n                if (ints.isNotEmpty()) {\n                    val sortedInts = ints.map { it.a.contourT }.sorted()\n                    val weldedInts = (listOfNotNull(if (sortedInts.first() > 0.0) 0.0 else null) + sortedInts + (if (sortedInts.last() < 1.0) 1.0 else null)).filterNotNull().merge { a, b ->\n                        abs(a - b) < 1E-6\n                    }\n                    val partitions = weldedInts.zipWithNext().mapNotNull {\n                        val partition = from.sub(it.first, it.second)\n                        if (partition.position(0.5) !in subtract) {\n                            partition\n                        } else {\n                            null\n                        }\n                    }\n                    Shape(partitions)\n                } else {\n                    if (from.position(0.0) !in subtract) from.shape else Shape.EMPTY\n                }\n            }\n            ShapeTopology.OPEN -> {\n                from.shape\n            }\n            ShapeTopology.MIXED -> {\n                return difference(\n                    from,\n                    Shape(subtract.splitCompounds().filter { it.topology == ShapeTopology.OPEN }\n                        .flatMap { it.contours })\n                )\n            }\n        }\n    }\n}\n\n/**\n * Applies a boolean difference operation between two [Shape]s.\n */\nfun difference(from: Shape, subtract: Shape): Shape {\n    if (from.empty) {\n        return Shape.EMPTY\n    }\n    if (subtract.empty) {\n        return from\n    }\n    return when (from.topology) {\n        ShapeTopology.OPEN -> {\n            when (subtract.topology) {\n                ShapeTopology.OPEN -> from\n                ShapeTopology.CLOSED -> {\n                    Shape.compound(from.contours.map { difference(it, subtract) })\n                }\n                ShapeTopology.MIXED -> {\n                    val closed = Shape(from.splitCompounds().filter { it.topology == ShapeTopology.CLOSED }\n                        .flatMap { it.contours })\n                    difference(closed, subtract)\n                }\n            }\n        }\n        ShapeTopology.CLOSED -> {\n            when (subtract.topology) {\n                ShapeTopology.OPEN -> from\n                ShapeTopology.CLOSED -> {\n                    val result = from.region2.difference(subtract.region2)\n                    result.toShape()\n                }\n                ShapeTopology.MIXED -> {\n                    val closed = Shape(from.splitCompounds().filter { it.topology == ShapeTopology.CLOSED }\n                        .flatMap { it.contours })\n                    difference(closed, subtract)\n                }\n            }\n        }\n        ShapeTopology.MIXED -> {\n            val closed =\n                Shape(from.splitCompounds().filter { it.topology == ShapeTopology.CLOSED }.flatMap { it.contours })\n            val open = from.openContours\n            Shape.compound(listOf(difference(closed, subtract)) + open.map { difference(it, subtract) })\n        }\n    }\n}\n\n/**\n * Applies a boolean difference operation between a [List] of [Shape]s and a [ShapeContour].\n */\nfun difference(from: List<Shape>, subtract: ShapeContour): List<Shape> {\n    return from.toRegion2().difference(subtract.ring2.region()).toShapes()\n}\n\n/**\n * Applies a boolean difference operation between a [List] of [Shape]s and a [Shape].\n */\nfun difference(from: List<Shape>, subtract: Shape): List<Shape> {\n    return from.toRegion2().difference(subtract.region2).toShapes()\n}\n\n/**\n * Applies a boolean difference operation between two [List]s of [Shape]s.\n */\nfun difference(from: List<Shape>, subtract: List<Shape>): List<Shape> {\n    return from.toRegion2().difference(subtract.toRegion2()).toShapes()\n}\n\n/**\n * Applies a boolean difference operation iteratively between a [List] of [Shape]s and a two-dimensional [List] of [Shape]s.\n *\n * [subtract] is traversed and a boolean [union] is applied between [from] and each element.\n */\n@JvmName(\"differenceIterative\")\nfun difference(from: List<Shape>, subtract: List<List<Shape>>): List<Shape> {\n    var left = from\n    for (subtractShapes in subtract) {\n        left = difference(left, subtractShapes)\n    }\n    return left\n}\n\n/**\n * Applies a boolean org.openrndr.shape.union operation between two [ShapeContour]s.\n */\nfun union(from: ShapeContour, add: ShapeContour): Shape {\n    if (from === ShapeContour.EMPTY && add == ShapeContour.EMPTY) {\n        return Shape.EMPTY\n    }\n    if (from === ShapeContour.EMPTY) {\n        return add.shape\n    }\n    if (add === ShapeContour.EMPTY) {\n        return from.shape\n    }\n\n    return if (from.closed) {\n        val result = from.ring2.region().union(add.ring2.region())\n        result.toShape()\n    } else {\n        from.shape\n    }\n}\n\n/**\n * Applies a boolean org.openrndr.shape.union operation between a [Shape] and a [ShapeContour].\n */\nfun union(from: Shape, add: ShapeContour): Shape {\n    if (from === Shape.EMPTY && add === ShapeContour.EMPTY) {\n        return Shape.EMPTY\n    }\n    if (from === Shape.EMPTY) {\n        return add.shape\n    }\n    if (add === ShapeContour.EMPTY) {\n        return from\n    }\n    val result = from.region2.union(add.ring2.region())\n    return result.toShape()\n}\n\n/**\n * Applies a boolean org.openrndr.shape.union operation between two [Shape]s.\n */\nfun union(from: Shape, add: Shape): Shape {\n    return if (from.topology == ShapeTopology.CLOSED) {\n        val result = from.region2.union(add.region2)\n        result.toShape()\n    } else {\n        from\n    }\n}\n\n/**\n * Applies a boolean org.openrndr.shape.union operation between a [List] of [Shape]s and a [ShapeContour].\n */\nfun union(from: List<Shape>, add: ShapeContour): List<Shape> {\n    return from.toRegion2().union(add.ring2.region()).toShapes()\n}\n\n/**\n * Applies a boolean org.openrndr.shape.union operation between a [List] of [Shape]s and a [Shape].\n */\nfun union(from: List<Shape>, add: Shape): List<Shape> {\n    return from.toRegion2().union(add.region2).toShapes()\n}\n\n/**\n * Applies a boolean org.openrndr.shape.union operation between two [List]s of [Shape]s.\n */\nfun union(from: List<Shape>, add: List<Shape>): List<Shape> {\n    return from.toRegion2().union(add.toRegion2()).toShapes()\n}\n\n/**\n * Applies a boolean org.openrndr.shape.union operation iteratively between a [List] of [Shape]s and a two-dimensional [List] of [Shape]s.\n *\n * [add] is traversed and a boolean [union] is applied between [from] and each element.\n */\n@JvmName(\"unionIterative\")\nfun union(from: List<Shape>, add: List<List<Shape>>): List<Shape> {\n    var left = from\n    for (addShapes in add) {\n        left = union(left, addShapes)\n    }\n    return left\n}\n\nfun List<Double>.merge(f: (Double, Double) -> Boolean): List<Double> {\n    val result = mutableListOf<Double>()\n    result.add(this[0])\n    var last = this[0]\n    for (i in 1 until size) {\n        if (!f(last, this[i])) {\n            result.add(this[i])\n            last = this[i]\n        }\n    }\n    return result\n}\n\n/**\n * Applies a boolean intersection operation between two [ShapeContour]s.\n */\nfun intersection(from: ShapeContour, with: ShapeContour): Shape {\n    if (from.empty || with.empty)\n        return Shape.EMPTY\n\n    return if (from.closed) {\n        val result = from.ring2.region().intersection(with.ring2.region())\n        result.toShape()\n    } else {\n        return if (with.closed) {\n            val ints = intersections(from, with)\n            return if (ints.isNotEmpty()) {\n                val sortedInts = ints.map { it.a.contourT }.sorted()\n                val weldedInts = (listOf(if (sortedInts.first() > 0.0) 0.0 else null) + sortedInts + (if (sortedInts.last() < 1.0) 1.0 else null)).filterNotNull().merge { a, b ->\n                    abs(a - b) < 1E-6\n                }\n                val partitions = weldedInts.zipWithNext().mapNotNull {\n                    val partition = from.sub(it.first, it.second)\n                    if (partition.position(0.5) in with) {\n                        partition\n                    } else {\n                        null\n                    }\n                }\n                Shape(partitions)\n            } else {\n                if (from.position(0.0) in with) from.shape else Shape.EMPTY\n            }\n        } else {\n            from.shape\n        }\n    }\n}\n\n/**\n * Applies a boolean intersection operation between a [Shape] and a [ShapeContour].\n */\nfun intersection(from: Shape, with: ShapeContour): Shape {\n    if (from.empty || with.empty) {\n        return Shape.EMPTY\n    }\n\n    return when (from.topology) {\n        ShapeTopology.CLOSED -> {\n            if (with.closed) {\n                val result = from.region2.intersection(with.ring2.region())\n                result.toShape()\n            } else {\n                return from\n            }\n        }\n        ShapeTopology.OPEN -> {\n            if (with.closed) {\n                Shape.compound(from.contours.map {\n                    intersection(it, with)\n                })\n            } else {\n                return from\n            }\n        }\n        ShapeTopology.MIXED -> {\n            if (with.closed) {\n                Shape.compound(from.splitCompounds().map {\n                    intersection(it, with)\n                })\n            } else {\n                return from\n            }\n        }\n    }\n}\n\n/**\n * Applies a boolean intersection operation between a [ShapeContour] and [Shape].\n */\nfun intersection(from: ShapeContour, with: Shape): Shape {\n    if (from.empty || with.empty) {\n        return Shape.EMPTY\n    }\n\n    return if (from.closed) {\n        val result = from.ring2.region().intersection(with.region2)\n        result.toShape()\n    } else {\n        when (with.topology) {\n            ShapeTopology.CLOSED -> {\n                val ints = with.contours.flatMap { intersections(from, it) }\n                if (ints.isNotEmpty()) {\n                    val sortedInts = ints.map { it.a.contourT }.sorted()\n                    val weldedInts = (listOf(if (sortedInts.first() > 0.0) 0.0 else null) + sortedInts + (if (sortedInts.last() < 1.0) 1.0 else null)).filterNotNull().merge { a, b ->\n                        abs(a - b) < 1E-6\n                    }\n                    val partitions = weldedInts.zipWithNext().mapNotNull {\n                        val partition = from.sub(it.first, it.second)\n                        if (partition.position(0.5) in with) {\n                            partition\n                        } else {\n                            null\n                        }\n                    }\n                    Shape(partitions)\n\n                } else {\n                    if (from.position(0.0) in with) from.shape else Shape.EMPTY\n                }\n            }\n            ShapeTopology.OPEN -> {\n                from.shape\n            }\n            ShapeTopology.MIXED -> {\n                return intersection(\n                    from,\n                    Shape(with.splitCompounds().filter { it.topology == ShapeTopology.OPEN }.flatMap { it.contours })\n                )\n            }\n        }\n    }\n}\n\n/**\n * Applies a boolean intersection operation between two [Shape]s.\n */\nfun intersection(from: Shape, with: Shape): Shape {\n    return when (from.topology) {\n        ShapeTopology.OPEN -> {\n            when (with.topology) {\n                ShapeTopology.OPEN -> from\n                ShapeTopology.CLOSED -> {\n                    Shape.compound(from.contours.map { intersection(it, with) })\n                }\n                ShapeTopology.MIXED -> {\n                    val closed = Shape(from.splitCompounds().filter { it.topology == ShapeTopology.CLOSED }\n                        .flatMap { it.contours })\n                    intersection(closed, with)\n                }\n            }\n        }\n        ShapeTopology.CLOSED -> {\n            when (with.topology) {\n                ShapeTopology.OPEN -> from\n                ShapeTopology.CLOSED -> {\n                    val result = from.region2.intersection(with.region2)\n                    result.toShape()\n                }\n                ShapeTopology.MIXED -> {\n                    val closed = Shape(from.splitCompounds().filter { it.topology == ShapeTopology.CLOSED }\n                        .flatMap { it.contours })\n                    intersection(closed, with)\n                }\n            }\n        }\n        ShapeTopology.MIXED -> {\n            val closed =\n                Shape(from.splitCompounds().filter { it.topology == ShapeTopology.CLOSED }.flatMap { it.contours })\n            val open = from.openContours\n            Shape.compound(listOf(intersection(closed, with)) + open.map { intersection(it, with) })\n        }\n    }\n}\n\n/**\n * Applies a boolean intersection operation between a [List] of [Shape]s and a [ShapeContour].\n */\nfun intersection(from: List<Shape>, with: ShapeContour): List<Shape> {\n    return from.toRegion2().intersection(with.ring2.region()).toShapes()\n}\n\n/**\n * Applies a boolean intersection operation between a [List] of [Shape]s and a [Shape].\n */\nfun intersection(from: List<Shape>, with: Shape): List<Shape> {\n    return from.toRegion2().intersection(with.region2).toShapes()\n}\n\n/**\n * Applies a boolean intersection operation between two [List]s of [Shape]s.\n */\nfun intersection(from: List<Shape>, with: List<Shape>): List<Shape> {\n    return from.toRegion2().intersection(with.toRegion2()).toShapes()\n}\n\n/**\n * Applies a boolean intersection operation iteratively between a [List] of [Shape]s and a two-dimensional [List] of [Shape]s.\n *\n * [with] is traversed and a boolean [intersection] is applied between [from] and each element.\n */\n@JvmName(\"intersectionIterative\")\nfun intersection(from: List<Shape>, with: List<List<Shape>>): List<Shape> {\n    var left = from\n    for (withShapes in with) {\n        left = intersection(left, withShapes)\n    }\n    return left\n}\n\nclass SegmentIntersection(val a: SegmentPoint, val b: SegmentPoint, val position: Vector2)\n\n/** Calculates a [List] of all points where two [Segment]s intersect. */\nfun intersections(a: Segment, b: Segment, vertexThreshold: Double = 1E-5): List<SegmentIntersection> {\n\n    if ((a.linear && a.length == 0.0) || (b.linear && b.length == 0.0)) {\n        return emptyList()\n    }\n\n\n    // Test if checking against self. This test should be improved such that it is not based on object identity\n    val selfTest = a === b\n    val ca = a.toCurve2()\n    val cb = b.toCurve2()\n\n    return if (!selfTest) {\n        Intersections.intersections(ca, cb).map {\n            val at = when {\n                it.x < vertexThreshold -> 0.0\n                it.x >= 1.0 - vertexThreshold -> 1.0\n                else -> it.x\n            }\n            val bt = when {\n                it.y < vertexThreshold -> 0.0\n                it.y >= 1.0 - vertexThreshold -> 1.0\n                else -> it.y\n            }\n            val pointA = SegmentPoint(a, at, ca.position(it.x).toVector2())\n            val pointB = SegmentPoint(b, bt, pointA.position)\n            SegmentIntersection(pointA, pointB, pointA.position)\n        }\n    } else {\n        // Here we should handle self-intersections properly\n        emptyList()\n    }\n}\n\ndata class ContourIntersection(val a: ContourPoint, val b: ContourPoint, val position: Vector2)\n\n/**\n * Calculates a [List] of all points of where paths intersect between two [ShapeContour]s.\n */\nfun intersections(a: ShapeContour, b: ShapeContour, vertexThreshold: Double = 1E-5): List<ContourIntersection> {\n    val selfTest = a === b\n    val result = mutableListOf<ContourIntersection>()\n\n    if (a.empty || b.empty) {\n        return emptyList()\n    }\n\n    val lastA = a.segments.lastIndex\n    val lastB = b.segments.lastIndex\n    // this is where we should use a sweepline approach\n    for ((ia, sa) in a.segments.withIndex()) {\n        for ((ib, sb) in b.segments.withIndex()) {\n            if (selfTest && ib > ia) {\n                continue\n            }\n            val segmentIntersections = intersections(sa, sb, vertexThreshold).let {\n                if (selfTest) {\n                    it.filterNot { intersection -> intersection.a.segmentT == 1.0 && intersection.b.segmentT == 0.0 || intersection.a.segmentT == 0.0 && intersection.b.segmentT == 1.0 }\n                } else {\n                    it\n                }\n            }\n            result.addAll(segmentIntersections.map {\n                val at = if (it.a.segmentT == 1.0 && ia != lastA) 0.0 else it.a.segmentT\n                val ai = if (it.a.segmentT == 1.0 && ia != lastA) ia + 1 else ia\n                val bt = if (it.b.segmentT == 1.0 && ib != lastB) 0.0 else it.b.segmentT\n                val bi = if (it.b.segmentT == 1.0 && ib != lastB) ib + 1 else ib\n\n                ContourIntersection(\n                    ContourPoint(a, (ai + at) / a.segments.size, a.segments[ai], at, it.position),\n                    ContourPoint(b, (bi + bt) / b.segments.size, b.segments[bi], bt, it.position),\n                    it.position\n                )\n            })\n        }\n    }\n\n\n    return result.let {\n        if (selfTest) {\n            it.distinctBy { intersection -> Pair(intersection.a.contourT.toString().take(7), intersection.b.contourT.toString().take(7)) }\n        } else {\n            it\n        }\n    }\n}\n\n/**\n * Calculates a [List] of all points of where paths intersect between the two [Shape]s.\n */\nfun intersections(a: Shape, b: Shape): List<ContourIntersection> {\n    return a.contours.flatMap { ac ->\n        b.contours.flatMap { bc ->\n            intersections(ac, bc)\n        }\n    }\n}\n\n\n/**\n * Splits a [Shape] into two separate [Shape]s from given [LineSegment].\n *\n * [LineSegment] doesn't necessarily need to cover the full length of the [Shape],\n * as it will be extended on both ends to ensure it splits the whole [Shape].\n *\n * @return A pair containing two partial [Shape]s.\n */\nfun split(shape: Shape, cutter: LineSegment): Pair<Shape, Shape> {\n    val center = (cutter.end + cutter.start) / 2.0\n    val direction = (cutter.end - cutter.start).normalized\n    val perpendicular = direction.perpendicular(shape.contours.first().polarity)\n    val extend = 50000.0\n\n    val splitLine = LineSegment(center - direction * extend, center + direction * extend)\n\n    val leftContour = shape {\n        contour {\n            moveTo(splitLine.start)\n            lineTo(cursor + perpendicular * extend)\n            lineTo(cursor + direction * extend)\n            lineTo(splitLine.end)\n            lineTo(splitLine.start)\n            close()\n        }\n    }\n\n    val rightContour = shape {\n        contour {\n            moveTo(splitLine.start)\n            lineTo(cursor - perpendicular * extend)\n            lineTo(cursor + direction * extend)\n            lineTo(splitLine.end)\n            lineTo(splitLine.start)\n            close()\n        }\n    }\n    val leftShape = difference(shape, leftContour)\n    val rightShape = difference(shape, rightContour)\n    return Pair(leftShape, rightShape)\n}\n\n/**\n * Splits a [ShapeContour] with another [ShapeContour].\n *\n * If there is no intersection, the original contour is returned.\n */\nfun split(from: ShapeContour, cutter: ShapeContour): List<ShapeContour> {\n    if (from.empty) return listOf()\n    if (cutter.empty) return listOf(from)\n\n    val ints = intersections(from, cutter)\n    return performSplit(from, ints)\n}\n\n/**\n * Splits a [ShapeContour] with all other [ShapeContour] in a [List].\n */\nfun split(from: ShapeContour, cutters: List<ShapeContour>): List<ShapeContour> {\n    if (from.empty) return listOf()\n\n    // Do `it != from` because we may want to split all org.openrndr.shape.contours\n    // in a collection at their intersections.\n    // We would iterate over each element and cut against\n    // \"all other items\". Building a collection with \"all other items\"\n    // for each item is tedious. Easier to just discard if equal.\n    val validCutters = cutters.filter { !it.empty && it != from }\n    if (validCutters.isEmpty()) return listOf(from)\n\n    val ints = validCutters.map { cutter ->\n        intersections(from, cutter)\n    }.flatten()\n\n    return performSplit(from, ints)\n}\n\n/**\n * Performs the actual ShapeContour cutting. Receive the shape to be cut\n * and a list of all the cut points.\n */\nprivate fun performSplit(from: ShapeContour, ints: List<ContourIntersection>):\n        List<ShapeContour> {\n    return if (ints.isNotEmpty()) {\n        val sortedInts = ints.map { it.a.contourT }.sorted()\n        val weldedInts = (if (from.closed) {\n            sortedInts + (if (sortedInts.first() > 0.0) 1 +\n                    sortedInts.first() else null)\n        } else {\n            listOf(if (sortedInts.first() > 0.0) 0.0 else null) +\n                    sortedInts + (if (sortedInts.last() < 1.0) 1.0 else null)\n        }).filterNotNull().merge { a, b -> abs(a - b) < 1E-6 }\n        weldedInts.zipWithNext().map { from.sub(it.first, it.second) }\n    } else {\n        listOf(from)\n    }\n}","package org.openrndr.shape\n\nimport org.openrndr.math.*\nimport kotlin.math.*\n\n/**\n * Shape builder class, used by [shape]\n */\nclass ShapeBuilder {\n    internal val contours = mutableListOf<ShapeContour>()\n\n    @Suppress(\"unused\")\n    fun boundary(f: ContourBuilder.() -> Unit) {\n        val cb = ContourBuilder(false)\n        cb.f()\n\n        val contour = cb.result.first()\n        require(contour.closed) { \"boundary org.openrndr.shape.contours must be closed\" }\n        contours.add(contour.clockwise)\n    }\n\n    @Suppress(\"unused\")\n    fun hole(f: ContourBuilder.() -> Unit) {\n        val cb = ContourBuilder(false)\n        cb.f()\n        val contour = cb.result.first()\n        require(contour.closed) { \"hole org.openrndr.shape.contours must be closed\" }\n        contours.add(contour.counterClockwise)\n    }\n\n    fun contour(f: ContourBuilder.() -> Unit) {\n        val cb = ContourBuilder(false)\n        cb.f()\n        val c = cb.result.first()\n        contours.add(if (contours.size == 0) c.clockwise else c.counterClockwise)\n    }\n}\n\n@Suppress(\"unused\")\nclass ContourBuilder(private val multipleContours: Boolean) {\n    var cursor = Vector2.INFINITY\n    var anchor = Vector2.INFINITY\n\n\n    val segments = mutableListOf<Segment>()\n\n    internal val contours = mutableListOf<ShapeContour>()\n\n\n    fun copy(source: ShapeContour, connectEpsilon: Double = 1E-6) {\n        if (this.segments.isEmpty() && !source.empty) {\n            segments.addAll(source.segments)\n            anchor = segments.first().start\n            cursor = segments.last().end\n        } else if (!source.empty) {\n            val d = cursor - source.segments.first().start\n            if (d.squaredLength > connectEpsilon * connectEpsilon) {\n                lineTo(source.segments.first().start)\n            }\n            for (segment in source.segments) {\n                segment(segment)\n            }\n        }\n    }\n\n    /**\n     * Move pen without drawing\n     * @param position coordinate to move pen to\n     */\n    fun moveTo(position: Vector2) {\n        require(multipleContours || anchor === Vector2.INFINITY) {\n            \"pen only can only be moved once per contour, use 'org.openrndr.shape.contours {}' to create multiple org.openrndr.shape.contours\"\n        }\n        if (multipleContours && segments.isNotEmpty()) {\n            contours.add(ShapeContour(segments.map { it }, false))\n            segments.clear()\n        }\n        cursor = position\n        anchor = position\n    }\n\n    /**\n     * Move the pen to the given coordinates without drawing\n     * @param x the x-coordinate\n     * @param y the y-coordinate\n     */\n    fun moveTo(x: Double, y: Double) = moveTo(Vector2(x, y))\n\n    /**\n     * Move the pen or draw a line to the given coordinates.\n     * The pen is moved without drawing when to prior moveTo instructions have been given.\n     * @param position the coordinates to move the pen to\n     */\n    @Suppress(\"unused\")\n    fun moveOrLineTo(position: Vector2) {\n        if (anchor === Vector2.INFINITY) {\n            moveTo(position)\n        } else {\n            lineTo(position)\n        }\n    }\n\n    /**\n     * Move the pen or draw a line to the given coordinates.\n     * The pen is moved without drawing when to prior moveTo instructions have been given.\n     * @param x the x-coordinate\n     * @param y the y-coordinate\n     */\n    fun moveOrLineTo(x: Double, y: Double) = moveOrLineTo(Vector2(x, y))\n\n\n    @Suppress(\"unused\")\n    fun moveOrCurveTo(control: Vector2, position: Vector2) {\n        if (anchor === Vector2.INFINITY) {\n            moveTo(position)\n        } else {\n            curveTo(control, position)\n        }\n    }\n\n    fun moveOrCurveTo(cx: Double, cy: Double, x: Double, y: Double) = moveOrCurveTo(Vector2(cx, cy), Vector2(x, y))\n\n    @Suppress(\"unused\")\n    fun moveOrCurveTo(control0: Vector2, control1: Vector2, position: Vector2) {\n        if (anchor === Vector2.INFINITY) {\n            moveTo(position)\n        } else {\n            curveTo(control0, control1, position)\n        }\n    }\n\n    fun moveOrCurveTo(c0x: Double, c0y: Double, c1x: Double, c1y: Double, x: Double, y: Double) =\n        moveOrCurveTo(Vector2(c0x, c0y), Vector2(c1x, c1y), Vector2(x, y))\n\n    /**\n     * Line to\n     */\n    fun lineTo(position: Vector2) {\n        require(cursor !== Vector2.INFINITY) {\n            \"use moveTo first\"\n        }\n        if ((position - cursor).length > 0.0) {\n            val segment = Segment(cursor, position)\n            segments.add(segment)\n            cursor = position\n        }\n    }\n\n    /**\n     * Line to\n     */\n    fun lineTo(x: Double, y: Double) = lineTo(Vector2(x, y))\n\n    /**\n     * Quadratic curve to\n     */\n    @Suppress(\"unused\")\n    fun curveTo(control: Vector2, position: Vector2) {\n        require(cursor !== Vector2.INFINITY) {\n            \"use moveTo first\"\n        }\n        if ((position - cursor).squaredLength > 0.0) {\n            val segment = Segment(cursor, control, position)\n            segments.add(segment)\n            cursor = position\n        }\n    }\n\n    /**\n     * Quadratic curve to\n     */\n    fun curveTo(cx: Double, cy: Double, x: Double, y: Double) = curveTo(Vector2(cx, cy), Vector2(x, y))\n\n    /**\n     * Cubic curve to\n     */\n    fun curveTo(control0: Vector2, control1: Vector2, position: Vector2) {\n        require(cursor !== Vector2.INFINITY) {\n            \"use moveTo first\"\n        }\n        if ((position - cursor).squaredLength > 0.0) {\n            val segment = Segment(cursor, control0, control1, position)\n            segments.add(segment)\n            cursor = position\n        }\n    }\n\n    /**\n     * Cubic curve to\n     */\n    fun curveTo(c0x: Double, c0y: Double, c1x: Double, c1y: Double, x: Double, y: Double) =\n        curveTo(Vector2(c0x, c0y), Vector2(c1x, c1y), Vector2(x, y))\n\n    /**\n     * Closes the contour, adds a line segment to `anchor` when needed\n     */\n    fun close() {\n        require(segments.isNotEmpty()) {\n            \"cannot close contour with 0 segments\"\n        }\n\n        if ((anchor - cursor).length > 0.001) {\n            segments.add(Segment(cursor, anchor))\n        }\n        contours.add(ShapeContour(segments.map { it }, true))\n        segments.clear()\n    }\n\n    /**\n     * Reverse all segments\n     */\n    fun reverse() {\n        segments.forEachIndexed { index, segment ->\n            segments[index] = segment.reverse\n        }\n        segments.reverse()\n    }\n\n\n    fun circularArcTo(through: Vector2, end: Vector2) {\n        val circle = Circle.fromPoints(cursor, through, end)\n        val side = LineSegment(cursor, end).side(through) < 0.0\n        val centerSide = LineSegment(cursor, end).side(circle.center) < 0.0\n        if (side == centerSide) {\n            arcTo(circle.radius, circle.radius, 90.0, true, side, end)\n        } else {\n            arcTo(circle.radius, circle.radius, 90.0, false, side, end)\n        }\n    }\n\n    fun arcTo(\n        crx: Double,\n        cry: Double,\n        angle: Double,\n        largeArcFlag: Boolean,\n        sweepFlag: Boolean,\n        tx: Double,\n        ty: Double\n    ) {\n        // based on https://github.com/BigBadaboom/androidsvg/blob/master/androidsvg/src/main/java/com/caverock/androidsvg/SVGAndroidRenderer.java\n\n        require(cursor !== Vector2.INFINITY) {\n            \"use moveTo first\"\n        }\n\n        val angleRad = (angle.mod(360.0)).asRadians\n\n        val tdx = cursor.x - tx\n        val tdy = cursor.y - ty\n\n        if (tdx * tdx + tdy * tdy == 0.0) {\n            return\n        }\n        val radiiEpsilon = 10E-6\n\n        if (abs(crx) <= radiiEpsilon || abs(cry) <= radiiEpsilon) {\n            lineTo(Vector2(tx, ty))\n            return\n        }\n\n        var rx = abs(crx)\n        var ry = abs(cry)\n\n        val cosAngle = cos(angleRad)\n        val sinAngle = sin(angleRad)\n\n        val dx2 = (cursor.x - tx) / 2.0\n        val dy2 = (cursor.y - ty) / 2.0\n\n        val x1 = cosAngle * dx2 + sinAngle * dy2\n        val y1 = -sinAngle * dx2 + cosAngle * dy2\n\n        val rxSqr = rx * rx\n        val rySqr = ry * ry\n\n        val y1Sqr = y1 * y1\n        val x1Sqr = x1 * x1\n\n        val radiiCheck = ((x1 * x1) / (rx * rx)) + ((y1 * y1) / (ry * ry))\n        if (radiiCheck > 1) {\n            rx *= sqrt(radiiCheck)\n            ry *= sqrt(radiiCheck)\n        }\n\n        // Step 2 : Compute (cx1, cy1) - the transformed centre point\n        val sign0 = if (largeArcFlag == sweepFlag) -1.0 else 1.0\n        var sq = (rxSqr * rySqr - rxSqr * y1Sqr - rySqr * x1Sqr) / (rxSqr * y1Sqr + rySqr * x1Sqr)\n        sq = if (sq < 0) 0.0 else sq\n        val coefficient = sign0 * sqrt(sq)\n        val cx1 = coefficient * (rx * y1 / ry)\n        val cy1 = coefficient * -(ry * x1 / rx)\n\n        // Step 3 : Compute (cx, cy) from (cx1, cy1)\n        val sx2 = (cursor.x + tx) / 2.0\n        val sy2 = (cursor.y + ty) / 2.0\n        val cx = sx2 + (cosAngle * cx1 - sinAngle * cy1)\n        val cy = sy2 + (sinAngle * cx1 + cosAngle * cy1)\n\n        // Step 4 : Compute the angleStart (angle1) and the angleExtent (dangle)\n        val ux = (x1 - cx1) / rx\n        val uy = (y1 - cy1) / ry\n        val vx = (-x1 - cx1) / rx\n        val vy = (-y1 - cy1) / ry\n\n        // Compute the angle start\n        val n0 = sqrt(ux * ux + uy * uy)\n        //val p0 = (1 * ux) + (0 * uy)\n        val sign1 = if (uy < 0) -1.0 else 1.0\n        var angleStart = sign1 * acos(ux / n0) // ux was p0\n\n        // Compute the angle extent\n        val n1 = sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy))\n        val p1 = ux * vx + uy * vy\n        val sign2 = if (ux * vy - uy * vx < 0) -1.0 else 1.0\n\n        fun checkedACos(v: Double): Double {\n            return when {\n                v < -1.0 -> PI\n                v > 1.0 -> 0.0\n                else -> acos(v)\n            }\n        }\n\n        var angleExtent = sign2 * checkedACos(p1 / n1)\n\n        if (angleExtent == 0.0) {\n            lineTo(tx, ty)\n            return\n        }\n\n        if (!sweepFlag && angleExtent > 0) {\n            angleExtent -= PI * 2\n        } else if (sweepFlag && angleExtent < 0) {\n            angleExtent += PI * 2\n        }\n        angleExtent %= PI * 2\n        angleStart %= PI * 2\n\n        val bezierPoints = arcToBeziers(angleStart, angleExtent)\n        if (bezierPoints.isEmpty()) {\n            return\n        }\n\n        bezierPoints[bezierPoints.lastIndex] = Vector2(tx, ty)\n\n        for (i in bezierPoints.indices) {\n            val x = bezierPoints[i].x\n            val y = bezierPoints[i].y\n            bezierPoints[i] = Vector2(\n                cosAngle * rx * x + -sinAngle * ry * y + cx,\n                sinAngle * rx * x + cosAngle * ry * y + cy\n            )\n        }\n\n        if (bezierPoints.isNotEmpty()) {\n            bezierPoints[bezierPoints.size - 1] = Vector2(tx, ty)\n            var i = 0\n            while (i < bezierPoints.size) {\n                try {\n                    curveTo(bezierPoints[i], bezierPoints[i + 1], bezierPoints[i + 2])\n                } catch (e: IllegalArgumentException) {\n                    error(\"radii: $crx $cry, deltas: $tdx $tdy [$i] ${bezierPoints[i]}, ${bezierPoints[i + 1]}, ${bezierPoints[i + 2]}\")\n                }\n                i += 3\n            }\n        }\n\n        cursor = Vector2(tx, ty)\n    }\n\n    fun arcTo(crx: Double, cry: Double, angle: Double, largeArcFlag: Boolean, sweepFlag: Boolean, end: Vector2) =\n        arcTo(crx, cry, angle, largeArcFlag, sweepFlag, end.x, end.y)\n\n    fun continueTo(end: Vector2, tangentScale: Double = 1.0) {\n        if ((cursor - end).squaredLength > 0.0) {\n            if (segments.isNotEmpty() && segments.last().control.isNotEmpty()) {\n                val last = segments.last()\n                val delta = last.control.last() - last.end\n                curveTo(last.end - delta * tangentScale, end)\n            } else {\n                curveTo(cursor + (end - cursor) / 2.0, end)\n            }\n        }\n    }\n\n    fun continueTo(x: Double, y: Double, tangentScale: Double = 1.0) = continueTo(Vector2(x, y), tangentScale)\n\n    @Suppress(\"unused\")\n    fun continueTo(control: Vector2, end: Vector2, tangentScale: Double = 1.0) {\n        if (segments.isNotEmpty() && segments.last().control.isNotEmpty()) {\n            val last = segments.last()\n            val delta = last.control.last() - last.end\n            curveTo(last.end - delta * tangentScale, control, end)\n        } else {\n            curveTo(cursor + (end - cursor) / 3.0, control, end)\n        }\n    }\n\n    fun continueTo(cx: Double, cy: Double, x: Double, y: Double, tangentScale: Double = 1.0) =\n        continueTo(Vector2(cx, cy), Vector2(x, y), tangentScale)\n\n    private fun arcToBeziers(angleStart: Double, angleExtent: Double): Array<Vector2> {\n        val numSegments = ceil(abs(angleExtent) * 2.0 / PI).toInt()\n        val angleIncrement = (angleExtent / numSegments)\n\n        // The length of each control point vector is given by the following formula.\n        val controlLength = 4.0 / 3.0 * sin(angleIncrement / 2.0) / (1.0 + cos(angleIncrement / 2.0))\n\n        val coordinates = Array(numSegments * 3) { Vector2.ZERO }\n        var pos = 0\n\n        for (i in 0 until numSegments) {\n            var angle = angleStart + i * angleIncrement\n            // Calculate the control vector at this angle\n            var dx = cos(angle)\n            var dy = sin(angle)\n            // First control point\n            coordinates[pos] = Vector2(dx - controlLength * dy, dy + controlLength * dx)\n            pos++\n            // Second control point\n            angle += angleIncrement\n            dx = cos(angle)\n            dy = sin(angle)\n            coordinates[pos] = Vector2(dx + controlLength * dy, dy - controlLength * dx)\n            pos++\n            // Endpoint of bezier\n            coordinates[pos] = Vector2(dx, dy)\n            pos++\n        }\n        return coordinates\n    }\n\n    fun segment(segment: Segment) {\n        if (cursor !== Vector2.INFINITY) {\n            require((segment.start - cursor).length < 10E-3) {\n                \"segment is disconnected: cursor: ${cursor}, segment.start: ${segment.start}, distance: ${(cursor - segment.start).length}\"\n            }\n        }\n        if (cursor === Vector2.INFINITY) {\n            moveTo(segment.start)\n        }\n\n        if (segment.linear) {\n            lineTo(segment.end)\n        } else {\n            if (segment.control.size == 1) {\n                curveTo(segment.control[0], segment.end)\n            } else {\n                curveTo(segment.control[0], segment.control[1], segment.end)\n            }\n        }\n    }\n\n    fun undo(): Segment? {\n        return if (segments.isNotEmpty()) {\n            val r = segments.removeAt(segments.lastIndex)\n            cursor = r.start\n            r\n        } else {\n            null\n        }\n    }\n\n    val lastSegment: Segment?\n        get() = segments.lastOrNull()\n\n\n    val result: List<ShapeContour>\n        get() {\n            return contours + if (segments.isNotEmpty()) listOf(\n                ShapeContour(\n                    segments.map { it },\n                    false\n                )\n            ) else emptyList()\n        }\n}\n\n\n/**\n * Build a shape\n */\nfun shape(f: ShapeBuilder.() -> Unit): Shape {\n    val sb = ShapeBuilder()\n    sb.f()\n    return Shape(sb.contours)\n}\n\n/**\n * Build a contour\n */\nfun contour(f: ContourBuilder.() -> Unit): ShapeContour {\n    val cb = ContourBuilder(false)\n    cb.f()\n    return if (cb.result.isEmpty()) {\n        ShapeContour.EMPTY\n    } else {\n        cb.result.first()\n    }\n}\n\n/**\n * Build multiple org.openrndr.shape.contours\n */\nfun contours(f: ContourBuilder.() -> Unit): List<ShapeContour> {\n    val clb = ContourBuilder(true)\n    clb.f()\n    return clb.result\n}\n","package org.openrndr.shape\n\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.Transient\nimport org.openrndr.kartifex.Path2\nimport org.openrndr.kartifex.Ring2\nimport org.openrndr.math.*\nimport org.openrndr.utils.resettableLazy\nimport kotlin.jvm.JvmOverloads\nimport kotlin.math.abs\nimport kotlin.math.min\n\nprivate const val subEpsilon = 1E-6\nprivate const val closeEpsilon = 1E-6\nprivate const val consecutiveEpsilon = 1E-6\n\n/**\n * A [List] for managing a collection of [Segment]s.\n */\n@Serializable\ndata class ShapeContour @JvmOverloads constructor(\n    val segments: List<Segment>,\n    val closed: Boolean,\n    val polarity: YPolarity = YPolarity.CW_NEGATIVE_Y\n) : ShapeProvider, ShapeContourProvider {\n    companion object {\n        /**\n         * An empty [ShapeContour] object.\n         *\n         * It is advised to use this instance whenever an empty contour is needed.\n         */\n        val EMPTY: ShapeContour = ShapeContour(emptyList(), false)\n\n        @JvmOverloads\n        fun fromSegments(\n            segments: List<Segment>,\n            closed: Boolean,\n            polarity: YPolarity = YPolarity.CW_NEGATIVE_Y,\n            distanceTolerance: Double = 1E-3,\n        ): ShapeContour {\n            if (segments.isEmpty()) {\n                return EMPTY\n            }\n            return ShapeContour(\n                segments.zipWithNext().map {\n                    val distance = it.first.end.squaredDistanceTo(it.second.start)\n                    require(distance < distanceTolerance) {\n                        \"distance between segment end and start is $distance (max: $distanceTolerance)\"\n                    }\n                    it.first.copy(end = it.second.start)\n                } + segments.last(), closed, polarity\n            )\n        }\n\n        /** Creates a [ShapeContour] by converting [points] to [Segment]s. */\n        @JvmOverloads\n        fun fromPoints(\n            points: List<Vector2>,\n            closed: Boolean,\n            polarity: YPolarity = YPolarity.CW_NEGATIVE_Y\n        ): ShapeContour = if (points.isEmpty()) {\n            EMPTY\n        } else {\n            if (!closed) {\n                ShapeContour((0 until points.size - 1).map {\n                    Segment(\n                        points[it],\n                        points[it + 1]\n                    )\n                }, closed, polarity)\n            } else {\n                val d = (points.last() - points.first()).squaredLength\n                val usePoints = if (d > closeEpsilon) points else points.dropLast(1)\n                ShapeContour((usePoints.indices).map {\n                    Segment(\n                        usePoints[it],\n                        usePoints[(it + 1) % usePoints.size]\n                    )\n                }, true, polarity)\n            }\n        }\n    }\n\n    init {\n        segments.zipWithNext().forEach {\n            val d = (it.first.end - it.second.start).length\n            require(d < consecutiveEpsilon) {\n                \"points are too far away from each other ${it.first.end} ${it.second.start} $d\"\n            }\n        }\n    }\n\n    /** Returns [Shape] representation. */\n    override val shape: Shape get() = Shape(listOf(this))\n\n    /** Calculates approximate Euclidean length of the contour. */\n    val length by lazy { segments.sumOf { it.length } }\n\n    /** Calculates the bounding box of the contour as [Rectangle]. */\n    val bounds by lazy {\n        sampleLinear().segments.flatMap {\n            listOf(\n                it.start,\n                it.end\n            )\n        }.bounds\n    }\n\n    /** Determines the winding order of the [ShapeContour]. */\n    val winding: Winding by lazy {\n        var sum = 0.0\n        segments.forEach { s ->\n            (listOf(s.start) + s.control + listOf(s.end)).zipWithNext { a, b ->\n                sum += (b.x - a.x) * (b.y + a.y)\n            }\n        }\n        val start = segments.first().start\n        val end = segments.last().end\n        sum += (start.x - end.x) * (start.y + end.y)\n        when (polarity) {\n            YPolarity.CCW_POSITIVE_Y -> if (sum < 0) {\n                Winding.COUNTER_CLOCKWISE\n            } else {\n                Winding.CLOCKWISE\n            }\n\n            YPolarity.CW_NEGATIVE_Y -> if (sum < 0) {\n                Winding.CLOCKWISE\n            } else {\n                Winding.COUNTER_CLOCKWISE\n            }\n        }\n    }\n\n\n    /** Converts to a [List] of single [Segment]s. */\n    @Suppress(\"unused\")\n    val exploded: List<ShapeContour>\n        get() = segments.map { ShapeContour(listOf(it), false, polarity) }\n\n    /** Returns the [ShapeContour], but with a clockwise winding. */\n    val clockwise: ShapeContour get() = if (winding == Winding.CLOCKWISE) this else this.reversed\n\n    /** Returns the [ShapeContour], but with a counterclockwise winding. */\n    val counterClockwise: ShapeContour get() = if (winding == Winding.COUNTER_CLOCKWISE) this else this.reversed\n\n    operator fun plus(other: ShapeContour): ShapeContour {\n        require(polarity == other.polarity) {\n            \"\"\"shapes have mixed polarities\"\"\"\n        }\n        if (segments.isEmpty() && other.segments.isEmpty()) {\n            return EMPTY\n        } else {\n            if (segments.isEmpty()) {\n                return other\n            }\n            if (other.segments.isEmpty()) {\n                return this\n            }\n        }\n        val segments = mutableListOf<Segment>()\n        segments.addAll(this.segments)\n        if ((this.segments[this.segments.size - 1].end - other.segments[0].start).length > consecutiveEpsilon) {\n            segments.add(\n                Segment(\n                    this.segments[this.segments.size - 1].end,\n                    other.segments[0].start\n                )\n            )\n        }\n        segments.addAll(other.segments)\n        return ShapeContour(segments, false, polarity)\n    }\n\n    /**\n     * Estimates the [t](https://pomax.github.io/bezierinfo/#explanation) value for a given length.\n     *\n     * @return The value of *t* between `0.0` and `1.0`.\n     */\n    @Suppress(\"unused\")\n    fun tForLength(length: Double): Double {\n        var remaining = length\n        if (length <= 0.0) {\n            return 0.0\n        }\n        if (segments.size == 1) {\n            return segments.first().tForLength(length)\n        }\n        for ((index, segment) in segments.withIndex()) {\n            val segmentLength = segment.length\n            if (segmentLength > remaining) {\n                return (segment.tForLength(remaining) + index) / segments.size\n            } else {\n                remaining -= segmentLength\n            }\n        }\n        return 1.0\n    }\n\n    /**\n     * Calculates the point at a given distance along this [ShapeContour].\n     * @param length the distance along the [ShapeContour]\n     * @param distanceTolerance the tolerance used for simplifying the [ShapeContour], lower values\n     * result in more accurate results, but slower calculation\n     *\n     * @return Resulting [Vector2] or [Vector2.INFINITY] for an empty [ShapeContour].\n     *\n     * @see [Segment.pointAtLength]\n     */\n    fun pointAtLength(length: Double, distanceTolerance: Double = 0.5): Vector2 {\n        when {\n            empty -> return Vector2.INFINITY\n            length <= 0.0 -> return segments.first().start\n            length >= this.length -> return segments.last().end\n        }\n        var remainingLength = length\n        for (segment in segments) {\n            val segmentLength = segment.length\n            if (segmentLength > remainingLength) {\n                return segment.pointAtLength(remainingLength, distanceTolerance)\n            }\n            remainingLength -= segmentLength\n        }\n        return segments.last().end\n    }\n\n    /** Returns true if [ShapeContour] doesn't contain any [Segment]s. */\n    val empty: Boolean\n        get() {\n            return this === EMPTY || segments.isEmpty()\n        }\n\n    /**\n     * Returns a point on the path of the [ShapeContour].\n     *\n     * To make the computation easier in the presence of non-linear Segments,\n     * the result is derived first from the corresponding Segment in the ShapeContour,\n     * and then within that Segment.\n     *\n     * For example, if the ShapeContour is composed of 10 Segments, asking for position ut=0.03\n     * will return the point 30% of the along the 1st Segment, and ut=0.51 will return the point\n     * 10% of the along the 6th.\n     *\n     *\n     * If the component Segments are of wildly different lengths, the resulting point can be very\n     * different from what would be arrived at if the ShapeContour were treated strictly as a whole.\n     * In that case, consider using [ShapeContour.equidistantPositions] instead.\n     *\n     * Also see: [Segment.position].\n     *\n     * @param ut unfiltered t parameter, will be clamped between 0.0 and 1.0.\n     * @return [Vector2] that lies on the path of the [ShapeContour].\n     */\n    fun position(ut: Double): Vector2 {\n        if (empty) {\n            return Vector2.INFINITY\n        }\n\n        return when (val t = ut.coerceIn(0.0, 1.0)) {\n            0.0 -> segments[0].start\n            1.0 -> segments.last().end\n            else -> {\n                val (segment, segmentOffset) = segment(t)\n                segments[segment].position(segmentOffset)\n            }\n        }\n    }\n\n    /**\n     * Calculates the normal for the given [ut].\n     *\n     * @param ut unfiltered t parameter, will be clamped between 0.0 and 1.0.  The treatment of\n     * ut is as in [ShapeContour.position].\n     */\n    fun normal(ut: Double): Vector2 {\n        if (empty) {\n            return Vector2.ZERO\n        }\n\n        return when (val t = ut.coerceIn(0.0, 1.0)) {\n            0.0 -> segments[0].normal(0.0, polarity)\n            1.0 -> segments.last().normal(1.0, polarity)\n            else -> {\n                val (segment, segmentOffset) = segment(t)\n                segments[segment].normal(segmentOffset, polarity)\n            }\n        }\n    }\n\n    /**\n     * Returns segment number and segment offset\n     * in a [ShapeContour] for the given [ut].\n     * @param ut unfiltered t parameter, will be clamped between 0.0 and 1.0.\n     */\n    fun segment(ut: Double): Pair<Int, Double> {\n        if (empty) {\n            return Pair(0, 0.0)\n        }\n\n        return when (val t = ut.coerceIn(0.0, 1.0)) {\n            0.0 -> Pair(0, 0.0)\n            1.0 -> Pair(segments.size - 1, 1.0)\n            else -> {\n                val segment = (t * segments.size).toInt()\n                val segmentOffset = (t * segments.size) - segment\n                return Pair(segment, segmentOffset)\n            }\n        }\n    }\n\n\n    /**\n     * Calculates the pose [Matrix44] (i.e. translation and rotation) that describes an orthonormal basis\n     * formed by normal and tangent of the contour at [t](https://pomax.github.io/bezierinfo/#explanation).\n     *\n     * Which means it returns a [Matrix44],\n     * that you can use to orient an object\n     * the same way the curve is oriented at\n     * given value of *t*.\n     *\n     * @param t The value of t in the range of `0.0` to `1.0` at which to return the pose at.\n     */\n    @Suppress(\"unused\")\n    fun pose(t: Double): Matrix44 {\n        val n = normal(t)\n        val dx = n.perpendicular(polarity).xy0.xyz0\n        val dy = n.xy0.xyz0\n        val dt = position(t).xy01\n        return Matrix44.fromColumnVectors(dx, dy, Vector4.UNIT_Z, dt)\n    }\n\n    /**\n     * Recursively subdivides linear [Segment]s to approximate Bézier curves.\n     *\n     * Works similar to [adaptivePositionsAndCorners] but it only returns\n     * the positions without the corners.\n     */\n    fun adaptivePositions(distanceTolerance: Double = 0.5): List<Vector2> {\n        return adaptivePositionsAndCorners(distanceTolerance).first\n    }\n\n    fun adaptivePositionsWithT(distanceTolerance: Double = 0.5): List<Pair<Vector2, Double>> {\n        val adaptivePoints = mutableListOf<Pair<Vector2, Double>>()\n        val segmentCount = segments.size\n        for ((segmentIndex, segment) in this.segments.withIndex()) {\n            val samples = segment.adaptivePositionsWithT(distanceTolerance)\n            samples.forEach {\n                val last = adaptivePoints.lastOrNull()\n                if (last == null || last.first.squaredDistanceTo(it.first) > 0.0) {\n                    adaptivePoints.add(it.copy(second = (it.second + segmentIndex) / segmentCount))\n                }\n            }\n        }\n        return adaptivePoints\n    }\n\n    /**\n     * Recursively subdivides linear [Segment]s to approximate Bézier curves.\n     *\n     * Also see [Segment.adaptivePositions].\n     *\n     * @param distanceTolerance The square of the maximal distance of each point from curve.\n     * @return A pair containing a list of points and a list of\n     * respective boolean values for each point, indicating if the point is on a [Segment] boundary or not.\n     */\n    fun adaptivePositionsAndCorners(distanceTolerance: Double = 0.5): Pair<List<Vector2>, List<Boolean>> {\n        if (empty) {\n            return Pair(emptyList(), emptyList())\n        }\n\n        val adaptivePoints = mutableListOf<Vector2>()\n        val corners = mutableListOf<Boolean>()\n        for (segment in this.segments) {\n            val samples = segment.adaptivePositions(distanceTolerance)\n            val lastSampleIndex = samples.size - 1\n            samples.forEachIndexed { index, it ->\n                val last = adaptivePoints.lastOrNull()\n                if (last == null || last.squaredDistanceTo(it) > 0.0) {\n                    adaptivePoints.add(it)\n                    if (index == 0 || index == lastSampleIndex) {\n                        corners.add(segment.corner)\n                    } else {\n                        corners.add(false)\n                    }\n                }\n            }\n        }\n        return Pair(adaptivePoints, corners)\n    }\n\n\n    /**\n     * Returns specified amount of points of equal distance from each other.\n     */\n    fun equidistantPositions(pointCount: Int, distanceTolerance: Double = 0.5) =\n        if (empty) {\n            emptyList()\n        } else {\n            sampleEquidistant(\n                adaptivePositions(distanceTolerance),\n                pointCount + if (closed) 1 else 0\n            ).take(pointCount)\n        }\n\n    fun equidistantPositionsWithT(pointCount: Int, distanceTolerance: Double = 0.5) =\n        if (empty) {\n            emptyList()\n        } else {\n            sampleEquidistantWithT(\n                adaptivePositionsWithT(distanceTolerance),\n                pointCount + if (closed) 1 else 0\n            ).take(pointCount)\n        }\n\n    /**\n     * Adaptively samples the contour into a new [ShapeContour] of\n     * [linear][SegmentType.LINEAR] [Segment]s while still approximating the original contour.\n     *\n     * @param distanceTolerance Controls the precision of the approximation, higher values result in lower accuracy.\n     * @return A [ShapeContour] composed of linear [Segment]s\n     */\n    fun sampleLinear(distanceTolerance: Double = 0.5) =\n        if (empty) {\n            EMPTY\n        } else {\n            fromPoints(adaptivePositions(distanceTolerance), closed, polarity)\n        }\n\n    /** Samples the [ShapeContour] into equidistant linear [Segment]s. */\n    fun sampleEquidistant(pointCount: Int) =\n        if (empty) {\n            EMPTY\n        } else {\n            fromPoints(equidistantPositions(pointCount.coerceAtLeast(2)), closed, polarity)\n        }\n\n    /** Applies linear transformation to [ShapeContour]. */\n    fun transform(transform: Matrix44) =\n        if (empty) {\n            EMPTY\n        } else {\n            if (transform === Matrix44.IDENTITY) {\n                this\n            } else {\n                ShapeContour(\n                    segments.map { it.transform(transform) },\n                    closed,\n                    polarity\n                )\n            }\n        }\n\n\n    /**\n     * Samples a new [ShapeContour] from the current [ShapeContour] starting at [t0] and ending at [t1].\n     *\n     * @param t0 Starting point in range `0.0` to less than `1.0`.\n     * @param t1 Ending point in range `0.0` to less than `1.0`.\n     * @return Subcontour\n     */\n    fun sub(t0: Double, t1: Double): ShapeContour {\n        if (empty) {\n            return EMPTY\n        }\n\n        require(t0 == t0) { \"t0 is NaN\" }\n        require(t1 == t1) { \"t1 is NaN\" }\n\n        if (abs(t0 - t1) < subEpsilon) {\n            return EMPTY\n        }\n\n        var u0 = t0\n        var u1 = t1\n\n        if (closed && (u1 < u0 || u1 > 1.0 || u0 > 1.0 || u0 < 0.0 || u1 < 0.0)) {\n            val diff = u1 - u0\n            u0 = mod(u0, 1.0)\n            if (abs(diff) < (1.0 - subEpsilon)) {\n                return if (diff > 0.0) {\n                    u1 = u0 + diff\n                    if (u1 > 1.0) {\n                        sub(u0, 1.0) + sub(0.0, u1 - 1.0)\n                    } else {\n                        sub(u0, u1)\n                    }\n                } else {\n                    u1 = u0 + diff\n                    if (u1 < 0) {\n                        sub(u1 + 1.0, 1.0) + sub(0.0, u0)\n                    } else {\n                        sub(u1, u0)\n                    }\n                }\n            } else {\n                u1 = if (diff < 0.0) {\n                    u0 - 1.0\n                } else {\n                    u0 + 1.0\n                }\n                if (u1 > 1.0) {\n                    return sub(u0, 1.0) + sub(0.0, u1 - 1.0)\n                }\n                if (u1 < 1.0) {\n                    return sub(u0, 1.0) + sub(0.0, u1 + 1.0)\n                }\n            }\n        }\n\n        u0 = u0.coerceIn(0.0, 1.0)\n        u1 = u1.coerceIn(0.0, 1.0)\n\n        var z0 = u0\n        var z1 = u1\n\n        if (u0 > u1) {\n            z0 = u1\n            z1 = u0\n        }\n\n        val length = segments.size.toDouble()\n        var segment0 = (z0 * length).toInt()\n        val segmentOffset0 = if (segment0 < segments.size) z0 * length % 1.0 else 1.0\n        var segment1 = (z1 * length).toInt()\n        val segmentOffset1 = if (segment1 < segments.size) z1 * length % 1.0 else 1.0\n\n        segment1 = min(segments.size - 1, segment1)\n        segment0 = min(segments.size - 1, segment0)\n\n        val newSegments = mutableListOf<Segment>()\n\n        for (s in segment0..segment1) {\n            if (s == segment0 && s == segment1) {\n                //if (Math.abs(segmentOffset0-segmentOffset1) > epsilon)\n                newSegments.add(segments[s].sub(segmentOffset0, segmentOffset1))\n            } else if (s == segment0) {\n                if (segmentOffset0 < 1.0 - subEpsilon)\n                    newSegments.add(segments[s].sub(segmentOffset0, 1.0))\n            } else if (s == segment1) {\n                if (segmentOffset1 > subEpsilon)\n                    newSegments.add(segments[s].sub(0.0, segmentOffset1))\n            } else {\n                newSegments.add(segments[s])\n            }\n        }\n        return ShapeContour(newSegments, false, polarity)\n    }\n\n    /**\n     * Checks if given point lies on the path of the [ShapeContour].\n     *\n     * @param point The point to check.\n     * @param error Maximum acceptable margin for error.\n     * @return The contour parameter in the range 0 to less than 1 (inclusive of 0, but not 1) only if the point is within the margin of error.\n     *      Otherwise `null` will be returned.\n     */\n    fun on(point: Vector2, error: Double = 5.0): Double? {\n        for (i in segments.indices) {\n            val st = segments[i].on(point, error)\n            if (st != null) {\n                return (i + st) / segments.size\n            }\n        }\n        return null\n    }\n\n    /**\n     * Projects a point on the [ShapeContour]\n     * @param point The point to project.\n     * @return a projected point that lies on the [ShapeContour].\n     */\n    fun nearest(point: Vector2): ContourPoint {\n        val n = segments.map { it.nearest(point) }.minByOrNull { it.position.distanceTo(point) }\n            ?: error(\"no segments\")\n        val segmentIndex = segments.indexOf(n.segment)\n        val t = (segmentIndex + n.segmentT) / segments.size\n        return ContourPoint(this, t, n.segment, n.segmentT, n.position)\n    }\n\n\n    /**\n     * Opens the path of the [ShapeContour].\n     */\n    val open\n        get() : ShapeContour = if (empty) EMPTY else\n            ShapeContour(segments, false, polarity)\n\n    /**\n     * Closes the path of the [ShapeContour].\n     *\n     * The path is closed by creating a new connecting [Segment]\n     * between the first and last [Segment] in the contour.\n     * If the distance between the beginning of the first and the finish of the last point is negligible (`<0.001`),\n     * then no new [Segment]s are added.\n     */\n    fun close() = if (empty) EMPTY else {\n        if ((segments.last().end - segments.first().start).squaredLength < closeEpsilon)\n            ShapeContour(segments, true, polarity)\n        else\n            ShapeContour(\n                segments + Segment(\n                    segments.last().end,\n                    segments.first().start\n                ), true, polarity\n            )\n    }\n\n    /**\n     * Reverses the direction of [Segment]s and their order.\n     *\n     * For more information, see [Segment.reverse].\n     */\n    val reversed\n        get():ShapeContour = ShapeContour(\n            segments.map { it.reverse }.reversed(),\n            closed,\n            polarity\n        )\n    override val contour: ShapeContour\n        get() = this\n\n    @Transient\n    private val path2Delegate = resettableLazy {\n        Path2(segments.map { it.toCurve2() })\n    }\n\n    internal val path2 by path2Delegate\n\n    @Transient\n    private val ring2Delegate = resettableLazy {\n        Ring2(segments.map { it.toCurve2() })\n    }\n\n    internal val ring2 by ring2Delegate\n\n    fun resetCache() {\n        path2Delegate.reset()\n        ring2Delegate.reset()\n    }\n}\n\n/**\n * Converts a [List] of [ShapeContour]s to a single [Shape].\n */\nval List<ShapeContour>.shape\n    get() = Shape(this)\n\n","package org.openrndr.shape\n\nimport org.openrndr.math.Vector2\n\n/**\n * Representation of a point on a [Segment].\n *\n * @param segment The [Segment] on which the point lies.\n * @param segmentT The [t](https://pomax.github.io/bezierinfo/#explanation) value of the point on the [Segment].\n * @param position The position of the point.\n */\ndata class SegmentPoint(\n    val segment: Segment,\n    val segmentT: Double,\n    val position: Vector2\n)\n\n/**\n * Representation of a point on a [ShapeContour].\n *\n * @param contour The [ShapeContour] on which the point lies.\n * @param contourT The [t](https://pomax.github.io/bezierinfo/#explanation) value of the point on the [ShapeContour] in the range of `0.0` to `1.0`.\n * @param segment The [Segment] on which the point lies.\n * @param segmentT The *t* value of the point on the [Segment] in the range of `0.0` to `1.0`.\n * @param position The position of the point.\n */\ndata class ContourPoint(\n    val contour: ShapeContour,\n    val contourT: Double,\n    val segment: Segment,\n    val segmentT: Double,\n    val position: Vector2\n)\n\n/** Indicates the type of [Segment]. */\nenum class SegmentType {\n    /** A simple [Segment] with two anchor points. */\n    LINEAR,\n\n    /** A quadratic Bézier curve [Segment] with two anchor points and one control point. */\n    QUADRATIC,\n\n    /** A cubic Bézier curve [Segment] with two anchor points and two control points. */\n    CUBIC\n}\n\n/** Indicates the winding order of the [ShapeContour]. */\nenum class Winding {\n    CLOCKWISE,\n    COUNTER_CLOCKWISE\n}\n\nenum class SegmentJoin {\n    ROUND,\n    MITER,\n    BEVEL\n}\n\n/** Indicates the [Shape] topology. */\nenum class ShapeTopology {\n    /** The [Shape] consists entirely of closed [ShapeContour]s. */\n    CLOSED,\n\n    /** The [Shape] consists entirely of open [ShapeContour]s. */\n    OPEN,\n\n    /** The [Shape] contains both open and closed [ShapeContour]s. */\n    MIXED\n}","package org.openrndr.shape\n\nimport org.openrndr.math.EuclideanVector\nimport org.openrndr.math.LinearType\nimport org.openrndr.utils.tuples.Quadruple\n\nimport kotlin.jvm.JvmName\nimport kotlin.math.roundToInt\n\n@JvmName(\"proportionalizeWithoutT\")\nfun <T : EuclideanVector<T>> proportionalize(input: List<T>): List<Pair<T, Double>> {\n    return proportionalize(input.map { Pair(it, 0.0) })\n}\n\nfun <T : EuclideanVector<T>> proportionalize(input: List<Pair<T, Double>>): List<Pair<T, Double>> {\n    val lengths = mutableListOf<Double>()\n    var sum = 0.0\n    for (i in input.indices) {\n        if (i > 0) {\n            sum += input[i].first.distanceTo(input[i - 1].first)\n        }\n        lengths.add(sum)\n    }\n    for (i in lengths.indices) {\n        lengths[i] /= sum\n    }\n\n    return (lengths.indices).map { i ->\n        Pair(input[i].first, lengths[i])\n    }\n}\n\n@JvmName(\"resampleList\")\nfun <T : LinearType<T>> resample(input: List<Pair<T, Double>>, ts: List<Double>): List<Pair<T, Double>> {\n    val result = mutableListOf<Pair<T, Double>>()\n    var index = 0\n    for (t in ts) {\n        while (index < input.size && input[index].second < t) {\n            index++\n        }\n        val i1 = index.coerceIn(input.indices)\n        val i0 = (index - 1).coerceIn(input.indices)\n\n        val v: T = if (i0 == i1) {\n            input[i0].first\n        } else {\n            val t0 = t - input[i0].second\n            val dt = input[i1].second - input[i0].second\n            val f = t0 / dt\n            val v0 = input[i0].first\n            val v1 = input[i1].first\n            v0 * (1.0 - f) + v1 * f\n        }\n        result.add(Pair(v, t))\n    }\n    return result\n}\n\nprivate fun gatherTs(vararg input: List<Pair<LinearType<*>, Double>>): List<Double> {\n    return input.flatMap { l -> l.map { it.second } }.distinct().sorted()\n}\n\nfun <T1 : LinearType<T1>, T2 : LinearType<T2>> resample(\n    input1: List<Pair<T1, Double>>,\n    input2: List<Pair<T2, Double>>\n): List<Triple<T1, T2, Double>> {\n    val ts = gatherTs(input1, input2)\n\n    val resampled1 = resample(input1, ts)\n    val resampled2 = resample(input2, ts)\n\n    val result = mutableListOf<Triple<T1, T2, Double>>()\n    for (i in ts.indices) {\n        result.add(Triple(resampled1[i].first, resampled2[i].first, ts[i]))\n    }\n    return result\n}\n\nfun <T1 : LinearType<T1>, T2 : LinearType<T2>, T3 : LinearType<T3>> resample(\n    input1: List<Pair<T1, Double>>,\n    input2: List<Pair<T2, Double>>,\n    input3: List<Pair<T3, Double>>\n): List<Quadruple<T1, T2, T3, Double>> {\n    val ts = gatherTs(input1, input2, input3)\n\n    val resampled1 = resample(input1, ts)\n    val resampled2 = resample(input2, ts)\n    val resampled3 = resample(input3, ts)\n\n    val result = mutableListOf<Quadruple<T1, T2, T3, Double>>()\n    for (i in ts.indices) {\n        result.add(Quadruple(resampled1[i].first, resampled2[i].first, resampled3[i].first, ts[i]))\n    }\n    return result\n}\n\n\n/** Returns specified amount of points of equal distance from each other. */\nfun <T> sampleEquidistant(\n    segments: List<T>,\n    count: Int\n): List<T> where T : LinearType<T>, T : EuclideanVector<T> {\n    val result = mutableListOf<T>()\n    if (segments.isEmpty()) {\n        return result\n    }\n    var totalLength = 0.0\n\n    for (i in 0 until segments.size - 1) {\n        totalLength += segments[i].minus(segments[i + 1]).length\n    }\n\n    val spacing = totalLength / (count - 1)\n\n    var remaining = 0.0\n    var cursor: T\n    if (count > 0) {\n        result.add(segments[0])\n    }\n\n    for (i in 0 until segments.size - 1) {\n        val direction = segments[i + 1] - segments[i]\n        val segmentLength = direction.length\n        if (segmentLength + remaining < spacing) {\n            remaining += segmentLength\n        } else {\n            val skipLength = (spacing - remaining).coerceAtLeast(0.0)\n            val pointsFromSegment = 1 + ((segmentLength - skipLength) / spacing).roundToInt()\n\n            // note: sometimes pointsFromSegments overestimates (due to roundToInt) the number of points\n            // that should be sampled from the current segment by 1 at most.\n\n            val skipT = skipLength / segmentLength\n            val spaceT = spacing / segmentLength\n            val start = segments[i]\n            var t = skipT\n            for (n in 0 until pointsFromSegment) {\n                if (t < 1.0 + 1.0E-6) {\n                    cursor = start + direction * t\n                    t += spaceT\n                    result.add(cursor)\n                }\n            }\n            remaining = (1.0 - (t - spaceT)) * segmentLength\n        }\n    }\n    if (count >= 2) {\n        if (result.size == count) {\n            result[result.lastIndex] = segments.last()\n        } else {\n            result.add(segments.last())\n        }\n    }\n    return result\n}\n\n/** Returns specified amount of points of equal distance from each other. */\nfun <T> sampleEquidistantWithT(\n    segments: List<Pair<T, Double>>,\n    count: Int\n): List<Pair<T, Double>> where T : LinearType<T>, T : EuclideanVector<T> {\n    val result = mutableListOf<Pair<T, Double>>()\n    if (segments.isEmpty()) {\n        return result\n    }\n    var totalLength = 0.0\n\n    for (i in 0 until segments.size - 1) {\n        totalLength += (segments[i].first - segments[i + 1].first).length\n    }\n\n    val spacing = totalLength / (count - 1)\n\n    var remaining = 0.0\n    var cursor: T\n    if (count > 0) {\n        result.add(segments[0])\n    }\n\n    for (i in 0 until segments.size - 1) {\n        val direction = segments[i + 1].first - segments[i].first\n        val deltaT = segments[i + 1].second - segments[i].second\n\n        val segmentLength = direction.length\n        if (segmentLength + remaining < spacing) {\n            remaining += segmentLength\n        } else {\n            val skipLength = (spacing - remaining).coerceAtLeast(0.0)\n            val pointsFromSegment = 1 + ((segmentLength - skipLength) / spacing).roundToInt()\n\n            // note: sometimes pointsFromSegments overestimates (due to roundToInt) the number of points\n            // that should be sampled from the current segment by 1 at most.\n\n            val skipL = skipLength / segmentLength\n            val spaceL = spacing / segmentLength\n            val start = segments[i]\n            var l = skipL\n            for (n in 0 until pointsFromSegment) {\n                if (l < 1.0 + 1.0E-6) {\n                    cursor = start.first + direction * l\n\n                    result.add(cursor to start.second + deltaT * l)\n                    l += spaceL\n                }\n            }\n            remaining = (1.0 - (l - spaceL)) * segmentLength\n        }\n    }\n    if (count >= 2) {\n        if (result.size == count) {\n            result[result.lastIndex] = segments.last()\n        } else {\n            result.add(segments.last())\n        }\n    }\n    return result\n}","package org.openrndr.shape\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.math.Matrix33\nimport org.openrndr.math.Polar\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.Vector3\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.sqrt\nimport kotlin.random.Random\n\n/**\n * Creates a simple three-point polygon.\n */\n@Serializable\ndata class Triangle(val x1: Vector2, val x2: Vector2, val x3: Vector2) : ShapeProvider, ShapeContourProvider {\n    /** Returns true if given [v] lies inside the [Triangle]. */\n    operator fun contains(v: Vector2): Boolean {\n        val x23 = x2 - x3\n        val x32 = x3 - x2\n        val x31 = x3 - x1\n        val x13 = x1 - x3\n        val det = x23.y * x13.x - x32.x * x31.y\n        val minD = min(det, 0.0) - 10E-6\n        val maxD = max(det, 0.0) + 10E-6\n\n        val d = v - x3\n        val a = x23.y * d.x + x32.x * d.y\n        if (a < minD || a > maxD) {\n            return false\n        }\n        val b = x31.y * d.x + x13.x * d.y\n        if (b < minD || b > maxD) {\n            return false\n        }\n        val c = det - a - b\n        return !(c < minD || c > maxD)\n    }\n\n\n    override val contour: ShapeContour\n        get() = ShapeContour.fromPoints(listOf(x1, x2, x3), closed = true)\n\n    override val shape: Shape\n        get() = Shape(listOf(contour))\n    /** Generates a random point that lies inside the [Triangle]. */\n    fun randomPoint(random: Random = Random.Default): Vector2 {\n        val u = random.nextDouble()\n        val v = random.nextDouble()\n        val su0 = sqrt(u)\n        val b0 = 1.0 - su0\n        val b1 = v * su0\n        val b = Vector3(b0, b1, 1.0 - b0 - b1)\n        return x1 * b.x + x2 * b.y + x3 * b.z\n    }\n\n\n    /** The unitless area covered by this [Triangle]. */\n    val area by lazy {\n        val u = x2 - x1\n        val v = x3 - x1\n        abs(u cross v) / 2.0\n    }\n\n    /** The centroid of the [Triangle]. */\n    val centroid by lazy {\n        (x1 + x2 + x3) / 3.0\n    }\n\n    companion object {\n        /**\n         * Creates a triangle from a [centroid] based on the circumradius [radius]\n         *\n         * @param centroid\n         * @param radius\n         * @param theta angle of one of the vertices -> equilateral if theta = 60.0 and isosceles otherwise\n         * @param rotation\n         * @return\n         */\n        fun fromCentroid(centroid: Vector2, radius: Double, theta: Double = 60.0, rotation: Double = 0.0): Triangle {\n            val omega = (180.0 - theta)\n\n            val x1 = centroid + Polar(rotation, radius).cartesian\n            val x2 = centroid + Polar(omega + rotation, radius).cartesian\n            val x3 = centroid + Polar(-omega + rotation, radius).cartesian\n\n            val c = (x1 + x2 + x3) / 3.0\n            val delta = centroid - c\n\n            return Triangle(x1 + delta, x2 + delta, x3 + delta)\n        }\n    }\n\n    operator fun times(scale: Double): Triangle {\n        return Triangle(x1 * scale, x2 * scale, x3 * scale)\n    }\n\n    operator fun div(scale: Double): Triangle {\n        return Triangle(x1 / scale, x2 / scale, x3 / scale)\n    }\n\n    operator fun plus(right: Triangle): Triangle {\n        return Triangle(x1 + right.x1, x2 + right.x2, x3 + right.x3)\n    }\n\n    operator fun minus(right: Triangle): Triangle {\n        return Triangle(x1 - right.x1, x2 - right.x2, x3 - right.x3)\n    }\n\n    fun position(bary: Vector3): Vector2 {\n        return x1 * bary.x + x2 * bary.y + x3 * bary.z\n    }\n\n    fun barycentric(position: Vector2) : Vector3 {\n        val m = Matrix33.fromColumnVectors(\n            Vector3(x1.x - x3.x, x1.y - x3.y, 0.0),\n            Vector3(x2.x - x3.x, x2.y - x3.y, 0.0),\n            Vector3.UNIT_Z\n            )\n        val r = position - x3\n        val (b1, b2) = (m.inversed * r.xy1).xy\n        return Vector3(b1, b2, 1.0 - b1 - b2)\n\n    }\n\n    val reversed: Triangle\n        get() = Triangle(x3, x2, x1)\n}","package org.openrndr.shape\n\nimport org.openrndr.ktessellation.GLConstants.GL_TRIANGLES\nimport org.openrndr.ktessellation.GLConstants.GL_TRIANGLE_FAN\nimport org.openrndr.ktessellation.GLConstants.GL_TRIANGLE_STRIP\nimport org.openrndr.ktessellation.GLU\nimport org.openrndr.ktessellation.Tessellator\nimport org.openrndr.math.Vector2\n\nenum class FillRule {\n    ODD,\n    NONZERO_WINDING,\n}\n\n/**\n * Triangulates a [Shape] into a [List] of triangle corner positions.\n *\n * @param distanceTolerance How refined should the triangular shape be, smaller values equate to higher precision.\n */\nfun triangulate(\n    shape: Shape,\n    distanceTolerance: Double = 0.5,\n    fillRule: FillRule = FillRule.NONZERO_WINDING\n): List<Vector2> {\n    if (shape.contours.isEmpty() || shape.topology == ShapeTopology.OPEN) {\n        return emptyList()\n    }\n    val tessellator = Tessellator()\n    if (shape.topology == ShapeTopology.CLOSED) {\n        when (fillRule) {\n            FillRule.ODD -> tessellator.gluTessProperty(GLU.GLU_TESS_WINDING_RULE, GLU.GLU_TESS_WINDING_ODD)\n            FillRule.NONZERO_WINDING -> tessellator.gluTessProperty(GLU.GLU_TESS_WINDING_RULE, GLU.GLU_TESS_WINDING_NONZERO)\n        }\n    }\n    tessellator.gluTessBeginPolygon(null)\n    for (contour in shape.closedContours) {\n        if (contour.segments.isNotEmpty()) {\n            tessellator.gluTessBeginContour()\n            val positions = contour.adaptivePositions(distanceTolerance).dropLast(1)\n            val positionData = DoubleArray(positions.size * 3) { 0.0 }\n            var offset = 0\n            for (i in positions.indices) {\n                positionData[offset] = positions[i].x\n                offset++\n                positionData[offset] = positions[i].y\n                offset++\n                positionData[offset] = 0.0\n                offset++\n            }\n            for (i in positions.indices) {\n                tessellator.gluTessVertex(positionData, i * 3, doubleArrayOf(positions[i].x, positions[i].y, 0.0))\n            }\n            tessellator.gluTessEndContour()\n        }\n    }\n    tessellator.gluTessEndPolygon()\n    val result = mutableListOf<Vector2>()\n    for (pd in tessellator.primitives) {\n        if (pd.positions.isNotEmpty()) {\n            when (pd.type) {\n                GL_TRIANGLES -> {\n                    result.addAll(pd.positions)\n                }\n                GL_TRIANGLE_FAN -> {\n                    val fixed = pd.positions[0]\n                    for (i in 1 until pd.positions.size - 1) {\n                        result.add(fixed)\n                        result.add(pd.positions[i])\n                        result.add(pd.positions[i + 1])\n                    }\n                }\n                GL_TRIANGLE_STRIP -> {\n                    for (i in 0 until pd.positions.size - 2) {\n                        result.add(pd.positions[i])\n                        result.add(pd.positions[i + 1])\n                        result.add(pd.positions[i + 2])\n                    }\n                }\n                else -> error(\"type not supported: ${pd.type}\")\n            }\n        }\n    }\n    for (i in result.indices step 3) {\n        val a = result[i]\n        val b = result[i + 1]\n        val c = result[i + 2]\n        if ((b.x - a.x) * (c.y - a.y) < (b.y - a.y) * (c.x - a.x)) {\n            result[i + 1] = c\n            result[i + 2] = b\n        }\n    }\n    tessellator.gluDeleteTess()\n    return result\n}\n\n","package org.openrndr.shape.internal\n\nimport org.openrndr.math.EuclideanVector\nimport kotlin.math.PI\nimport kotlin.math.absoluteValue\n\ninternal typealias Tt<T> = Pair<T, Double>\nprivate operator fun <T:EuclideanVector<T>> Tt<T>.plus(other: Tt<T>) = Tt(first + other.first, second + other.second)\nprivate operator fun <T:EuclideanVector<T>> Tt<T>.times(scale: Double) = Tt(first * scale, second * scale)\nprivate fun <T:EuclideanVector<T>> Tt<T>.squaredDistanceTo(other: Tt<T>) = first.squaredDistanceTo(other.first)\nprivate fun <T:EuclideanVector<T>> Tt<T>.squaredDistanceTo(other: T) = first.squaredDistanceTo(other)\n\ninternal class BezierCubicSamplerT<T:EuclideanVector<T>> {\n    private val points = mutableListOf<Tt<T>>()\n\n    private var distanceToleranceSquare = 0.0\n    private val angleTolerance = 0.0\n    private val cuspLimit = 0.0\n    var distanceTolerance = 0.5\n\n    fun sample(x1: T, x2: T, x3: T, x4: T): List<Tt<T>> {\n        distanceToleranceSquare = distanceTolerance * distanceTolerance\n        points.clear()\n        points.add(x1 to 0.0)\n        sample(x1 to 0.0, x2 to 1.0/3.0, x3 to 2.0/3.0, x4 to 1.0, 0)\n        if (points.last().first.squaredDistanceTo(x4) > 0.0) {\n            points.add(x4 to 1.0)\n        }\n        return points\n    }\n\n    private fun sample(vt1: Tt<T>, vt2 : Tt<T>, vt3: Tt<T>, vt4: Tt<T>, level: Int) {\n        val x1 = vt1.first\n        val x2 = vt2.first\n        val x3 = vt3.first\n        val x4 = vt4.first\n\n        if (level > recursionLimit) {\n            return\n        }\n\n        val vt12 = (vt1 + vt2) * 0.5\n        val vt23 = (vt2 + vt3) * 0.5\n        val vt34 = (vt3 + vt4) * 0.5\n\n        val vt123 = (vt12 + vt23) * 0.5\n        val vt234 = (vt23 + vt34) * 0.5\n\n        val vt1234 = (vt123 + vt234) * 0.5\n\n        val d = x4 - x1\n        var d2 = (x2-x4).areaBetween(d)\n        var d3 = (x3-x4).areaBetween(d)\n\n        val p1 = d2 > colinearityEpsilon\n        val p0 = d3 > colinearityEpsilon\n        val p = (if (p1) 2 else 0) + if (p0) 1 else 0\n\n        var k: Double\n        when (p) {\n            0 -> {\n                k = d.squaredLength\n                if (k == 0.0) {\n                    d2 = x1.squaredDistanceTo(x2)\n                    d3 = x3.squaredDistanceTo(x4)\n                } else {\n                    k = 1 / k\n\n                    d2 = run {\n                        val dl = x2 - x1\n                        k * d.dot(dl)\n                    }\n\n                    d3 = run {\n                        val dl = x3 - x1\n                        k * d.dot(dl)\n                    }\n                    if (d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1) {\n                        // Simple collinear case, 1---2---3---4\n                        // We can leave just two endpoints\n                        return\n                    }\n\n                    d2 = when {\n                        d2 <= 0 -> x1.squaredDistanceTo(x2)\n                        d2 >= 1 -> x2.squaredDistanceTo(x4)\n                        else -> x2.squaredDistanceTo(x1 + d * d2) // squareDistance(x2.x, x2.y, x1.x + d2 * dx, x1.y + d2 * dy)\n                    }\n\n                    d3 = when {\n                        d3 <= 0 -> x3.squaredDistanceTo(x1)\n                        d3 >= 1 -> x3.squaredDistanceTo(x4)\n                        else -> x3.squaredDistanceTo(x1 + d * d3) //squareDistance(x3.x, x3.y, x1.x + d3 * dx, x1.y + d3 * dy)\n                    }\n\n                }\n                if (d2 > d3) {\n                    if (d2 < distanceToleranceSquare) {\n                        if (points.last().first.squaredDistanceTo(x2) > 0.0) {\n                            points.add(vt2)\n                        }\n                        return\n                    }\n                } else {\n                    if (d3 < distanceToleranceSquare) {\n                        if (points.last().first.squaredDistanceTo(x3) > 0.0) {\n                            points.add(vt3)\n                        }\n                        return\n                    }\n                }\n            }\n            1 ->\n                // p1,p2,p4 are collinear, p3 is significant\n                //----------------------\n                if (d3 * d3 <= distanceToleranceSquare * d.squaredLength) {\n                    if (angleTolerance < angleToleranceEpsilon) {\n                        if (points.last().squaredDistanceTo(vt23) > 0.0) {\n                            points.add(vt23)\n                        }\n                        return\n                    }\n\n                    // Angle Condition\n                    //----------------------\n                    var da1 = (x4-x3).atan2(x3-x2).absoluteValue // abs(atan2(x4.y - x3.y, x4.x - x3.x) - atan2(x3.y - x2.y, x3.x - x2.x))\n                    if (da1 >= PI) da1 = 2 * PI - da1\n\n                    if (da1 < angleTolerance) {\n                        if (points.last().squaredDistanceTo(x2) > 0.0) {\n                            points.add(vt2)\n                        }\n                        if (points.last().squaredDistanceTo(x3) > 0.0) {\n                            points.add(vt3)\n                        }\n                        return\n                    }\n\n                    if (cuspLimit != 0.0) {\n                        if (da1 > cuspLimit) {\n                            if (points.last().squaredDistanceTo(x3) > 0.0) {\n                                points.add(vt3)\n                            }\n                            return\n                        }\n                    }\n                }\n            2 ->\n                // p1,p3,p4 are collinear, p2 is significant\n                //----------------------\n                if (d2 * d2 <= distanceToleranceSquare * d.squaredLength) {\n                    if (angleTolerance < angleToleranceEpsilon) {\n                        if (points.last().squaredDistanceTo(vt23) > 0.0) {\n                            points.add(vt23)\n                        }\n                        return\n                    }\n\n                    // Angle Condition\n                    //----------------------\n                    var da1 = (x3-x2).atan2(x2-x1).absoluteValue //abs(atan2(x3.y - x2.y, x3.x - x2.x) - atan2(x2.y - x1.y, x2.x - x1.x))\n                    if (da1 >= PI) da1 = 2 * PI - da1\n\n                    if (da1 < angleTolerance) {\n                        if (points.last().squaredDistanceTo(vt2) > 0.0) {\n                            points.add(vt2)\n                        }\n                        if (points.last().squaredDistanceTo(vt3) > 0.0) {\n                            points.add(vt3)\n                        }\n                        return\n                    }\n\n                    if (cuspLimit != 0.0) {\n                        if (da1 > cuspLimit) {\n                            if (points.last().squaredDistanceTo(vt2) > 0.0) {\n                                points.add(vt2)\n                            }\n                            return\n                        }\n                    }\n                }\n            3 ->\n                // Regular case\n                //-----------------\n                if ((d2 + d3) * (d2 + d3) <= distanceToleranceSquare * d.squaredLength) {\n                    // If the curvature doesn't exceed the distance_tolerance value\n                    // we tend to finish subdivisions.\n                    //----------------------\n                    if (angleTolerance < angleToleranceEpsilon) {\n                        if (points.last().squaredDistanceTo(vt23) > 0.0) {\n                            points.add(vt23)\n                        }\n                        return\n                    }\n\n                    // Angle & Cusp Condition\n                    //----------------------\n                    var da1 = (x3-x2).atan2(x2-x1).absoluteValue\n                    var da2 = (x4-x3).atan2(x3-x2).absoluteValue\n                    //\n                    if (da1 >= PI) da1 = 2 * PI - da1\n                    if (da2 >= PI) da2 = 2 * PI - da2\n\n                    if (da1 + da2 < angleTolerance) {\n                        // Finally we can stop the recursion\n                        //----------------------\n                        if (points.last().squaredDistanceTo(vt23) > 0.0) {\n                            points.add(vt23)\n                        }\n                        return\n                    }\n\n                    if (cuspLimit != 0.0) {\n                        if (da1 > cuspLimit) {\n                            if (points.last().squaredDistanceTo(vt2) > 0.0) {\n                                points.add(vt2)\n                            }\n                            return\n                        }\n\n                        if (da2 > cuspLimit) {\n                            if (points.last().squaredDistanceTo(vt3) > 0.0) {\n                                points.add(vt3)\n                            }\n                            return\n                        }\n                    }\n                }\n        }\n        sample(vt1, vt12, vt123, vt1234, level + 1)\n        sample(vt1234, vt234, vt34, vt4, level + 1)\n    }\n\n    companion object {\n        private const val colinearityEpsilon = 1e-30\n        private const val angleToleranceEpsilon = 0.01\n        private const val recursionLimit = 12\n    }\n}\n","package org.openrndr.shape.internal\n\nimport org.openrndr.math.EuclideanVector\nimport kotlin.math.PI\nimport kotlin.math.absoluteValue\n\nprivate operator fun <T:EuclideanVector<T>> Tt<T>.plus(other: Tt<T>) = Tt(first + other.first, second + other.second)\nprivate operator fun <T:EuclideanVector<T>> Tt<T>.times(scale: Double) = Tt(first * scale, second * scale)\nprivate fun <T:EuclideanVector<T>> Tt<T>.squaredDistanceTo(other: Tt<T>) = first.squaredDistanceTo(other.first)\nprivate fun <T:EuclideanVector<T>> Tt<T>.squaredDistanceTo(other: T) = first.squaredDistanceTo(other)\n\ninternal class BezierQuadraticSamplerT<T : EuclideanVector<T>> {\n    private val recursionLimit = 12\n\n    var distanceTolerance = 0.5\n    private var distanceToleranceSquare = 0.0\n    private val angleToleranceEpsilon = 0.01\n    private val angleTolerance = 0.0\n\n    internal var points: MutableList<Tt<T>> = mutableListOf()\n\n    private fun sample(vt1: Tt<T>, vt2: Tt<T>, vt3: Tt<T>, level: Int) {\n        if (level > recursionLimit) {\n            return\n        }\n\n        val vt12 = (vt1 + vt2) * 0.5\n        val vt23 = (vt2 + vt3) * 0.5\n        val vt123 = (vt12 + vt23) * 0.5\n\n        val x1 = vt1.first\n        val x2 = vt2.first\n        val x3 = vt3.first\n\n        val d = x3 - x1\n        val d1 = (x2-x3).areaBetween(x3-x1)\n\n        if (d1 > colinearityEpsilon) {\n            // Regular case\n            //-----------------\n            if (d1 * d1 <= distanceToleranceSquare * d.squaredLength) {\n                // If the curvature doesn't exceed the distance_tolerance value\n                // we tend to finish subdivisions.\n                //----------------------\n                if (angleTolerance < angleToleranceEpsilon) {\n                    if (points.last().squaredDistanceTo(vt123) > 0.0) {\n                        points.add(vt123)\n                    }\n                    return\n                }\n\n                // Angle & Cusp Condition\n                //----------------------\n                var da = (x2-x1).atan2(x3-x2).absoluteValue //  abs(atan2(x3.y - x2.y, x3.x - x2.x) - atan2(x2.y - x1.y, x2.x - x1.x))\n                if (da >= PI) da = 2 * PI - da\n\n                if (da < angleTolerance) {\n                    // Finally we can stop the recursion\n                    //----------------------\n                    if (points.last().squaredDistanceTo(vt123) > 0.0) {\n                        points.add(vt123)\n                    }\n                    return\n                }\n            }\n        } else {\n            // Collinear case\n            //------------------\n            val da = d.squaredLength\n            var dl: Double\n            if (da == 0.0) {\n                dl = x1.squaredDistanceTo(x2)\n            } else {\n                dl = (x2-x1).dot(d) / da // ((x2.x - x1.x) * dx + (x2.y - x1.y) * dy) / da\n                if (dl > 0 && dl < 1) {\n                    // Simple collinear case, 1---2---3\n                    // We can leave just two endpoints\n                    return\n                }\n                if (dl <= 0)\n                    dl = x2.squaredDistanceTo(x1)\n                else if (dl >= 1)\n                    dl = x2.squaredDistanceTo(x3)\n                else\n                    dl = x2.squaredDistanceTo(x1 + d * dl)//squaredDistance(x2.x, x2.y, x1.x + d * dx, x1.y + d * dy)\n            }\n            if (dl < distanceToleranceSquare) {\n                if (points.last().squaredDistanceTo(x2) > 0.0) {\n                    points.add(vt2)\n                }\n                return\n            }\n        }\n\n        // Continue subdivision\n        //----------------------\n        sample(vt1, vt12, vt123, level + 1)\n        sample(vt123, vt23, vt3, level + 1)\n    }\n\n    fun sample(x1: T, x2: T, x3: T): List<Tt<T>> {\n        distanceToleranceSquare = distanceTolerance * distanceTolerance\n        points.clear()\n        points.add(x1 to 0.0)\n        sample(x1 to 0.0, x2 to 0.5, x3 to 1.0, 0)\n        if (points.last().squaredDistanceTo(x3) > 0.0) {\n            points.add(x3 to 1.0)\n        }\n        return points\n    }\n\n    companion object {\n        private const val colinearityEpsilon = 1e-30\n    }\n}\n","//https://codereview.stackexchange.com/questions/175291/minimum-priority-queue-implementation-in-kotlin\npackage org.openrndr.collections\n\nclass PriorityQueue<Key> : Iterable<Key> {\n    private var pq: Array<Key?>\n    private var n = 0\n    private val comparator: Comparator<Key>?\n\n    constructor(initCapacity: Int) : this(initCapacity, null)\n    constructor() : this(1)\n    constructor(comparator: Comparator<Key>?) : this(1, comparator)\n\n    constructor(initCapacity: Int, comparator: Comparator<Key>?) {\n        this.comparator = comparator\n        @Suppress(\"UNCHECKED_CAST\")\n        pq = arrayOfNulls<Any?>(initCapacity + 1) as Array<Key?>\n    }\n\n    constructor(keys: Array<Key>) : this(keys.size) {\n        n = keys.size\n        for (i in 0 until n) {\n            pq[i + 1] = keys[i]\n        }\n        for (k in n / 2 downTo 1) {\n            sink(k)\n        }\n        //assert(isMinHeap())\n    }\n\n    fun isEmpty() = n == 0\n\n    fun size() = n\n\n    fun peek(): Key {\n        if (!isEmpty()) {\n            return pq[1]!!\n        } else {\n            error(\"pq empty\")\n        }\n    }\n\n\n    fun add(x: Key): PriorityQueue<Key> = insert(x)\n    fun insert(x: Key): PriorityQueue<Key> {\n        if (n == pq.size - 1) {\n            resize(2 * pq.size)\n        }\n        pq[++n] = x\n        swim(n)\n        //assert(isMinHeap())\n        return this\n    }\n\n    fun poll(): Key? {\n        if (isEmpty()) {\n            return null\n        }\n\n        //require(!isEmpty()) { \"Cannot retrieve minimum record. Priority queue is empty\" }\n        val min = pq[1]\n        exch(1, n--)\n        sink(1)\n        pq[n + 1] = null\n        //assert(isMinHeap())\n        return min ?: throw NullPointerException(\"'min' must not be null\")\n    }\n\n    override fun iterator(): Iterator<Key> {\n        return HeapIterator(comparator, size(), n, pq)\n    }\n\n    private fun swim(k: Int) {\n        var myK = k\n        while (myK > 1 && greater(myK / 2, myK)) {\n            exch(myK, myK / 2)\n            myK /= 2\n        }\n    }\n\n    private fun sink(k: Int) {\n        var myK = k\n        while (2 * myK <= n) {\n            var j = 2 * myK\n            if (j < n && greater(j, j + 1)) j++\n            if (!greater(myK, j)) return\n            exch(myK, j)\n            myK = j\n        }\n    }\n\n    private fun greater(i: Int, j: Int): Boolean {\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (comparator == null) (pq[i] as Comparable<Key>) > pq[j]!!\n        else comparator.compare(pq[i]!!, pq[j]!!) > 0\n    }\n\n    private fun exch(i: Int, j: Int) {\n        pq[i] = pq[j].also { pq[j] = pq[i] }\n    }\n\n    private fun isMinHeap(): Boolean = isMinHeap(1)\n\n    private fun isMinHeap(k: Int): Boolean {\n        if (k > n) return true\n        val left = 2 * k\n        val right = 2 * k + 1\n        when {\n            left <= n && greater(k, left) -> return false\n            right <= n && greater(k, right) -> return false\n            else -> {\n                return isMinHeap(left) && isMinHeap(right)\n            }\n        }\n    }\n\n    private fun resize(capacity: Int) {\n        //assert(capacity > n)\n        @Suppress(\"UNCHECKED_CAST\") val temp = arrayOfNulls<Any>(capacity) as Array<Key?>\n        for (i in 1..n) {\n            temp[i] = pq[i]\n        }\n        pq = temp\n    }\n\n    class HeapIterator<out Key>(comparator: Comparator<Key>?, size: Int, n: Int, pq: Array<Key?>) : Iterator<Key> {\n\n        private val copy: PriorityQueue<Key> = if (comparator == null) PriorityQueue<Key>(size) else PriorityQueue<Key>(size, comparator)\n\n        override fun hasNext(): Boolean {\n            return !copy.isEmpty()\n        }\n\n        override fun next(): Key {\n            require(hasNext()) {\"Queue is empty\"}\n            return copy.poll() ?: error(\"Queue is empty\")\n        }\n\n        init {\n            for (i in 1..n)\n                copy.insert(pq[i]!!)\n        }\n    }\n}","package org.openrndr.utils\n\nimport kotlin.reflect.KProperty\nactual class ResettableDelegate<T> actual constructor(private val initializer: () -> T) {\n    private var lazyRef = lazy(initializer)\n\n    actual operator fun getValue(thisRef: Any?, property: KProperty<*>): T {\n        return lazyRef.getValue(thisRef, property)\n    }\n\n    actual fun reset() {\n        lazyRef = lazy(initializer)\n    }\n}","package org.openrndr.utils.buffer\n\nimport org.khronos.webgl.ArrayBuffer\nimport org.khronos.webgl.DataView\n\nactual class MPPBuffer(val dataView: DataView) {\n    private var offset = 0\n    actual fun rewind() {\n        offset = 0\n    }\n\n    actual val int: Int\n        get() {\n            val v = dataView.getInt32(offset, littleEndian = true)\n            offset += 4\n            return v\n        }\n\n    actual val float: Float\n        get() {\n            val v = dataView.getFloat32(offset, littleEndian = true)\n            offset += 4\n            return v\n        }\n\n    actual val double: Double\n        get() {\n            val v = dataView.getFloat64(offset, littleEndian = true)\n            offset += 8\n            return v\n        }\n\n    actual val byte: Byte\n        get() {\n            val v = dataView.getInt8(offset)\n            offset += 1\n            return v\n        }\n\n    actual fun get(): Byte {\n        val v = dataView.getInt8(offset)\n        offset += 1\n        return v\n    }\n\n    actual fun capacity(): Int {\n        return dataView.byteLength\n    }\n\n    actual fun get(target: ByteArray) {\n        for (i in 0 until target.size) {\n            target[i] = dataView.getInt8(offset)\n            offset++\n        }\n    }\n\n    actual fun remaining(): Int {\n        return dataView.byteLength - offset\n    }\n\n\n    actual companion object {\n        actual fun allocate(size: Int): MPPBuffer {\n            val ab = ArrayBuffer(size)\n            val dv = DataView(ab)\n            return MPPBuffer(dv)\n        }\n\n        actual fun createFrom(fromBytes: ByteArray): MPPBuffer {\n            val ab = ArrayBuffer(fromBytes.size)\n            val dv = DataView(ab)\n            for ((index, i) in fromBytes.withIndex()) {\n                dv.setInt8(index, i)\n            }\n            return MPPBuffer(dv)\n        }\n    }\n\n    actual fun put(byte: Byte) {\n        dataView.setInt8(offset, byte)\n        offset++\n    }\n\n    actual fun putFloat(float: Float) {\n        dataView.setFloat32(offset, float, littleEndian = true)\n        offset += 4\n    }\n\n    actual fun putDouble(double: Double) {\n        dataView.setFloat64(offset, double, littleEndian = true)\n        offset += 8\n    }\n\n    actual fun putInt(int: Int) {\n        dataView.setInt32(offset, int, littleEndian = true)\n        offset += 4\n    }\n\n\n}","package org.openrndr.collections\n\nfun <E> ArrayDeque<E>.push(item: E) : E {\n    addLast(item)\n    return item\n}\n\nfun <E> ArrayDeque<E>.pop() : E {\n    return removeLast()\n}","package org.openrndr.utils\n\nimport kotlin.reflect.KProperty\n\nfun <T> resettableLazy(initializer: () -> T) = ResettableDelegate(initializer)\n\nexpect class ResettableDelegate<T>(initializer: () -> T) {\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): T\n    fun reset()\n}","package org.openrndr.extra.color.phrases\n\nimport org.openrndr.extra.shaderphrases.ShaderPhrase\nimport org.openrndr.extra.shaderphrases.ShaderPhraseBook\n\nobject ColorPhraseBook : ShaderPhraseBook(\"color\") {\n    val phraseAtan2 = ShaderPhrase(\"\"\"\n        |float atan2(in float y, in float x) {\n        |   bool s = (abs(x) > abs(y));\n        |   return mix(PI/2.0 - atan(x,y), atan(y,x), float(s));\n        |}\"\"\".trimMargin())\n\n    val phraseLinearRgbToOKLab = ShaderPhrase(\"\"\"\n        |vec4 linear_rgb_to_oklab(vec4 c) {\n        |   c.rgb = max(vec3(0.0), c.rgb);\n        |   const mat3 kCONEtoLMS = mat3(\n        |       0.4122214708,  0.2119034982,  0.0883024619,\n        |       0.5363325363,  0.6806995451,  0.2817188376,\n        |       0.0514459929,  0.1073969566,  0.6299787005);\n        |\n        |   const mat3 kRot = mat3(\n        |       0.2104542553,  1.9779984951,  0.0259040371,\n        |       0.7936177850, -2.4285922050,  0.7827717662,\n        |       -0.0040720468,  0.4505937099, -0.8086757660);\n        |   vec3 lms = pow(kCONEtoLMS * c.rgb, vec3(1.0/3.0));\n        |   vec4 res = vec4((kRot) * lms, c.a);\n        |   return res;\n        |}\"\"\".trimMargin())\n\n    val oklabToLinearRgb = ShaderPhrase(\"\"\"\n        |vec4 oklab_to_linear_rgb(vec4 lab) {\n        |   const mat3 kLMStoCONE = mat3(\n        |       1.0,            1.0,           1.0,\n        |       0.3963377774,  -0.1055613458, -0.0894841775,\n        |       0.2158037573,  -0.0638541728,  -1.2914855480);\n        |   const mat3 kRot = mat3(\n        |       4.0767416621, -1.2684380046, -0.0041960863,\n        |       -3.3077115913,  2.6097574011,  -0.7034186147,\n        |       0.2309699292, -0.3413193965, 1.7076147010);\n        |   vec3 lms = kLMStoCONE * lab.rgb;\n        |   lms = lms * lms * lms;\n        |   vec4 res = vec4(kRot * lms,lab.a);\n        |   return res;\n        |}\"\"\".trimMargin())\n\n    val phraseLabToLch = ShaderPhrase( \"\"\"\n        |vec4 lab_to_lch(vec4 lab) {\n        |   float r = length(lab.yz);\n        |   float h = atan2(lab[2], lab[1]);\n        |   return vec4(lab[0], c, h, lab.a);\n        |}\"\"\".trimMargin())\n\n    val phraseLchToLab = ShaderPhrase(\"\"\"\n        |vec4 lch_to_lab(vec4 lch) {\n        |   float a = lch[1] * cos(lch[2]);\n        |   float b = lch[1] * sin(lch[2]);\n        |   return vec4(lab[0], a, b, lab.a);\n        |}\"\"\".trimMargin())\n\n    val linearRgbToSRgb = ShaderPhrase(\"\"\"\n        |vec4 linear_rgb_to_srgb(vec4 c) {\n        |   const float t = 0.00313066844250063;\n        |   return vec4(\n        |       c.r <= t ? c.r * 12.92 : 1.055 * pow(c.r, 1.0 / 2.4) - 0.055,\n        |       c.g <= t ? c.g * 12.92 : 1.055 * pow(c.g, 1.0 / 2.4) - 0.055,\n        |       c.b <= t ? c.b * 12.92 : 1.055 * pow(c.b, 1.0 / 2.4) - 0.055,\n        |       c.a);\n        |}\"\"\".trimMargin())\n\n    val phraseSRgbToLinearRgb = ShaderPhrase(\"\"\"\n        |vec4 srgb_to_linear_rgb(vec4 c) {\n        |   const float t = 0.0404482362771082;\n        |   return vec4(\n        |       c.r <= t ? c.r / 12.92 : pow( (c.r + 0.055) / 1.055, 2.4),\n        |       c.g <= t ? c.g / 12.92 : pow( (c.g + 0.055) / 1.055, 2.4),\n        |       c.b <= t ? c.b / 12.92 : pow( (c.b + 0.055) / 1.055, 2.4),\n        |       c.a);\n        |}\"\"\".trimMargin())\n}","package org.openrndr.extra.color.spaces\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.color.*\nimport org.openrndr.math.Vector4\nimport kotlin.math.abs\nimport kotlin.math.pow\nimport kotlin.math.sign\n\n/**\n * Color in OKLab color space.\n * [l] = lightness: black (0.0) to white (1.0),\n * [a] = red (-1.0) to green (1.0),\n * [b] = yellow (-1.0) to blue (1.0).\n */\n@Suppress(\"LocalVariableName\")\n@Serializable\ndata class ColorOKLABa(val l: Double, val a: Double, val b: Double, override val alpha: Double = 1.0) :\n    ColorModel<ColorOKLABa>,\n    ShadableColor<ColorOKLABa>,\n    LuminosityColor<ColorOKLABa>,\n    AlgebraicColor<ColorOKLABa> {\n\n    companion object {\n        fun fromRGBa(rgba: ColorRGBa): ColorOKLABa {\n            // based on https://bottosson.github.io/posts/oklab/\n            val c = rgba.toLinear()\n            val l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b\n            val m = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b\n            val s = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b\n\n            val lnl = abs(l).pow(1.0 / 3.0) * sign(l)\n            val mnl = abs(m).pow(1.0 / 3.0) * sign(m)\n            val snl = abs(s).pow(1.0 / 3.0) * sign(s)\n\n\n            val L = 0.2104542553 * lnl + 0.7936177850 * mnl - 0.0040720468 * snl\n            val a = 1.9779984951 * lnl - 2.4285922050 * mnl + 0.4505937099 * snl\n            val b = 0.0259040371 * lnl + 0.7827717662 * mnl - 0.8086757660 * snl\n\n            return ColorOKLABa(L, a, b, c.alpha)\n        }\n    }\n\n    override fun toRGBa(): ColorRGBa {\n        // based on https://bottosson.github.io/posts/oklab/\n        val lnl = l + 0.3963377774 * a + 0.2158037573 * b\n        val mnl = l - 0.1055613458 * a - 0.0638541728 * b\n        val snl = l - 0.0894841775 * a - 1.2914855480 * b\n\n        val l = lnl * lnl * lnl\n        val m = mnl * mnl * mnl\n        val s = snl * snl * snl\n\n        return ColorRGBa(\n            4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,\n            -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,\n            -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s,\n            alpha,\n            Linearity.LINEAR\n        )\n    }\n\n    fun toOKLCHa() = ColorOKLCHa.fromColorOKLABa(this)\n\n    override fun shade(factor: Double) = ColorOKLABa(l * factor, a, b, alpha)\n    override fun opacify(factor: Double) = ColorOKLABa(l, a, b, alpha * factor)\n    override fun minus(right: ColorOKLABa) = ColorOKLABa(l - right.l, a - right.a, b - right.b, alpha - right.alpha)\n    override fun plus(right: ColorOKLABa) = ColorOKLABa(l + right.l, a + right.a, b + right.b, alpha + right.alpha)\n    override fun times(scale: Double) = ColorOKLABa(l * scale, a * scale, b * scale, alpha * scale)\n\n    override fun toVector4() = Vector4(l, a, b, alpha)\n    override val luminosity: Double\n        get() = l * 100.0\n\n    override fun withLuminosity(luminosity: Double): ColorOKLABa = copy(l = luminosity / 100.0)\n}\n\nfun ColorRGBa.toOKLABa() = ColorOKLABa.fromRGBa(this)","package org.openrndr.extra.color.spaces\n\nimport kotlinx.serialization.Serializable\nimport org.openrndr.color.*\nimport org.openrndr.math.*\nimport kotlin.math.*\n\n/**\n * Color in cylindrical OKLab space\n */\n@Serializable\ndata class ColorOKLCHa(val l: Double, val c: Double, val h: Double, override val alpha: Double = 1.0) :\n    ColorModel<ColorOKLCHa>,\n    ShadableColor<ColorOKLCHa>,\n    ChromaColor<ColorOKLCHa>,\n    HueShiftableColor<ColorOKLCHa>,\n    LuminosityColor<ColorOKLCHa>,\n    AlgebraicColor<ColorOKLCHa> {\n\n    companion object {\n        fun fromColorOKLABa(oklaba: ColorOKLABa): ColorOKLCHa {\n            val l = oklaba.l\n            val c = sqrt(oklaba.a * oklaba.a + oklaba.b * oklaba.b)\n            var h = atan2(oklaba.b, oklaba.a)\n\n            if (h < 0) {\n                h += PI * 2\n            }\n            h = h.asDegrees\n            return ColorOKLCHa(l, c, h, oklaba.alpha)\n        }\n    }\n\n    @Deprecated(\"Legacy alpha parameter name\", ReplaceWith(\"alpha\"))\n    val a = alpha\n\n    override fun opacify(factor: Double) = copy(alpha = alpha * factor)\n    override fun shade(factor: Double) = copy(l = l * factor)\n\n    override fun plus(right: ColorOKLCHa) = copy(l = l + right.l, c = c + right.c, h = h + right.h, alpha = alpha + right.alpha)\n    override fun minus(right: ColorOKLCHa) = copy(l = l - right.l, c = c - right.c, h = h - right.h, alpha = alpha - right.alpha)\n    override fun times(scale: Double) = copy(l = l * scale, c = c * scale, h = h * scale, alpha = alpha * scale)\n    override fun mix(other: ColorOKLCHa, factor: Double) = mix(this, other, factor)\n\n    fun toOKLABa(): ColorOKLABa {\n        val a = c * cos(h.asRadians)\n        val b = c * sin(h.asRadians)\n        return ColorOKLABa(l, a, b, alpha = this.alpha)\n    }\n\n    override fun toRGBa(): ColorRGBa = toOKLABa().toRGBa()\n    override fun toVector4(): Vector4 = Vector4(l, c, h, alpha)\n    override val chroma: Double\n        get() = c * 100.0\n    override fun withChroma(chroma: Double): ColorOKLCHa = copy(c = chroma / 100.0)\n    override val hue: Double\n        get() = h\n\n    override fun withHue(hue: Double): ColorOKLCHa = copy(h = hue)\n    override val luminosity: Double\n        get() = l * 100.0\n\n    override fun withLuminosity(luminosity: Double): ColorOKLCHa = copy(l = luminosity / 100.0)\n}\n\nfun mix(left: ColorOKLCHa, right: ColorOKLCHa, x: Double): ColorOKLCHa {\n    val sx = x.coerceIn(0.0, 1.0)\n    return ColorOKLCHa(\n        (1.0 - sx) * left.l + sx * right.l,\n        (1.0 - sx) * left.c + sx * right.c,\n        mixAngle(left.h, right.h, sx),\n        (1.0 - sx) * left.alpha + sx * right.alpha\n    )\n}\n\nfun ColorRGBa.toOKLCHa() = ColorOKLABa.fromRGBa(this).toOKLCHa()\n","package org.openrndr.extra.composition\n\nimport org.openrndr.draw.*\nimport org.openrndr.math.*\nimport org.openrndr.math.transforms.*\nimport org.openrndr.shape.Rectangle\nimport org.openrndr.shape.Shape\nimport org.openrndr.shape.ShapeContour\nimport org.openrndr.shape.bounds\nimport kotlin.math.*\nimport kotlin.reflect.*\n\n/**\n * Describes a node in a composition\n */\nsealed class CompositionNode {\n\n    var id: String? = null\n\n    var parent: CompositionNode? = null\n\n    /** This CompositionNode's own style. */\n    var style: Style = Style()\n\n    /**\n     * This CompositionNode's computed style.\n     * Where every style attribute is obtained by\n     * overwriting the Style in the following order:\n     * 1. Default style attributes.\n     * 2. Parent Node's computed style's inheritable attributes.\n     * 3. This Node's own style attributes.\n     */\n    val effectiveStyle: Style\n        get() = when (val p = parent) {\n            is CompositionNode -> style inherit p.effectiveStyle\n            else -> style\n        }\n\n    /**\n     * Custom attributes to be applied to the Node in addition to the Style attributes.\n     */\n    var attributes = mutableMapOf<String, String?>()\n\n    /**\n     * a map that stores user data\n     */\n    val userData = mutableMapOf<String, Any>()\n\n    /**\n     * a [Rectangle] that describes the bounding box of the contents\n     */\n    abstract val bounds: Rectangle\n\n    val effectiveStroke get() = effectiveStyle.stroke.value\n    val effectiveStrokeOpacity get() = effectiveStyle.strokeOpacity.value\n    val effectiveStrokeWeight get() = effectiveStyle.strokeWeight.value\n    val effectiveMiterLimit get() = effectiveStyle.miterLimit.value\n    val effectiveLineCap get() = effectiveStyle.lineCap.value\n    val effectiveLineJoin get() = effectiveStyle.lineJoin.value\n    val effectiveFill get() = effectiveStyle.fill.value\n    val effectiveFillOpacity get() = effectiveStyle.fillOpacity.value\n    val effectiveDisplay get() = effectiveStyle.display.value\n    val effectiveOpacity get() = effectiveStyle.opacity.value\n    val effectiveVisibility get() = effectiveStyle.visibility.value\n    val effectiveShadeStyle get() = effectiveStyle.shadeStyle.value\n\n    /** Calculates the absolute transformation of the current node. */\n    val effectiveTransform: Matrix44\n        get() = when (val p = parent) {\n            is CompositionNode -> transform * p.effectiveTransform\n            else -> transform\n        }\n\n    var stroke\n        get() = style.stroke.value\n        set(value) {\n            style.stroke = when (value) {\n                null -> Paint.None\n                else -> Paint.RGB(value)\n            }\n        }\n    var strokeOpacity\n        get() = style.strokeOpacity.value\n        set(value) {\n            style.strokeOpacity = Numeric.Rational(value)\n        }\n    var strokeWeight\n        get() = style.strokeWeight.value\n        set(value) {\n            style.strokeWeight = Length.Pixels(value)\n        }\n    var miterLimit\n        get() = style.miterLimit.value\n        set(value) {\n            style.miterLimit = Numeric.Rational(value)\n        }\n    var lineCap\n        get() = style.lineCap.value\n        set(value) {\n            style.lineCap = when (value) {\n                org.openrndr.draw.LineCap.BUTT -> LineCap.Butt\n                org.openrndr.draw.LineCap.ROUND -> LineCap.Round\n                org.openrndr.draw.LineCap.SQUARE -> LineCap.Square\n            }\n        }\n    var lineJoin\n        get() = style.lineJoin.value\n        set(value) {\n            style.lineJoin = when (value) {\n                org.openrndr.draw.LineJoin.BEVEL -> LineJoin.Bevel\n                org.openrndr.draw.LineJoin.MITER -> LineJoin.Miter\n                org.openrndr.draw.LineJoin.ROUND -> LineJoin.Round\n            }\n        }\n    var fill\n        get() = style.fill.value\n        set(value) {\n            style.fill = when (value) {\n                null -> Paint.None\n                else -> Paint.RGB(value)\n            }\n        }\n    var fillOpacity\n        get() = style.fillOpacity.value\n        set(value) {\n            style.fillOpacity = Numeric.Rational(value)\n        }\n    var opacity\n        get() = style.opacity.value\n        set(value) {\n            style.opacity = Numeric.Rational(value)\n        }\n    var shadeStyle\n        get() = style.shadeStyle.value\n        set(value) {\n            style.shadeStyle = Shade.Value(value)\n        }\n    var transform\n        get() = style.transform.value\n        set(value) {\n            style.transform = Transform.Matrix(value)\n        }\n}\n\n// TODO: Deprecate this?\noperator fun KMutableProperty0<Shade>.setValue(thisRef: Style, property: KProperty<*>, value: ShadeStyle) {\n    this.set(Shade.Value(value))\n}\n\nfun transform(node: CompositionNode): Matrix44 =\n    (node.parent?.let { transform(it) } ?: Matrix44.IDENTITY) * node.transform\n\n/**\n * a [CompositionNode] that holds a single image [ColorBuffer]\n */\nclass ImageNode(var image: ColorBuffer, var x: Double, var y: Double, var width: Double, var height: Double) :\n    CompositionNode() {\n    override val bounds: Rectangle\n        get() = Rectangle(0.0, 0.0, width, height).contour.transform(transform(this)).bounds\n}\n\n/**\n * a [CompositionNode] that holds a single [Shape]\n */\nclass ShapeNode(var shape: Shape) : CompositionNode() {\n    override val bounds: Rectangle\n        get() {\n            val t = effectiveTransform\n            return if (t === Matrix44.IDENTITY) {\n                shape.bounds\n            } else {\n                shape.bounds.contour.transform(t).bounds\n            }\n        }\n\n    /**\n     * apply transforms of all ancestor nodes and return a new detached org.openrndr.shape.ShapeNode with conflated transform\n     */\n    fun conflate(): ShapeNode {\n        return ShapeNode(shape).also {\n            it.id = id\n            it.parent = parent\n            it.style = style\n            it.transform = transform(this)\n            it.attributes = attributes\n        }\n    }\n\n    /**\n     * apply transforms of all ancestor nodes and return a new detached shape node with identity transform and transformed Shape\n     */\n    fun flatten(): ShapeNode {\n        return ShapeNode(shape.transform(transform(this))).also {\n            it.id = id\n            it.parent = parent\n            it.style = effectiveStyle\n            it.attributes = attributes\n        }\n    }\n\n    fun copy(\n        id: String? = this.id,\n        parent: CompositionNode? = null,\n        style: Style = this.style,\n        attributes: MutableMap<String, String?> = this.attributes,\n        shape: Shape = this.shape\n    ): ShapeNode {\n        return ShapeNode(shape).also {\n            it.id = id\n            it.parent = parent\n            it.style = style\n            it.attributes = attributes\n        }\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other !is ShapeNode) return false\n        if (shape != other.shape) return false\n        return true\n    }\n\n    override fun hashCode(): Int {\n        return shape.hashCode()\n    }\n\n    /**\n     * the local [Shape] with the [effectiveTransform] applied to it\n     */\n    val effectiveShape\n        get() = shape.transform(effectiveTransform)\n}\n\n/**\n * a [CompositionNode] that holds a single text\n */\ndata class TextNode(var text: String, var contour: ShapeContour?) : CompositionNode() {\n    // TODO: This should not be Rectangle.EMPTY\n    override val bounds: Rectangle\n        get() = Rectangle.EMPTY\n}\n\n/**\n * A [CompositionNode] that functions as a group node\n */\nopen class GroupNode(open val children: MutableList<CompositionNode> = mutableListOf()) : CompositionNode() {\n    override val bounds: Rectangle\n        get() {\n            return children.map { it.bounds }.bounds\n        }\n\n    fun copy(\n        id: String? = this.id,\n        parent: CompositionNode? = null,\n        style: Style = this.style,\n        children: MutableList<CompositionNode> = this.children\n    ): GroupNode {\n        return GroupNode(children).also {\n            it.id = id\n            it.parent = parent\n            it.style = style\n            it.attributes = attributes\n        }\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other !is GroupNode) return false\n\n        if (children != other.children) return false\n        return true\n    }\n\n    override fun hashCode(): Int {\n        return children.hashCode()\n    }\n}\n\ndata class CompositionDimensions(val x: Length, val y: Length, val width: Length, val height: Length) {\n    val position = Vector2((x as Length.Pixels).value, (y as Length.Pixels).value)\n    val dimensions = Vector2((width as Length.Pixels).value, (height as Length.Pixels).value)\n\n    constructor(rectangle: Rectangle) : this(\n        rectangle.corner.x.pixels,\n        rectangle.corner.y.pixels,\n        rectangle.dimensions.x.pixels,\n        rectangle.dimensions.y.pixels\n    )\n\n    override fun toString(): String = \"$x $y $width $height\"\n\n    // I'm not entirely sure why this is needed but\n    // but otherwise equality checks will never succeed\n    override fun equals(other: Any?): Boolean {\n        return other is CompositionDimensions\n            && x.value == other.x.value\n            && y.value == other.y.value\n            && width.value == other.width.value\n            && height.value == other.height.value\n    }\n\n    override fun hashCode(): Int {\n        var result = x.hashCode()\n        result = 31 * result + y.hashCode()\n        result = 31 * result + width.hashCode()\n        result = 31 * result + height.hashCode()\n        return result\n    }\n}\n\nval defaultCompositionDimensions = CompositionDimensions(0.0.pixels, 0.0.pixels, 768.0.pixels, 576.0.pixels)\n\n\nclass GroupNodeStop(children: MutableList<CompositionNode>) : GroupNode(children)\n\n/**\n * A vector composition.\n * @param root the root node of the composition\n * @param bounds the dimensions of the composition\n */\nclass Composition(val root: CompositionNode, var bounds: CompositionDimensions = defaultCompositionDimensions) {\n    constructor(root: CompositionNode, bounds: Rectangle) : this(root, CompositionDimensions(bounds))\n\n    /** SVG/XML namespaces */\n    val namespaces = mutableMapOf<String, String>()\n\n    var style: Style = Style()\n\n    /**\n     * The style attributes affecting the whole document, such as the viewBox area and aspect ratio.\n     */\n    var documentStyle: DocumentStyle = DocumentStyle()\n\n    init {\n        val (x, y, width, height) = bounds\n        style.x = x\n        style.y = y\n        style.width = width\n        style.height = height\n    }\n\n    fun findShapes() = root.findShapes()\n    fun findShape(id: String): ShapeNode? {\n        return (root.find { it is ShapeNode && it.id == id }) as? ShapeNode\n    }\n\n    fun findImages() = root.findImages()\n    fun findImage(id: String): ImageNode? {\n        return (root.find { it is ImageNode && it.id == id }) as? ImageNode\n    }\n\n    fun findGroups(): List<GroupNode> = root.findGroups()\n    fun findGroup(id: String): GroupNode? {\n        return (root.find { it is GroupNode && it.id == id }) as? GroupNode\n    }\n\n    fun clear() = (root as? GroupNode)?.children?.clear()\n\n    /** Calculates the equivalent of `1%` in pixels. */\n    internal fun normalizedDiagonalLength(): Double = sqrt(bounds.dimensions.squaredLength / 2.0)\n\n    /**\n     * Calculates effective viewport transformation using [viewBox] and [preserveAspectRatio].\n     * As per [the SVG 2.0 spec](https://svgwg.org/svg2-draft/single-page.html#coords-ComputingAViewportsTransform).\n     */\n    fun calculateViewportTransform(): Matrix44 {\n        return when (documentStyle.viewBox) {\n            ViewBox.None -> Matrix44.IDENTITY\n            is ViewBox.Value -> {\n                when (val vb = (documentStyle.viewBox as ViewBox.Value).value) {\n                    Rectangle.EMPTY -> {\n                        // The intent is to not display the element\n                        Matrix44.ZERO\n                    }\n\n                    else -> {\n                        val vbCorner = vb.corner\n                        val vbDims = vb.dimensions\n                        val eCorner = bounds.position\n                        val eDims = bounds.dimensions\n                        val (align, meetOrSlice) = documentStyle.preserveAspectRatio\n\n                        val scale = (eDims / vbDims).let {\n                            if (align != Align.NONE) {\n                                if (meetOrSlice == MeetOrSlice.MEET) {\n                                    Vector2(min(it.x, it.y))\n                                } else {\n                                    Vector2(max(it.x, it.y))\n                                }\n                            } else {\n                                it\n                            }\n                        }\n\n                        val translate = (eCorner - (vbCorner * scale)).let {\n                            val cx = eDims.x - vbDims.x * scale.x\n                            val cy = eDims.y - vbDims.y * scale.y\n                            it + when (align) {\n                                // TODO: This first one probably doesn't comply with the spec\n                                Align.NONE -> Vector2.ZERO\n                                Align.X_MIN_Y_MIN -> Vector2.ZERO\n                                Align.X_MID_Y_MIN -> Vector2(cx / 2, 0.0)\n                                Align.X_MAX_Y_MIN -> Vector2(cx, 0.0)\n                                Align.X_MIN_Y_MID -> Vector2(0.0, cy / 2)\n                                Align.X_MID_Y_MID -> Vector2(cx / 2, cy / 2)\n                                Align.X_MAX_Y_MID -> Vector2(cx, cy / 2)\n                                Align.X_MIN_Y_MAX -> Vector2(0.0, cy)\n                                Align.X_MID_Y_MAX -> Vector2(cx / 2, cy)\n                                Align.X_MAX_Y_MAX -> Vector2(cx, cy)\n                            }\n                        }\n\n                        buildTransform {\n                            translate(translate)\n                            scale(scale.x, scale.y, 1.0)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * remove node from its parent [CompositionNode]\n */\nfun CompositionNode.remove() {\n    require(parent != null) { \"parent is null\" }\n    val parentGroup = (parent as? GroupNode)\n    if (parentGroup != null) {\n        val filtered = parentGroup.children.filter {\n            it != this\n        }\n        parentGroup.children.clear()\n        parentGroup.children.addAll(filtered)\n    }\n    parent = null\n}\n\nfun CompositionNode.findTerminals(filter: (CompositionNode) -> Boolean): List<CompositionNode> {\n    val result = mutableListOf<CompositionNode>()\n    fun find(node: CompositionNode) {\n        when (node) {\n            is GroupNode -> node.children.forEach { find(it) }\n            else -> if (filter(node)) {\n                result.add(node)\n            }\n        }\n    }\n    find(this)\n    return result\n}\n\nfun CompositionNode.findAll(filter: (CompositionNode) -> Boolean): List<CompositionNode> {\n    val result = mutableListOf<CompositionNode>()\n    fun find(node: CompositionNode) {\n        if (filter(node)) {\n            result.add(node)\n        }\n        if (node is GroupNode) {\n            node.children.forEach { find(it) }\n        }\n    }\n    find(this)\n    return result\n}\n\n/**\n * Finds first [CompositionNode] to match the given [predicate].\n */\nfun CompositionNode.find(predicate: (CompositionNode) -> Boolean): CompositionNode? {\n    if (predicate(this)) {\n        return this\n    } else if (this is GroupNode) {\n        val deque: ArrayDeque<CompositionNode> = ArrayDeque(children)\n        while (deque.isNotEmpty()) {\n            val node = deque.removeFirst()\n            if (predicate(node)) {\n                return node\n            } else if (node is GroupNode) {\n                deque.addAll(node.children)\n            }\n        }\n    }\n    return null\n}\n\n/**\n * find all descendant [ShapeNode] nodes, including potentially this node\n * @return a [List] of [ShapeNode] nodes\n */\nfun CompositionNode.findShapes(): List<ShapeNode> = findTerminals { it is ShapeNode }.map { it as ShapeNode }\n\n/**\n * find all descendant [ImageNode] nodes, including potentially this node\n * @return a [List] of [ImageNode] nodes\n */\nfun CompositionNode.findImages(): List<ImageNode> = findTerminals { it is ImageNode }.map { it as ImageNode }\n\n/**\n * find all descendant [GroupNode] nodes, including potentially this node\n * @return a [List] of [GroupNode] nodes\n */\nfun CompositionNode.findGroups(): List<GroupNode> = findAll { it is GroupNode }.map { it as GroupNode }\n\n/**\n * visit this [CompositionNode] and all descendant nodes and execute [visitor]\n */\nfun CompositionNode.visitAll(visitor: (CompositionNode.() -> Unit)) {\n    visitor()\n    if (this is GroupNode) {\n        for (child in children) {\n            child.visitAll(visitor)\n        }\n    }\n}\n\n/**\n * org.openrndr.shape.UserData delegate\n */\nclass UserData<T : Any>(\n    val name: String, val initial: T\n) {\n    @Suppress(\"UNCHECKED_CAST\")\n    operator fun getValue(node: CompositionNode, property: KProperty<*>): T {\n        val value: T? = node.userData[name] as? T\n        return value ?: initial\n    }\n\n    operator fun setValue(stylesheet: CompositionNode, property: KProperty<*>, value: T) {\n        stylesheet.userData[name] = value\n    }\n}\n\nfun CompositionNode.filter(filter: (CompositionNode) -> Boolean): CompositionNode? {\n    val f = filter(this)\n\n    if (!f) {\n        return null\n    }\n\n    if (this is GroupNode) {\n        val copies = mutableListOf<CompositionNode>()\n        children.forEach {\n            val filtered = it.filter(filter)\n            if (filtered != null) {\n                when (filtered) {\n                    is ShapeNode -> {\n                        copies.add(filtered.copy(parent = this))\n                    }\n\n                    is GroupNode -> {\n                        copies.add(filtered.copy(parent = this))\n                    }\n\n                    else -> {\n\n                    }\n                }\n            }\n        }\n        return GroupNode(children = copies)\n    } else {\n        return this\n    }\n}\n\nfun CompositionNode.map(mapper: (CompositionNode) -> CompositionNode): CompositionNode {\n    val r = mapper(this)\n    return when (r) {\n        is GroupNodeStop -> {\n            r.copy().also { copy ->\n                copy.children.forEach {\n                    it.parent = copy\n                }\n            }\n        }\n\n        is GroupNode -> {\n            val copy = r.copy(children = r.children.map { it.map(mapper) }.toMutableList())\n            copy.children.forEach {\n                it.parent = copy\n            }\n            copy\n        }\n\n        else -> r\n    }\n}","@file:Suppress(\"RemoveExplicitTypeArguments\")\n\npackage org.openrndr.extra.composition\nimport org.openrndr.color.*\nimport org.openrndr.draw.*\nimport org.openrndr.extra.composition.AttributeOrPropertyKey.*\nimport org.openrndr.extra.composition.Inheritance.*\nimport org.openrndr.math.*\nimport org.openrndr.shape.Rectangle\nimport kotlin.reflect.*\n\nenum class Inheritance {\n    INHERIT,\n    RESET\n}\n\nsealed interface AttributeOrPropertyValue {\n    val value: Any?\n    override fun toString(): String\n}\n\nsealed interface Paint : AttributeOrPropertyValue {\n    override val value: ColorRGBa?\n\n    class RGB(override val value: ColorRGBa) : Paint {\n        override fun toString(): String {\n            val hexs = listOf(value.r, value.g, value.b).map {\n                (it.coerceIn(0.0, 1.0) * 255.0).toInt().toString(16).padStart(2, '0')\n            }\n            return hexs.joinToString(prefix = \"#\", separator = \"\")\n        }\n    }\n\n    // This one is kept just in case, it's not handled in any way yet\n    object CurrentColor : Paint {\n        override val value: ColorRGBa\n            get() = TODO(\"Not yet implemented\")\n\n        override fun toString(): String = \"currentcolor\"\n    }\n\n    object None : Paint {\n        override val value: ColorRGBa? = null\n        override fun toString(): String = \"none\"\n    }\n}\n\nsealed interface Shade : AttributeOrPropertyValue {\n    override val value: ShadeStyle\n\n    class Value(override val value: ShadeStyle) : Shade {\n        override fun toString(): String = \"\"\n    }\n}\n\nsealed interface Length : AttributeOrPropertyValue {\n    override val value: Double\n\n    class Pixels(override val value: Double) : Length {\n        companion object {\n            fun fromInches(value: Double) = Pixels(value * 96.0)\n            fun fromPicas(value: Double) = Pixels(value * 16.0)\n            fun fromPoints(value: Double) = Pixels(value * (4.0 / 3.0))\n            fun fromCentimeters(value: Double) = Pixels(value * (96.0 / 2.54))\n            fun fromMillimeters(value: Double) = Pixels(value * (96.0 / 25.4))\n            fun fromQuarterMillimeters(value: Double) = Pixels(value * (96.0 / 101.6))\n        }\n\n        override fun toString(): String = \"$value\"\n    }\n\n    class Percent(override val value: Double) : Length {\n        override fun toString(): String {\n            return \"${value}%\"\n        }\n    }\n\n    enum class UnitIdentifier {\n        IN,\n        PC,\n        PT,\n        PX,\n        CM,\n        MM,\n        Q\n    }\n}\n\ninline val Double.pixels: Length.Pixels\n    get() = Length.Pixels(this)\ninline val Double.percent: Length.Percent\n    get() = Length.Percent(this)\n\nsealed interface Numeric : AttributeOrPropertyValue {\n    override val value: Double\n\n    class Rational(override val value: Double) : Numeric {\n        override fun toString(): String = \"$value\"\n    }\n}\n\nsealed interface Transform : AttributeOrPropertyValue {\n    override val value: Matrix44\n\n    class Matrix(override val value: Matrix44) : Transform {\n        override fun toString(): String {\n            return if (value == Matrix44.IDENTITY) {\n                \"\"\n            } else {\n                \"matrix(${value.c0r0} ${value.c0r1} \" +\n                    \"${value.c1r0} ${value.c1r1} \" +\n                    \"${value.c3r0} ${value.c3r1})\"\n            }\n        }\n    }\n\n    object None : Transform {\n        override val value = Matrix44.IDENTITY\n        override fun toString(): String = \"\"\n    }\n}\n\nsealed interface Visibility : AttributeOrPropertyValue {\n    override val value: Boolean\n\n    object Visible : Visibility {\n        override val value = true\n        override fun toString() = \"visible\"\n    }\n\n    object Hidden : Visibility {\n        override val value = false\n        override fun toString() = \"hidden\"\n    }\n\n    // This exists because the spec specifies so,\n    // it is effectively Hidden.\n    object Collapse : Visibility {\n        override val value = false\n        override fun toString() = \"collapse\"\n    }\n}\n\nsealed interface Display : AttributeOrPropertyValue {\n    override val value: Boolean\n\n    object Inline : Display {\n        override val value = true\n        override fun toString() = \"inline\"\n    }\n\n    object Block : Display {\n        override val value = true\n        override fun toString() = \"block\"\n    }\n\n    object None : Display {\n        override val value = false\n        override fun toString() = \"none\"\n    }\n}\n\nsealed interface LineCap : AttributeOrPropertyValue {\n    override val value: org.openrndr.draw.LineCap\n\n    object Round : LineCap {\n        override val value = org.openrndr.draw.LineCap.ROUND\n        override fun toString() = \"round\"\n    }\n\n    object Butt : LineCap {\n        override val value = org.openrndr.draw.LineCap.BUTT\n        override fun toString() = \"butt\"\n    }\n\n    object Square : LineCap {\n        override val value = org.openrndr.draw.LineCap.SQUARE\n        override fun toString() = \"square\"\n    }\n}\n\nsealed interface LineJoin : AttributeOrPropertyValue {\n    override val value: org.openrndr.draw.LineJoin\n\n    object Miter : LineJoin {\n        override val value = org.openrndr.draw.LineJoin.MITER\n        override fun toString() = \"miter\"\n    }\n\n    object Bevel : LineJoin {\n        override val value = org.openrndr.draw.LineJoin.BEVEL\n        override fun toString() = \"bevel\"\n    }\n\n    object Round : LineJoin {\n        override val value = org.openrndr.draw.LineJoin.ROUND\n        override fun toString() = \"round\"\n    }\n}\n\nenum class Align {\n    NONE,\n    X_MIN_Y_MIN,\n    X_MID_Y_MIN,\n    X_MAX_Y_MIN,\n    X_MIN_Y_MID,\n    X_MID_Y_MID,\n    X_MAX_Y_MID,\n    X_MIN_Y_MAX,\n    X_MID_Y_MAX,\n    X_MAX_Y_MAX\n}\n\nenum class MeetOrSlice {\n    MEET,\n    SLICE\n}\n\ndata class AspectRatio(val align: Align, val meetOrSlice: MeetOrSlice) : AttributeOrPropertyValue {\n    override val value = this\n\n    companion object {\n        val DEFAULT = AspectRatio(Align.X_MID_Y_MID, MeetOrSlice.MEET)\n    }\n\n    override fun toString(): String {\n        if (this == DEFAULT) {\n            return \"\"\n        }\n\n        val a = when (align) {\n            Align.NONE -> \"none\"\n            Align.X_MIN_Y_MIN -> \"xMinYMin\"\n            Align.X_MID_Y_MIN -> \"xMidYMin\"\n            Align.X_MAX_Y_MIN -> \"xMaxYMin\"\n            Align.X_MIN_Y_MID -> \"xMinYMid\"\n            Align.X_MID_Y_MID -> \"xMidYMid\"\n            Align.X_MAX_Y_MID -> \"xMaxYMid\"\n            Align.X_MIN_Y_MAX -> \"xMinYMax\"\n            Align.X_MID_Y_MAX -> \"xMidYMax\"\n            Align.X_MAX_Y_MAX -> \"xMaxYMax\"\n        }\n        val m = when (meetOrSlice) {\n            MeetOrSlice.MEET -> \"meet\"\n            MeetOrSlice.SLICE -> \"slice\"\n        }\n\n        return \"$a $m\"\n    }\n}\n\nsealed interface ViewBox : AttributeOrPropertyValue {\n    override val value: Rectangle?\n\n    class Value(override val value: Rectangle) : ViewBox {\n        override fun toString(): String =\n            \"${value.x.toInt()} ${value.y.toInt()} ${value.width.toInt()} ${value.height.toInt()}\"\n    }\n\n    /**\n     * The viewBox has not been defined,\n     * **not** that it doesn't exist.\n     */\n    object None : ViewBox {\n        override val value: Rectangle? = null\n        override fun toString(): String = \"\"\n    }\n}\n\nprivate data class PropertyBehavior(val inherit: Inheritance, val initial: AttributeOrPropertyValue)\n\nprivate object PropertyBehaviors {\n    val behaviors = HashMap<AttributeOrPropertyKey, PropertyBehavior>()\n}\n\nprivate class PropertyDelegate<T : AttributeOrPropertyValue>(\n    val name: AttributeOrPropertyKey,\n    inheritance: Inheritance,\n    val initial: T\n) {\n    init {\n        PropertyBehaviors.behaviors[name] = PropertyBehavior(inheritance, initial)\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    operator fun getValue(style: Styleable, property: KProperty<*>): T {\n        return (style[name] ?: PropertyBehaviors.behaviors[name]!!.initial) as T\n    }\n\n    operator fun setValue(style: Styleable, property: KProperty<*>, value: T?) {\n        style[name] = value\n    }\n}\n\nsealed class Styleable {\n    val properties = HashMap<AttributeOrPropertyKey, AttributeOrPropertyValue?>()\n\n    operator fun get(name: AttributeOrPropertyKey) = properties[name]\n\n    operator fun set(name: AttributeOrPropertyKey, value: AttributeOrPropertyValue?) {\n        properties[name] = value\n    }\n\n    infix fun inherit(from: Style): Style {\n        return Style().also {\n            from.properties.forEach { (name, value) ->\n                if (PropertyBehaviors.behaviors[name]?.inherit == INHERIT) {\n                    it.properties[name] = value\n                }\n            }\n            it.properties.putAll(properties)\n        }\n    }\n\n    // Because AttributeOrPropertyValue has a toString override,\n    // we can abuse it for equality checks.\n    fun isInherited(from: Styleable, attributeKey: AttributeOrPropertyKey): Boolean =\n        when (this.properties[attributeKey].toString()) {\n            from.properties[attributeKey].toString() -> true\n            PropertyBehaviors.behaviors[attributeKey]?.initial.toString() -> true\n            else -> false\n        }\n}\n\nclass DocumentStyle : Styleable()\nclass Style : Styleable()\n\nvar DocumentStyle.viewBox by PropertyDelegate<ViewBox>(VIEW_BOX, RESET, ViewBox.None)\nvar DocumentStyle.preserveAspectRatio by PropertyDelegate<AspectRatio>(\n    PRESERVE_ASPECT_RATIO,\n    RESET, AspectRatio.DEFAULT\n)\n\nvar Style.stroke by PropertyDelegate<Paint>(STROKE, INHERIT, Paint.None)\nvar Style.strokeOpacity by PropertyDelegate<Numeric>(STROKE_OPACITY, INHERIT, Numeric.Rational(1.0))\nvar Style.strokeWeight by PropertyDelegate<Length>(STROKE_WIDTH, INHERIT, 1.0.pixels)\nvar Style.miterLimit by PropertyDelegate<Numeric>(STROKE_MITERLIMIT, INHERIT, Numeric.Rational(4.0))\nvar Style.lineCap by PropertyDelegate<LineCap>(STROKE_LINECAP, INHERIT, LineCap.Butt)\nvar Style.lineJoin by PropertyDelegate<LineJoin>(STROKE_LINEJOIN, INHERIT, LineJoin.Miter)\n\nvar Style.fill by PropertyDelegate<Paint>(FILL, INHERIT, Paint.RGB(ColorRGBa.BLACK))\nvar Style.fillOpacity by PropertyDelegate<Numeric>(FILL_OPACITY, INHERIT, Numeric.Rational(1.0))\n\nvar Style.transform by PropertyDelegate<Transform>(TRANSFORM, RESET, Transform.None)\n\n// Okay so the spec says `display` isn't inheritable, but effectively acts so\n// when the element and its children are excluded from the rendering tree.\nvar Style.display by PropertyDelegate<Display>(DISPLAY, RESET, Display.Inline)\nvar Style.opacity by PropertyDelegate<Numeric>(OPACITY, RESET, Numeric.Rational(1.0))\nvar Style.visibility by PropertyDelegate<Visibility>(VISIBILITY, INHERIT, Visibility.Visible)\n\nvar Style.x by PropertyDelegate<Length>(X, RESET, 0.0.pixels)\nvar Style.y by PropertyDelegate<Length>(Y, RESET, 0.0.pixels)\nvar Style.width by PropertyDelegate<Length>(WIDTH, RESET, 768.0.pixels)\nvar Style.height by PropertyDelegate<Length>(HEIGHT, RESET, 576.0.pixels)\n\nvar Style.shadeStyle by PropertyDelegate<Shade>(SHADESTYLE, INHERIT, Shade.Value(ShadeStyle()))\n\nenum class AttributeOrPropertyKey {\n    // @formatter:off\n    // Attributes\n    BASE_PROFILE { override fun toString() = \"baseProfile\" },\n    CLASS { override fun toString() = \"class\" },\n    CX { override fun toString() = \"cx\" },\n    CY { override fun toString() = \"cy\" },\n    D { override fun toString() = \"d\" },\n    DX { override fun toString() = \"dx\" },\n    DY { override fun toString() = \"dy\" },\n    GRADIENT_UNITS { override fun toString() = \"gradientUnits\" },\n    HEIGHT { override fun toString() = \"height\" },\n    ID { override fun toString() = \"id\" },\n    OFFSET { override fun toString() = \"offset\" },\n    PATH_LENGTH { override fun toString() = \"pathLength\" },\n    POINTS { override fun toString() = \"points\" },\n    PRESERVE_ASPECT_RATIO { override fun toString() = \"preserveAspectRatio\" },\n    R { override fun toString() = \"r\" },\n    ROTATE { override fun toString() = \"rotate\" },\n    RX { override fun toString() = \"rx\" },\n    RY { override fun toString() = \"ry\" },\n    SPACE { override fun toString() = \"xml:space\" },\n    STYLE { override fun toString() = \"style\" },\n    TRANSFORM { override fun toString() = \"transform\" },\n    VERSION { override fun toString() = \"version\" },\n    VIEW_BOX { override fun toString() = \"viewBox\" },\n    WIDTH { override fun toString() = \"width\" },\n    X { override fun toString() = \"x\" },\n    X1 { override fun toString() = \"x1\" },\n    X2 { override fun toString() = \"x2\" },\n    Y { override fun toString() = \"y\" },\n    Y1 { override fun toString() = \"y1\" },\n    Y2 { override fun toString() = \"y2\" },\n\n    // Properties\n    COLOR { override fun toString() = \"color\" },\n    DIRECTION { override fun toString() = \"direction\" },\n    DISPLAY { override fun toString() = \"display\" },\n    DISPLAY_ALIGN { override fun toString() = \"display-align\" },\n    FILL { override fun toString() = \"fill\" },\n    FILL_OPACITY { override fun toString() = \"fill-opacity\" },\n    FILL_RULE { override fun toString() = \"fill-rule\" },\n    FONT_FAMILY { override fun toString() = \"font-family\" },\n    FONT_SIZE { override fun toString() = \"font-size\" },\n    FONT_STYLE { override fun toString() = \"font-style\" },\n    FONT_VARIANT { override fun toString() = \"font-variant\" },\n    FONT_WEIGHT { override fun toString() = \"font-weight\" },\n    OPACITY { override fun toString() = \"opacity\" },\n    STOP_COLOR { override fun toString() = \"stop-color\" },\n    STOP_OPACITY { override fun toString() = \"stop-opacity\" },\n    STROKE { override fun toString() = \"stroke\" },\n    STROKE_DASHARRAY { override fun toString() = \"stroke-dasharray\" },\n    STROKE_DASHOFFSET { override fun toString() = \"stroke-dashoffset\" },\n    STROKE_LINECAP { override fun toString() = \"stroke-linecap\" },\n    STROKE_LINEJOIN { override fun toString() = \"stroke-linejoin\" },\n    STROKE_MITERLIMIT { override fun toString() = \"stroke-miterlimit\" },\n    STROKE_OPACITY { override fun toString() = \"stroke-opacity\" },\n    STROKE_WIDTH { override fun toString() = \"stroke-width\" },\n    TEXT_ALIGN { override fun toString() = \"text-align\" },\n    TEXT_ANCHOR { override fun toString() = \"text-anchor\" },\n    UNICODE_BIDI { override fun toString() = \"unicode-bidi\" },\n    VECTOR_EFFECT { override fun toString() = \"vector-effect\" },\n    VISIBILITY { override fun toString() = \"visibility\" },\n\n    // Made-up properties\n    // because \"Compositions aren't SVGs and yadda yadda\"\n    // this one's for you, edwin\n    SHADESTYLE { override fun toString() = \"\" };\n\n    abstract override fun toString(): String\n    // @formatter:on\n}","package org.openrndr.extra.shaderphrases\n\nimport io.github.oshai.kotlinlogging.KotlinLogging\nimport org.openrndr.draw.Shader\nimport org.openrndr.extra.shaderphrases.ShaderPhraseRegistry.getGLSLFunctionName\nimport org.openrndr.utils.url.textFromURL\n\nprivate val logger = KotlinLogging.logger {}\n\n/**\n * A single shader phrase.\n */\nclass ShaderPhrase(val phrase: String) {\n    /**\n     * Register this shader phrase in the [ShaderPhraseRegistry]\n     * This will likely be called by [ShaderPhraseBook]\n     */\n    fun register(bookId: String? = null) {\n        val id = getGLSLFunctionName(phrase)\n        val prefix = bookId?.let { \"$it.\" } ?: \"\"\n        ShaderPhraseRegistry.registerPhrase(\"$prefix$id\", this)\n    }\n}\n\n/**\n * A book of shader phrases.\n */\nexpect open class ShaderPhraseBook(bookId: String) {\n    val bookId: String\n\n    /**\n     * Registers all known shader phrases\n     */\n    fun register()\n\n}\n\n/**\n * The global, application-wide, shader phrase registry\n */\nobject ShaderPhraseRegistry {\n    private val phrases = mutableMapOf<String, ShaderPhrase>()\n\n    /**\n     * Registers a [phrase] with [id]\n     */\n    fun registerPhrase(id: String, phrase: ShaderPhrase) {\n        phrases[id] = phrase\n    }\n\n    /**\n     * Finds a phrase for [id], returns null when no phrase found\n     */\n    fun findPhrase(id: String): ShaderPhrase? {\n        val phrase = phrases[id]\n        if (phrase == null) {\n            logger.warn { \"no phrase found for id: \\\"$id\\\"\" }\n        }\n        return phrase\n    }\n\n    /**\n     * Gets the first GLSL function name out of GLSL source code\n     */\n    fun getGLSLFunctionName(glsl: String): String {\n        val functionRex =\n            Regex(\"\"\"\\s*(float|int|[bi]?vec[234]|mat[234])\\s+(\\w+)\\s*\\(.*\\).*\"\"\")\n        val defs = glsl.split(\"\\n\").filter {\n            functionRex.matches(it)\n        }.take(1).mapNotNull {\n            val m = functionRex.find(it)\n            m?.groupValues?.getOrNull(2)\n        }\n        return defs.firstOrNull()\n            ?: error(\"no function body found in phrase\")\n    }\n}\n\n/**\n * Preprocess shader source.\n * Looks for \"#pragma import\" statements and injects found phrases.\n * @param source GLSL source code encoded as string\n * @return GLSL source code with injected shader phrases\n */\nfun preprocessShader(source: String, symbols: MutableSet<String> = mutableSetOf()): String {\n    val lines = source.split(\"\\n\")\n    val funcName = Regex(\"\"\"^\\s*#pragma\\s+import\\s+([a-zA-Z0-9_.]+)\"\"\")\n    val processed = lines.map { line ->\n        if (line.contains(\"#pragma\")) {\n            val symbol = funcName.find(line)?.groupValues?.get(1) ?: return@map line\n            val fullTokens = symbol.split(\".\")\n            val fieldName = fullTokens.last().replace(\";\", \"\").trim()\n            val packageClassTokens = fullTokens.dropLast(1)\n            val packageClass = packageClassTokens.joinToString(\".\")\n            if (symbol !in symbols) {\n                symbols.add(symbol)\n                val registryPhrase = ShaderPhraseRegistry.findPhrase(symbol)\n                registryPhrase?.let { preprocessShader(it.phrase, symbols) }\n            } else {\n                \"\"\n            }\n        } else {\n            line\n        }\n    }\n    return processed.joinToString(\"\\n\")\n}\n\nfun String.preprocess() = preprocessShader(this)\n\n/**\n * Preprocess shader source from url\n * Looks for \"#pragma import\" statements and injects found phrases.\n * @param url url pointing to GLSL shader source\n * @return GLSL source code with injected shader phrases\n */\nfun preprocessShaderFromUrl(url: String, symbols: MutableSet<String> = mutableSetOf()): String {\n    return preprocessShader(textFromURL(url), symbols)\n}\n\nfun Shader.Companion.preprocessedFromUrls(\n    vsUrl: String,\n    tcsUrl: String? = null,\n    tesUrl: String? = null,\n    gsUrl: String? = null,\n    fsUrl: String\n): Shader {\n    val vsCode = textFromURL(vsUrl).preprocess()\n    val tcsCode = tcsUrl?.let { textFromURL(it) }?.preprocess()\n    val tesCode = tesUrl?.let { textFromURL(it) }?.preprocess()\n    val gsCode = gsUrl?.let { textFromURL(it) }?.preprocess()\n    val fsCode = textFromURL(fsUrl).preprocess()\n    val name = \"$$vsUrl / $gsUrl / $fsUrl\"\n    return Shader.createFromCode(vsCode, tcsCode, tesCode, gsCode, fsCode, name)\n}\n\n","package org.openrndr.extra.shaderphrases\n\n/**\n * A book of shader phrases.\n */\nactual open class ShaderPhraseBook actual constructor(actual val bookId: String) {\n    private var registered = false\n    /**\n     * Registers all known shader phrases\n     */\n    actual fun register() {\n        error(\"not supported\")\n    }\n\n}","package org.openrndr.extra.shapes.bezierpatches\n\nimport org.openrndr.color.AlgebraicColor\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.color.ConvertibleToColorRGBa\nimport org.openrndr.math.Matrix44\nimport org.openrndr.math.Vector2\nimport org.openrndr.shape.Rectangle\nimport org.openrndr.shape.Segment\nimport org.openrndr.shape.ShapeContour\nimport kotlin.random.Random\n\nopen class BezierPatchBase<C>(\n    val points: List<List<Vector2>>,\n    val colors: List<List<C>> = emptyList()\n)\n        where C : AlgebraicColor<C>, C : ConvertibleToColorRGBa {\n    init {\n        require(points.size == 4 && points.all { it.size == 4 })\n        require(colors.isEmpty() || colors.size == 4 && colors.all { it.size == 4 })\n    }\n\n    /**\n     * Return a transposed version of the bezier path by transposing the [points] matrix\n     */\n    val transposed\n        get() = BezierPatchBase(\n            listOf(\n                listOf(points[0][0], points[1][0], points[2][0], points[3][0]),\n                listOf(points[0][1], points[1][1], points[2][1], points[3][1]),\n                listOf(points[0][2], points[1][2], points[2][2], points[3][2]),\n                listOf(points[0][3], points[1][3], points[2][3], points[3][3]),\n            ),\n            if (colors.isEmpty()) emptyList() else {\n                listOf(\n                    listOf(colors[0][0], colors[1][0], colors[2][0], colors[3][0]),\n                    listOf(colors[0][1], colors[1][1], colors[2][1], colors[3][1]),\n                    listOf(colors[0][2], colors[1][2], colors[2][2], colors[3][2]),\n                    listOf(colors[0][3], colors[1][3], colors[2][3], colors[3][3]),\n                )\n            }\n        )\n\n    fun transform(transform: Matrix44) = BezierPatchBase(points.map { r ->\n        r.map { (transform * it.xy01).div.xy }\n    }, colors)\n\n    private fun coeffs2(t: Double): DoubleArray {\n        val it = 1.0 - t\n        val it2 = it * it\n        val t2 = t * t\n        return doubleArrayOf(it2, 2 * it * t, t2)\n    }\n\n    private fun coeffs3(t: Double): DoubleArray {\n        val it = 1.0 - t\n        val it2 = it * it\n        val it3 = it2 * it\n        val t2 = t * t\n        val t3 = t2 * t\n        return doubleArrayOf(it3, 3 * it2 * t, 3 * it * t2, t3)\n    }\n\n    /**\n     * Return a point on the patch by using its u,v parameterization\n     * @param u a value between 0 and 1\n     * @param v a value between 0 and 1\n     */\n    fun position(u: Double, v: Double): Vector2 {\n        val csu = coeffs3(u)\n        val csv = coeffs3(v)\n        var result = Vector2.ZERO\n        for (j in 0 until 4) {\n            for (i in 0 until 4) {\n                result += points[j][i] * csu[i] * csv[j]\n            }\n        }\n        return result\n    }\n\n    /**\n     * Return a gradient vector on the patch by using its u,v parameterization\n     * @param u a value between 0 and 1\n     * @param v a value between 0 and 1\n     */\n    fun gradient(u: Double, v: Double): Vector2 {\n        val f0 = List(4) { MutableList(3) { Vector2.ZERO } }\n        for (j in 0 until 4) {\n            for (i in 0 until 3) {\n                f0[j][i] = points[j][i + 1] - points[j][i]\n            }\n        }\n\n        val f1 = List(3) { MutableList(3) { Vector2.ZERO } }\n        for (j in 0 until 3) {\n            for (i in 0 until 3) {\n                f1[j][i] = f0[j + 1][i] - f0[j][i]\n            }\n        }\n\n        val csu = coeffs2(u)\n        val csv = coeffs2(v)\n        var result = Vector2.ZERO\n        for (j in 0 until 3) {\n            for (i in 0 until 3) {\n                result += f1[j][i] * csu[i] * csv[j]\n            }\n        }\n        return result\n    }\n\n    /**\n     * Generate a random point on the path\n     * @return a point that is uniformly distributed in uv space\n     */\n    fun randomPoint(random: Random = Random.Default) = position(random.nextDouble(), random.nextDouble())\n\n    fun horizontal(v: Double): ShapeContour {\n        val cs = coeffs3(v)\n        val cps = Array(4) { Vector2.ZERO }\n        for (j in 0 until 4) {\n            for (i in 0 until 4) {\n                cps[j] += points[i][j] * cs[i]\n            }\n        }\n        return ShapeContour(listOf(Segment(cps[0], cps[1], cps[2], cps[3])), false)\n    }\n\n    fun vertical(u: Double): ShapeContour {\n        val cs = coeffs3(u)\n        val cps = Array(4) { Vector2.ZERO }\n        for (j in 0 until 4) {\n            for (i in 0 until 4) {\n                cps[j] += points[j][i] * cs[i]\n            }\n        }\n        return ShapeContour(listOf(Segment(cps[0], cps[1], cps[2], cps[3])), false)\n    }\n\n    /**\n     * Extract a sub-patch based on uv parameterization\n     */\n    fun sub(u0: Double, v0: Double, u1: Double, v1: Double): BezierPatchBase<C> {\n        val c0 = Segment(points[0][0], points[0][1], points[0][2], points[0][3]).sub(u0, u1)\n        val c1 = Segment(points[1][0], points[1][1], points[1][2], points[1][3]).sub(u0, u1)\n        val c2 = Segment(points[2][0], points[2][1], points[2][2], points[2][3]).sub(u0, u1)\n        val c3 = Segment(points[3][0], points[3][1], points[3][2], points[3][3]).sub(u0, u1)\n\n        val sub0 = bezierPatch(c0, c1, c2, c3)\n        val d0 = Segment(sub0.points[0][0], sub0.points[1][0], sub0.points[2][0], sub0.points[3][0]).sub(v0, v1)\n        val d1 = Segment(sub0.points[0][1], sub0.points[1][1], sub0.points[2][1], sub0.points[3][1]).sub(v0, v1)\n        val d2 = Segment(sub0.points[0][2], sub0.points[1][2], sub0.points[2][2], sub0.points[3][2]).sub(v0, v1)\n        val d3 = Segment(sub0.points[0][3], sub0.points[1][3], sub0.points[2][3], sub0.points[3][3]).sub(v0, v1)\n\n        return fromSegments<C>(d0, d1, d2, d3).transposed\n    }\n\n    val contour: ShapeContour = ShapeContour(\n        listOf(\n            Segment(points[0][0], points[0][1], points[0][2], points[0][3]),\n            Segment(points[0][3], points[1][3], points[2][3], points[3][3]),\n            Segment(points[3][3], points[3][2], points[3][1], points[3][0]),\n            Segment(points[3][0], points[2][0], points[1][0], points[0][0]),\n        ), true\n    )\n\n    operator fun times(scale: Double) =\n        BezierPatchBase(\n            points.map { j -> j.map { i -> i * scale } },\n            if (colors.isEmpty()) colors else colors.map { j -> j.map { i -> i * scale } }\n        )\n\n    operator fun div(scale: Double) =\n        BezierPatchBase(points.map { j -> j.map { i -> i / scale } },\n            if (colors.isEmpty()) colors else colors.map { j -> j.map { i -> i / scale } }\n        )\n    operator fun plus(right: BezierPatchBase<C>) =\n        BezierPatchBase(List(4) { j -> List(4) { i -> points[j][i] + right.points[j][i] } },\n            if (colors.isEmpty() && right.colors.isEmpty()) { colors }\n            else if (colors.isEmpty() && right.colors.isNotEmpty()) { right.colors }\n            else if (colors.isNotEmpty() && right.colors.isEmpty()) { colors }\n            else { List(4) { j -> List(4) { i -> colors[j][i] + right.colors[j][i] } } }\n            )\n\n    operator fun minus(right: BezierPatchBase<C>) =\n        BezierPatchBase(List(4) { j -> List(4) { i -> points[j][i] - right.points[j][i] } },\n            if (colors.isEmpty() && right.colors.isEmpty()) { colors }\n            else if (colors.isEmpty() && right.colors.isNotEmpty()) { right.colors }\n            else if (colors.isNotEmpty() && right.colors.isEmpty()) { colors }\n            else { List(4) { j -> List(4) { i -> colors[j][i] - right.colors[j][i] } } }\n            )\n\n    fun <K> withColors(colors: List<List<K>>): BezierPatchBase<K>\n            where K : AlgebraicColor<K>, K : ConvertibleToColorRGBa {\n        return BezierPatchBase(points, colors)\n    }\n\n    companion object {\n        fun <C> fromSegments(c0: Segment, c1: Segment, c2: Segment, c3: Segment): BezierPatchBase<C>\n                where C : AlgebraicColor<C>, C : ConvertibleToColorRGBa {\n            val c0c = c0.cubic\n            val c1c = c1.cubic\n            val c2c = c2.cubic\n            val c3c = c3.cubic\n\n            val c0l = listOf(c0c.start, c0c.control[0], c0c.control[1], c0c.end)\n            val c1l = listOf(c1c.start, c1c.control[0], c1c.control[1], c1c.end)\n            val c2l = listOf(c2c.start, c2c.control[0], c2c.control[1], c2c.end)\n            val c3l = listOf(c3c.start, c3c.control[0], c3c.control[1], c3c.end)\n\n            return BezierPatchBase(listOf(c0l, c1l, c2l, c3l))\n        }\n    }\n}\n\nclass BezierPatch(points: List<List<Vector2>>, colors: List<List<ColorRGBa>> = emptyList()) :\n    BezierPatchBase<ColorRGBa>(points, colors)\n\n/**\n * Create a cubic bezier patch from 4 segments. The control points of the segments are used in row-wise fashion\n */\nfun bezierPatch(c0: Segment, c1: Segment, c2: Segment, c3: Segment): BezierPatch {\n    val c0c = c0.cubic\n    val c1c = c1.cubic\n    val c2c = c2.cubic\n    val c3c = c3.cubic\n\n    val c0l = listOf(c0c.start, c0c.control[0], c0c.control[1], c0c.end)\n    val c1l = listOf(c1c.start, c1c.control[0], c1c.control[1], c1c.end)\n    val c2l = listOf(c2c.start, c2c.control[0], c2c.control[1], c2c.end)\n    val c3l = listOf(c3c.start, c3c.control[0], c3c.control[1], c3c.end)\n\n    return BezierPatch(listOf(c0l, c1l, c2l, c3l))\n}\n\n/**\n * Create a bezier patch from a closed shape contour (with 4 segments).\n * @param alpha control for linearity, default is `1.0/3.0`\n */\nfun bezierPatch(shapeContour: ShapeContour, alpha: Double = 1.0 / 3.0): BezierPatch {\n    require(shapeContour.segments.size == 4) {\n        \"\"\"contour needs exactly 4 segments (has ${shapeContour.segments.size})\"\"\"\n    }\n    val c0 = shapeContour.segments[0].cubic\n    val c1 = shapeContour.segments[1].cubic\n    val c2 = shapeContour.segments[2].cubic\n    val c3 = shapeContour.segments[3].cubic\n\n    val fa = 1.0 - alpha\n    val fb = alpha\n\n    val x00 = (c0.control[0] * fa + c2.control[1] * fb + c3.control[1] * fa + c1.control[0] * fb) / 2.0\n    val x01 = (c0.control[1] * fa + c2.control[0] * fb + c3.control[1] * fb + c1.control[0] * fa) / 2.0\n    val x10 = (c0.control[0] * fb + c2.control[1] * fa + c3.control[0] * fa + c1.control[1] * fb) / 2.0\n    val x11 = (c0.control[1] * fb + c2.control[0] * fa + c3.control[0] * fb + c1.control[1] * fa) / 2.0\n    val cps = listOf(\n        listOf(c0.start, c0.control[0], c0.control[1], c0.end),\n        listOf(c3.control[1], x00, x01, c1.control[0]),\n        listOf(c3.control[0], x10, x11, c1.control[1]),\n        listOf(c2.end, c2.control[1], c2.control[0], c2.start),\n    )\n    return BezierPatch(cps)\n}\n\n/**\n * Create a bezier patch from 4 corners\n * @param corners a list of corners from which to create the patch\n * @param alpha control for linearity, default is `1.0/3.0`\n */\nfun bezierPatch(corners: List<Vector2>, alpha: Double = 1.0 / 3.0): BezierPatch {\n    require(corners.size == 4) {\n        \"\"\"need exactly 4 corners (got ${corners.size}\"\"\"\n    }\n    return bezierPatch(ShapeContour.fromPoints(corners, true), alpha)\n}\n\n/**\n * Distort a shape contour\n */\nfun BezierPatch.distort(shapeContour: ShapeContour, referenceRectangle: Rectangle = shapeContour.bounds): ShapeContour {\n    val distortedSegments = shapeContour.segments.map {\n        val c = it.cubic\n        val e = c.end.map(referenceRectangle)\n        val c0 = c.control[0].map(referenceRectangle)\n        val c1 = c.control[1].map(referenceRectangle)\n        val s = c.start.map(referenceRectangle)\n\n        val ne = position(e.x, e.y)\n        val ns = position(s.x, s.y)\n        val nc0 = position(c0.x, c0.y)\n        val nc1 = position(c1.x, c1.y)\n        Segment(ns, nc0, nc1, ne)\n    }\n    return ShapeContour(distortedSegments, shapeContour.closed, shapeContour.polarity)\n}\n\nprivate fun Vector2.map(rect: Rectangle): Vector2 {\n    val nx = (x - rect.x) / rect.width\n    val ny = (y - rect.y) / rect.height\n    return Vector2(nx, ny)\n}\n","package org.openrndr.extra.shapes.bezierpatches\n\nimport org.openrndr.color.AlgebraicColor\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.color.ConvertibleToColorRGBa\nimport org.openrndr.math.Matrix44\nimport org.openrndr.math.Vector3\nimport org.openrndr.shape.Path3D\nimport org.openrndr.shape.Segment3D\nimport kotlin.random.Random\n\nopen class BezierPatch3DBase<C>(\n    val points: List<List<Vector3>>,\n    val colors: List<List<C>> = emptyList()\n)\n        where C : AlgebraicColor<C>, C : ConvertibleToColorRGBa {\n    init {\n        require(points.size == 4 && points.all { it.size == 4 })\n        require(colors.isEmpty() || colors.size == 4 && colors.all { it.size == 4 })\n    }\n\n    /**\n     * Return a transposed version of the bezier path by transposing the [points] matrix\n     */\n    val transposed\n        get() = BezierPatch3DBase(\n            listOf(\n                listOf(points[0][0], points[1][0], points[2][0], points[3][0]),\n                listOf(points[0][1], points[1][1], points[2][1], points[3][1]),\n                listOf(points[0][2], points[1][2], points[2][2], points[3][2]),\n                listOf(points[0][3], points[1][3], points[2][3], points[3][3]),\n            ),\n            if (colors.isEmpty()) emptyList() else {\n                listOf(\n                    listOf(colors[0][0], colors[1][0], colors[2][0], colors[3][0]),\n                    listOf(colors[0][1], colors[1][1], colors[2][1], colors[3][1]),\n                    listOf(colors[0][2], colors[1][2], colors[2][2], colors[3][2]),\n                    listOf(colors[0][3], colors[1][3], colors[2][3], colors[3][3]),\n                )\n            }\n        )\n\n    fun transform(transform: Matrix44) = BezierPatch3DBase(points.map { r ->\n        r.map { (transform * it.xyz1).div }\n    }, colors)\n\n    private fun coeffs2(t: Double): DoubleArray {\n        val it = 1.0 - t\n        val it2 = it * it\n        val t2 = t * t\n        return doubleArrayOf(it2, 2 * it * t, t2)\n    }\n\n    private fun coeffs3(t: Double): DoubleArray {\n        val it = 1.0 - t\n        val it2 = it * it\n        val it3 = it2 * it\n        val t2 = t * t\n        val t3 = t2 * t\n        return doubleArrayOf(it3, 3 * it2 * t, 3 * it * t2, t3)\n    }\n\n    /**\n     * Return a point on the patch by using its u,v parameterization\n     * @param u a value between 0 and 1\n     * @param v a value between 0 and 1\n     */\n    fun position(u: Double, v: Double): Vector3 {\n        val csu = coeffs3(u)\n        val csv = coeffs3(v)\n        var result = Vector3.ZERO\n        for (j in 0 until 4) {\n            for (i in 0 until 4) {\n                result += points[j][i] * csu[i] * csv[j]\n            }\n        }\n        return result\n    }\n\n    /**\n     * Return a gradient vector on the patch by using its u,v parameterization\n     * @param u a value between 0 and 1\n     * @param v a value between 0 and 1\n     */\n    fun gradient(u: Double, v: Double): Vector3 {\n        val f0 = List(4) { MutableList(3) { Vector3.ZERO } }\n        for (j in 0 until 4) {\n            for (i in 0 until 3) {\n                f0[j][i] = points[j][i + 1] - points[j][i]\n            }\n        }\n\n        val f1 = List(3) { MutableList(3) { Vector3.ZERO } }\n        for (j in 0 until 3) {\n            for (i in 0 until 3) {\n                f1[j][i] = f0[j + 1][i] - f0[j][i]\n            }\n        }\n\n        val csu = coeffs2(u)\n        val csv = coeffs2(v)\n        var result = Vector3.ZERO\n        for (j in 0 until 3) {\n            for (i in 0 until 3) {\n                result += f1[j][i] * csu[i] * csv[j]\n            }\n        }\n        return result\n    }\n\n    /**\n     * Generate a random point on the path\n     * @return a point that is uniformly distributed in uv space\n     */\n    fun randomPoint(random: Random = Random.Default) = position(random.nextDouble(), random.nextDouble())\n\n    fun horizontal(v: Double): Path3D {\n        val cs = coeffs3(v)\n        val cps = Array(4) { Vector3.ZERO }\n        for (j in 0 until 4) {\n            for (i in 0 until 4) {\n                cps[j] += points[i][j] * cs[i]\n            }\n        }\n        return Path3D(listOf(Segment3D(cps[0], cps[1], cps[2], cps[3])), false)\n    }\n\n    fun vertical(u: Double): Path3D {\n        val cs = coeffs3(u)\n        val cps = Array(4) { Vector3.ZERO }\n        for (j in 0 until 4) {\n            for (i in 0 until 4) {\n                cps[j] += points[j][i] * cs[i]\n            }\n        }\n        return Path3D(listOf(Segment3D(cps[0], cps[1], cps[2], cps[3])), false)\n    }\n\n    /**\n     * Extract a sub-patch based on uv parameterization\n     */\n    fun sub(u0: Double, v0: Double, u1: Double, v1: Double): BezierPatch3DBase<C> {\n        val c0 = Segment3D(points[0][0], points[0][1], points[0][2], points[0][3]).sub(u0, u1)\n        val c1 = Segment3D(points[1][0], points[1][1], points[1][2], points[1][3]).sub(u0, u1)\n        val c2 = Segment3D(points[2][0], points[2][1], points[2][2], points[2][3]).sub(u0, u1)\n        val c3 = Segment3D(points[3][0], points[3][1], points[3][2], points[3][3]).sub(u0, u1)\n\n        val sub0 = bezierPatch(c0, c1, c2, c3)\n        val d0 = Segment3D(sub0.points[0][0], sub0.points[1][0], sub0.points[2][0], sub0.points[3][0]).sub(v0, v1)\n        val d1 = Segment3D(sub0.points[0][1], sub0.points[1][1], sub0.points[2][1], sub0.points[3][1]).sub(v0, v1)\n        val d2 = Segment3D(sub0.points[0][2], sub0.points[1][2], sub0.points[2][2], sub0.points[3][2]).sub(v0, v1)\n        val d3 = Segment3D(sub0.points[0][3], sub0.points[1][3], sub0.points[2][3], sub0.points[3][3]).sub(v0, v1)\n\n        return fromSegments<C>(d0, d1, d2, d3).transposed\n    }\n\n    val path: Path3D = Path3D(\n        listOf(\n            Segment3D(points[0][0], points[0][1], points[0][2], points[0][3]),\n            Segment3D(points[0][3], points[1][3], points[2][3], points[3][3]),\n            Segment3D(points[3][3], points[3][2], points[3][1], points[3][0]),\n            Segment3D(points[3][0], points[2][0], points[1][0], points[0][0]),\n        ), true\n    )\n\n    operator fun times(scale: Double) =\n        BezierPatch3DBase(\n            points.map { j -> j.map { i -> i * scale } },\n            if (colors.isEmpty()) colors else colors.map { j -> j.map { i -> i * scale } }\n        )\n\n    operator fun div(scale: Double) =\n        BezierPatch3DBase(points.map { j -> j.map { i -> i / scale } },\n            if (colors.isEmpty()) colors else colors.map { j -> j.map { i -> i / scale } }\n        )\n    operator fun plus(right: BezierPatch3DBase<C>) =\n        BezierPatch3DBase(List(4) { j -> List(4) { i -> points[j][i] + right.points[j][i] } },\n            if (colors.isEmpty() && right.colors.isEmpty()) { colors }\n            else if (colors.isEmpty() && right.colors.isNotEmpty()) { right.colors }\n            else if (colors.isNotEmpty() && right.colors.isEmpty()) { colors }\n            else { List(4) { j -> List(4) { i -> colors[j][i] + right.colors[j][i] } } }\n            )\n\n    operator fun minus(right: BezierPatch3DBase<C>) =\n        BezierPatch3DBase(List(4) { j -> List(4) { i -> points[j][i] - right.points[j][i] } },\n            if (colors.isEmpty() && right.colors.isEmpty()) { colors }\n            else if (colors.isEmpty() && right.colors.isNotEmpty()) { right.colors }\n            else if (colors.isNotEmpty() && right.colors.isEmpty()) { colors }\n            else { List(4) { j -> List(4) { i -> colors[j][i] - right.colors[j][i] } } }\n            )\n\n    fun <K> withColors(colors: List<List<K>>): BezierPatch3DBase<K>\n            where K : AlgebraicColor<K>, K : ConvertibleToColorRGBa {\n        return BezierPatch3DBase(points, colors)\n    }\n\n    companion object {\n        fun <C> fromSegments(c0: Segment3D, c1: Segment3D, c2: Segment3D, c3: Segment3D): BezierPatch3DBase<C>\n                where C : AlgebraicColor<C>, C : ConvertibleToColorRGBa {\n            val c0c = c0.cubic\n            val c1c = c1.cubic\n            val c2c = c2.cubic\n            val c3c = c3.cubic\n\n            val c0l = listOf(c0c.start, c0c.control[0], c0c.control[1], c0c.end)\n            val c1l = listOf(c1c.start, c1c.control[0], c1c.control[1], c1c.end)\n            val c2l = listOf(c2c.start, c2c.control[0], c2c.control[1], c2c.end)\n            val c3l = listOf(c3c.start, c3c.control[0], c3c.control[1], c3c.end)\n\n            return BezierPatch3DBase(listOf(c0l, c1l, c2l, c3l))\n        }\n    }\n}\n\nclass BezierPatch3D(points: List<List<Vector3>>, colors: List<List<ColorRGBa>> = emptyList()) :\n    BezierPatch3DBase<ColorRGBa>(points, colors)\n\n/**\n * Create a cubic bezier patch from 4 segments. The control points of the segments are used in row-wise fashion\n */\nfun bezierPatch(c0: Segment3D, c1: Segment3D, c2: Segment3D, c3: Segment3D): BezierPatch3D {\n    val c0c = c0.cubic\n    val c1c = c1.cubic\n    val c2c = c2.cubic\n    val c3c = c3.cubic\n\n    val c0l = listOf(c0c.start, c0c.control[0], c0c.control[1], c0c.end)\n    val c1l = listOf(c1c.start, c1c.control[0], c1c.control[1], c1c.end)\n    val c2l = listOf(c2c.start, c2c.control[0], c2c.control[1], c2c.end)\n    val c3l = listOf(c3c.start, c3c.control[0], c3c.control[1], c3c.end)\n\n    return BezierPatch3D(listOf(c0l, c1l, c2l, c3l))\n}\n\n/**\n * Create a bezier patch from a closed shape contour (with 4 segments).\n * @param alpha control for linearity, default is `1.0/3.0`\n */\nfun bezierPatch(path: Path3D, alpha: Double = 1.0 / 3.0): BezierPatch3D {\n    require(path.segments.size == 4) {\n        \"\"\"contour needs exactly 4 segments (has ${path.segments.size})\"\"\"\n    }\n    val c0 = path.segments[0].cubic\n    val c1 = path.segments[1].cubic\n    val c2 = path.segments[2].cubic\n    val c3 = path.segments[3].cubic\n\n    val fa = 1.0 - alpha\n    val fb = alpha\n\n    val x00 = (c0.control[0] * fa + c2.control[1] * fb + c3.control[1] * fa + c1.control[0] * fb) / 2.0\n    val x01 = (c0.control[1] * fa + c2.control[0] * fb + c3.control[1] * fb + c1.control[0] * fa) / 2.0\n    val x10 = (c0.control[0] * fb + c2.control[1] * fa + c3.control[0] * fa + c1.control[1] * fb) / 2.0\n    val x11 = (c0.control[1] * fb + c2.control[0] * fa + c3.control[0] * fb + c1.control[1] * fa) / 2.0\n    val cps = listOf(\n        listOf(c0.start, c0.control[0], c0.control[1], c0.end),\n        listOf(c3.control[1], x00, x01, c1.control[0]),\n        listOf(c3.control[0], x10, x11, c1.control[1]),\n        listOf(c2.end, c2.control[1], c2.control[0], c2.start),\n    )\n    return BezierPatch3D(cps)\n}\n\n/**\n * Create a bezier patch from 4 corners\n * @param corners a list of corners from which to create the patch\n * @param alpha control for linearity, default is `1.0/3.0`\n */\nfun bezierPatch(corners: List<Vector3>, alpha: Double = 1.0 / 3.0): BezierPatch3D {\n    require(corners.size == 4) {\n        \"\"\"need exactly 4 corners (got ${corners.size}\"\"\"\n    }\n    return bezierPatch(Path3D.fromPoints(corners, true), alpha)\n}\n","package org.openrndr.extra.shapes.bezierpatches\n\nimport org.openrndr.color.ColorRGBa\nimport org.openrndr.draw.*\nimport org.openrndr.internal.Driver\nimport org.openrndr.math.Vector2\n\nimport org.openrndr.draw.ShadeStyleGLSL.Companion.drawerUniforms\nimport org.openrndr.draw.ShadeStyleGLSL.Companion.fragmentMainConstants\nimport org.openrndr.draw.ShadeStyleGLSL.Companion.vertexMainConstants\nimport org.openrndr.extra.shaderphrases.preprocess\nimport org.openrndr.extra.shapes.phrases.BezierPhraseBook\nimport org.openrndr.extra.color.phrases.ColorPhraseBook\nimport org.openrndr.extra.color.spaces.ColorOKLABa\nimport org.openrndr.math.Vector4\nimport kotlin.jvm.JvmName\n\nclass BezierPatchDrawer {\n    private fun vsGenerator(structure: ShadeStructure): String {\n        return \"\"\"\n            |// BezierPatchDrawer.kt / vsGenerator\n            |${drawerUniforms()}\n            |${structure.attributes.orEmpty()}\n            |${structure.varyingOut.orEmpty()}\n            |void main() {\n            |   ${vertexMainConstants()}\n            |   vec3 x_normal = vec3(0.0, 0.0, 1.0);\n            |   vec3 x_position = a_position;\n            |   ${structure.varyingBridge}\n            |}\"\"\".trimMargin()\n    }\n\n    private fun fsGenerator(structure: ShadeStructure): String {\n        return (\"\"\"\n            |// BezierPatchDrawer.kt / fsGenerator            \n            |${drawerUniforms()}\n            |${structure.varyingIn.orEmpty()}\n\n            |out vec4 o_color;\n            |void main() {\n            |   vec4 x_fill = u_fill * va_color;\n            |   vec4 x_stroke = u_stroke;\n            |   {\n            |       ${structure.fragmentTransform.orEmpty()}\n            |   }\n            |   o_color = x_fill;\n            |   o_color.rgb *= o_color.a;\n            }\"\"\".trimMargin())\n    }\n    private fun fsGeneratorOKLab(structure: ShadeStructure): String {\n        return (\"\"\"\n            |// BezierPatchDrawer.kt / fsGeneratorOKLab            \n            |${drawerUniforms()}\n            |${ColorPhraseBook.oklabToLinearRgb.phrase}\n            |${ColorPhraseBook.linearRgbToSRgb.phrase}\n            |${structure.varyingIn.orEmpty()}\n            |out vec4 o_color;\n            |void main() {\n            |   ${fragmentMainConstants(instance = \"0\")}\n            |   vec4 x_fill = u_fill * va_color;\n            |   vec4 x_stroke = u_stroke;\n            |   {\n            |       ${structure.fragmentTransform.orEmpty()}\n            |   }\n            |   o_color = linear_rgb_to_srgb(oklab_to_linear_rgb(x_fill));\n            |   o_color.rgb *= o_color.a;\n            |}\"\"\".trimMargin())\n    }\n    private fun tseGenerator(structure: ShadeStructure): String {\n        BezierPhraseBook.register()\n        return \"\"\"\n            |\n            |#pragma import beziers.bezier_patch42\n            |#pragma import beziers.bezier_patch43\n            |#pragma import beziers.bezier_patch44\n            |\n            |${drawerUniforms()}\n            |layout(quads, equal_spacing, ccw) in;\n            |\n            |in vec3 cva_position[gl_MaxPatchVertices];\n            |in vec4 cva_color[gl_MaxPatchVertices];\n            |in vec2 cva_texCoord0[gl_MaxPatchVertices];\n            |\n            |${structure.varyingOut.orEmpty()}\n            |\n            |void main() {\n            |   va_position = bezier_patch43(cva_position, gl_TessCoord.xy);\n            |   va_color = bezier_patch44(cva_color, gl_TessCoord.xy);\n            |   va_texCoord0 = bezier_patch42(cva_texCoord0, gl_TessCoord.xy);\n            |   gl_Position = u_projectionMatrix * u_viewMatrix * u_modelMatrix * vec4(va_position,1.0);\n            }\"\"\".trimMargin().preprocess()\n    }\n\n    private fun tscGenerator(structure: ShadeStructure): String {\n        return \"\"\"\n            |uniform int u_subdivisions;\n            |${drawerUniforms()}\n            |layout(vertices = 16) out; // 16 points per patch\n            |\n            |in vec3 va_position[];\n            |in vec4 va_color[];\n            |in vec2 va_texCoord0[];\n            |\n            |out vec3 cva_position[];\n            |out vec4 cva_color[];\n            |out vec2 cva_texCoord0[];\n            |\n            |void main() {\n            |   cva_position[gl_InvocationID] = va_position[gl_InvocationID];\n            |   cva_color[gl_InvocationID] = va_color[gl_InvocationID];\n            |   cva_texCoord0[gl_InvocationID] = va_texCoord0[gl_InvocationID];\n            |\n            |   if (gl_InvocationID == 0) {\n            |       gl_TessLevelOuter[0] = u_subdivisions;\n            |       gl_TessLevelOuter[1] = u_subdivisions;\n            |       gl_TessLevelOuter[2] = u_subdivisions;\n            |       gl_TessLevelOuter[3] = u_subdivisions;\n            |       gl_TessLevelInner[0] = u_subdivisions;\n            |       gl_TessLevelInner[1] = u_subdivisions;\n            |   }\n            |}\"\"\".trimMargin()\n    }\n\n    val shadeStyleManager by lazy {\n        ShadeStyleManager.fromGenerators(\n            name = \"bezier-patches\",\n            vsGenerator = ::vsGenerator,\n            tscGenerator = ::tscGenerator,\n            tseGenerator = ::tseGenerator,\n            fsGenerator = ::fsGenerator\n        )\n    }\n\n    val shadeStyleManagerOKLab by lazy {\n        ShadeStyleManager.fromGenerators(\n            name = \"bezier-patches-oklab\",\n            vsGenerator = ::vsGenerator,\n            tscGenerator = ::tscGenerator,\n            tseGenerator = ::tseGenerator,\n            fsGenerator = ::fsGeneratorOKLab\n        )\n    }\n\n    var vertices =\n            vertexBuffer(\n                vertexFormat {\n                    position(3)\n                    color(4)\n                    textureCoordinate(2)\n                }, 16, session = Session.root)\n\n\n    internal fun ensureVertexCount(count: Int) {\n        if (vertices.vertexCount < count) {\n            vertices.destroy()\n            vertices = vertexBuffer(\n                vertexFormat {\n                    position(3)\n                    color(4)\n                    textureCoordinate(2)\n                }, count, session = Session.root)\n        }\n    }\n    fun drawBezierPatches(\n        context: DrawContext,\n        drawStyle: DrawStyle,\n        bezierPatches: List<BezierPatchBase<ColorRGBa>>,\n        subdivisions: Int = 32\n    ) {\n        ensureVertexCount(bezierPatches.size * 16)\n        val shader = shadeStyleManager.shader(\n            drawStyle.shadeStyle,\n            listOf(vertices.vertexFormat),\n            emptyList()\n        )\n        vertices.put {\n            for (bezierPatch in bezierPatches) {\n                for (j in 0 until 4) {\n                    for (i in 0 until 4) {\n                        write(bezierPatch.points[j][i].xy0)\n                        if (bezierPatch.colors.isEmpty()) {\n                            write(ColorRGBa.WHITE)\n                        } else {\n                            write(bezierPatch.colors[j][i])\n                        }\n                        write(Vector2(i / 3.0, j / 3.0))\n                    }\n                }\n            }\n        }\n        shader.begin()\n        shader.uniform(\"u_subdivisions\", subdivisions)\n        context.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawVertexBuffer(\n            shader,\n            listOf(vertices),\n            DrawPrimitive.PATCHES,\n            0,\n            16 * bezierPatches.size,\n            16\n        )\n        shader.end()\n    }\n\n    @JvmName(\"drawBezierPatchesOKLab\")\n    fun drawBezierPatches(\n        context: DrawContext,\n        drawStyle: DrawStyle,\n        bezierPatches: List<BezierPatchBase<ColorOKLABa>>,\n        subdivisions: Int = 32\n    ) {\n        ensureVertexCount(bezierPatches.size * 16)\n        val shader = shadeStyleManagerOKLab.shader(\n            drawStyle.shadeStyle,\n            listOf(vertices.vertexFormat),\n            emptyList()\n        )\n\n        vertices.put {\n            for(bezierPatch in bezierPatches) {\n                for (j in 0 until 4) {\n                    for (i in 0 until 4) {\n                        write(bezierPatch.points[j][i].xy0)\n                        if (bezierPatch.colors.isEmpty()) {\n                            write(ColorRGBa.WHITE)\n                        } else {\n                            write(bezierPatch.colors[j][i].let {\n                                Vector4(it.l, it.a, it.b, it.alpha)\n                            })\n                        }\n                        write(Vector2(i / 3.0, j / 3.0))\n                    }\n                }\n            }\n        }\n        shader.begin()\n        shader.uniform(\"u_subdivisions\", subdivisions)\n        context.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawVertexBuffer(\n            shader,\n            listOf(vertices),\n            DrawPrimitive.PATCHES,\n            0,\n            16 * bezierPatches.size,\n            16\n        )\n        shader.end()\n    }\n\n    @JvmName(\"drawBezierPatches3D\")\n    fun drawBezierPatches(\n        context: DrawContext,\n        drawStyle: DrawStyle,\n        bezierPatches: List<BezierPatch3DBase<ColorRGBa>>,\n        subdivisions: Int = 32\n    ) {\n        ensureVertexCount(bezierPatches.size * 16)\n        val shader = shadeStyleManager.shader(\n            drawStyle.shadeStyle,\n            listOf(vertices.vertexFormat),\n            emptyList()\n        )\n        vertices.put {\n            for (bezierPatch in bezierPatches) {\n                for (j in 0 until 4) {\n                    for (i in 0 until 4) {\n                        write(bezierPatch.points[j][i])\n                        if (bezierPatch.colors.isEmpty()) {\n                            write(ColorRGBa.WHITE)\n                        } else {\n                            write(bezierPatch.colors[j][i])\n                        }\n                        write(Vector2(i / 3.0, j / 3.0))\n                    }\n                }\n            }\n        }\n        shader.begin()\n        shader.uniform(\"u_subdivisions\", subdivisions)\n        context.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawVertexBuffer(\n            shader,\n            listOf(vertices),\n            DrawPrimitive.PATCHES,\n            0,\n            16 * bezierPatches.size,\n            16\n        )\n        shader.end()\n    }\n\n    @JvmName(\"drawBezierPatches3DOKLab\")\n    fun drawBezierPatches(\n        context: DrawContext,\n        drawStyle: DrawStyle,\n        bezierPatches: List<BezierPatch3DBase<ColorOKLABa>>,\n        subdivisions: Int = 32\n    ) {\n        ensureVertexCount(bezierPatches.size * 16)\n        val shader = shadeStyleManagerOKLab.shader(\n            drawStyle.shadeStyle,\n            listOf(vertices.vertexFormat),\n            emptyList()\n        )\n\n        vertices.put {\n            for(bezierPatch in bezierPatches) {\n                for (j in 0 until 4) {\n                    for (i in 0 until 4) {\n                        write(bezierPatch.points[j][i])\n                        if (bezierPatch.colors.isEmpty()) {\n                            write(ColorRGBa.WHITE)\n                        } else {\n                            write(bezierPatch.colors[j][i].let {\n                                Vector4(it.l, it.a, it.b, it.alpha)\n                            })\n                        }\n                        write(Vector2(i / 3.0, j / 3.0))\n                    }\n                }\n            }\n        }\n        shader.begin()\n        shader.uniform(\"u_subdivisions\", subdivisions)\n        context.applyToShader(shader)\n        drawStyle.applyToShader(shader)\n        Driver.instance.setState(drawStyle)\n        Driver.instance.drawVertexBuffer(\n            shader,\n            listOf(vertices),\n            DrawPrimitive.PATCHES,\n            0,\n            16 * bezierPatches.size,\n            16\n        )\n        shader.end()\n    }\n}\n\nprivate val Drawer.bezierPatchDrawer: BezierPatchDrawer by lazy { BezierPatchDrawer() }\n\n@JvmName(\"bezierPatchRGBa\")\nfun Drawer.bezierPatch(bezierPatch: BezierPatchBase<ColorRGBa>, subdivisions: Int = 32) {\n    bezierPatchDrawer.drawBezierPatches(context, drawStyle, listOf(bezierPatch), subdivisions)\n}\n\n@JvmName(\"bezierPatchesRGBa\")\nfun Drawer.bezierPatches(bezierPatch: List<BezierPatchBase<ColorRGBa>>, subdivisions: Int = 32) {\n    bezierPatchDrawer.drawBezierPatches(context, drawStyle, bezierPatch, subdivisions)\n}\n\n@JvmName(\"bezierPatchOKLAB\")\nfun Drawer.bezierPatch(bezierPatch: BezierPatchBase<ColorOKLABa>, subdivisions: Int = 32) {\n    bezierPatchDrawer.drawBezierPatches(context, drawStyle, listOf(bezierPatch), subdivisions)\n}\n\n@JvmName(\"bezierPatchesOKLAB\")\nfun Drawer.bezierPatches(bezierPatch: List<BezierPatchBase<ColorOKLABa>>, subdivisions: Int = 32) {\n    bezierPatchDrawer.drawBezierPatches(context, drawStyle, bezierPatch, subdivisions)\n}\n\n@JvmName(\"bezierPatch3DRGBa\")\nfun Drawer.bezierPatch(bezierPatch: BezierPatch3DBase<ColorRGBa>, subdivisions: Int = 32) {\n    bezierPatchDrawer.drawBezierPatches(context, drawStyle, listOf(bezierPatch), subdivisions)\n}\n\n@JvmName(\"bezierPatches3DRGBa\")\nfun Drawer.bezierPatches(bezierPatch: List<BezierPatch3DBase<ColorRGBa>>, subdivisions: Int = 32) {\n    bezierPatchDrawer.drawBezierPatches(context, drawStyle, bezierPatch, subdivisions)\n}\n\n@JvmName(\"bezierPatch3DOKLAB\")\nfun Drawer.bezierPatch(bezierPatch: BezierPatch3DBase<ColorOKLABa>, subdivisions: Int = 32) {\n    bezierPatchDrawer.drawBezierPatches(context, drawStyle, listOf(bezierPatch), subdivisions)\n}\n\n@JvmName(\"bezierPatches3DOKLAB\")\nfun Drawer.bezierPatches(bezierPatch: List<BezierPatch3DBase<ColorOKLABa>>, subdivisions: Int = 32) {\n    bezierPatchDrawer.drawBezierPatches(context, drawStyle, bezierPatch, subdivisions)\n}\n","package org.openrndr.extra.shapes.phrases\n\nimport org.openrndr.extra.shaderphrases.ShaderPhrase\nimport org.openrndr.extra.shaderphrases.ShaderPhraseBook\n\nobject BezierPhraseBook: ShaderPhraseBook(\"beziers\") {\n\n    val bezier22 = ShaderPhrase(\"\"\"\n        |vec2 bezier22(vec2 a, vec2 b, float t) {\n        |   return mix(a, b, t);\n        |}\"\"\".trimMargin())\n\n    val bezier32 = ShaderPhrase(\"\"\"\n        |#pragma import $bookId.bezier22\n        |vec2 bezier32(vec2 a, vec2 b, vec2 c, float t) {\n        |   return mix(bezier22(a, b, t), bezier22(b, c, t), t);\n        |}\"\"\".trimMargin())\n\n    val bezier42 = ShaderPhrase(\"\"\"\n        |#pragma import $bookId.bezier32\n        |vec2 bezier42(vec2 a, vec2 b, vec2 c, vec2 d, float t) {\n        |   return mix(bezier32(a, b, c, t), bezier32(b, c, d, t), t);\n        |}\"\"\".trimMargin())\n\n    val bezier23 = ShaderPhrase(\"\"\"\n        |vec3 bezier23(vec3 a, vec3 b, float t) {\n        |   return mix(a, b, t);\n        |}\"\"\".trimMargin())\n\n    val bezier33 = ShaderPhrase(\"\"\"\n        |#pragma import $bookId.bezier23\n        |vec3 bezier33(vec3 a, vec3 b, vec3 c, float t) {\n        |   return mix(bezier23(a, b, t), bezier23(b, c, t), t);\n        |}\"\"\".trimMargin())\n\n    val bezier43 = ShaderPhrase(\"\"\"\n        |#pragma import $bookId.bezier33\n        |vec3 bezier43(vec3 a, vec3 b, vec3 c, vec3 d, float t) {\n        |   return mix(bezier33(a, b, c, t), bezier33(b, c, d, t), t);\n        |}\"\"\".trimMargin())\n\n    val bezier24 = ShaderPhrase(\"\"\"\n        |vec4 bezier24(vec4 a, vec4 b, float t) {\n        |   return mix(a, b, t);\n        |}\"\"\".trimMargin())\n\n    val bezier34 = ShaderPhrase(\"\"\"\n        |#pragma import $bookId.bezier24\n        |vec4 bezier34(vec4 a, vec4 b, vec4 c, float t) {\n        |   return mix(bezier24(a, b, t), bezier24(b, c, t), t);\n        |}\"\"\".trimMargin())\n\n    val bezier44 = ShaderPhrase(\"\"\"\n        |#pragma import $bookId.bezier34\n        |vec4 bezier44(vec4 a, vec4 b, vec4 c, vec4 d, float t) {\n        |   return mix(bezier34(a, b, c, t), bezier34(b, c, d, t), t);\n        |}\"\"\".trimMargin())\n\n    val bezierPatch42 = ShaderPhrase(\"\"\"\n        |#pragma import $bookId.bezier42\n        |vec2 bezier_patch42(in vec2[gl_MaxPatchVertices] cps, vec2 uv) {\n        |   vec2 p0 = bezier42(cps[0], cps[1], cps[2], cps[3], uv.x);\n        |   vec2 p1 = bezier42(cps[4], cps[5], cps[6], cps[7], uv.x);\n        |   vec2 p2 = bezier42(cps[8], cps[9], cps[10], cps[11], uv.x);\n        |   vec2 p3 = bezier42(cps[12], cps[13], cps[14], cps[15], uv.x);\n        |   return bezier42(p0, p1, p2, p3, uv.y);\n        |}\"\"\".trimMargin())\n\n    val bezierPatch43 = ShaderPhrase(\"\"\"\n        |#pragma import $bookId.bezier43\n        |vec3 bezier_patch43(in vec3[gl_MaxPatchVertices] cps, vec2 uv) {\n        |   vec3 p0 = bezier43(cps[0], cps[1], cps[2], cps[3], uv.x);\n        |   vec3 p1 = bezier43(cps[4], cps[5], cps[6], cps[7], uv.x);\n        |   vec3 p2 = bezier43(cps[8], cps[9], cps[10], cps[11], uv.x);\n        |   vec3 p3 = bezier43(cps[12], cps[13], cps[14], cps[15], uv.x);\n        |   return bezier43(p0, p1, p2, p3, uv.y);\n        |}\"\"\".trimMargin())\n\n    val bezierPatch44 = ShaderPhrase(\"\"\"\n        |#pragma import $bookId.bezier44\n        |vec4 bezier_patch44(in vec4[gl_MaxPatchVertices] cps, vec2 uv) {\n        |   vec4 p0 = bezier44(cps[0], cps[1], cps[2], cps[3], uv.x);\n        |   vec4 p1 = bezier44(cps[4], cps[5], cps[6], cps[7], uv.x);\n        |   vec4 p2 = bezier44(cps[8], cps[9], cps[10], cps[11], uv.x);\n        |   vec4 p3 = bezier44(cps[12], cps[13], cps[14], cps[15], uv.x);\n        |   return bezier44(p0, p1, p2, p3, uv.y);\n        |}\"\"\".trimMargin())\n}","package org.openrndr.extra.shapes.rectify\n\nimport org.openrndr.extra.shapes.utilities.splitAt\nimport org.openrndr.math.Matrix44\nimport org.openrndr.math.Vector2\nimport org.openrndr.math.clamp\nimport org.openrndr.shape.Segment\nimport org.openrndr.shape.ShapeContour\nimport kotlin.math.floor\n\n/**\n * RectifiedContour provides an approximately uniform parameterization for [ShapeContour]\n */\nclass RectifiedContour(val contour: ShapeContour, distanceTolerance: Double = 0.5, lengthScale: Double = 1.0) {\n    val points =\n        contour.equidistantPositionsWithT((contour.length * lengthScale).toInt().coerceAtLeast(2), distanceTolerance)\n\n    val intervals by lazy {\n        points.zipWithNext().map {\n            Pair(it.first.second, it.second.second)\n        }\n    }\n\n    private fun safe(t: Double): Double {\n        return if (contour.closed) {\n            t.mod(1.0)\n        } else {\n            t.clamp(0.0, 1.0)\n        }\n    }\n\n    /**\n     * computes a rectified t-value for [contour]\n     */\n    fun rectify(t: Double): Double {\n        if (contour.empty) {\n            return 0.0\n        } else {\n            if (t <= 0.0) {\n                return 0.0\n            }\n            val fi = t * (points.size - 1.0)\n            val fr = fi.mod(1.0)\n            val i0 = fi.toInt()\n            val i1 = i0 + 1\n\n            return if (i0 >= points.size - 1) {\n                1.0\n            } else {\n                (points[i0].second * (1.0 - fr) + points[i1].second * fr)\n            }\n        }\n    }\n\n    fun inverseRectify(t: Double): Double {\n        if (contour.empty) {\n            return 0.0\n        } else {\n            if (t <= 0.0) {\n                return 0.0\n            } else if (t >= 1.0) {\n                return 1.0\n            } else {\n                val index = intervals.binarySearch {\n                    if (t < it.first) {\n                        1\n                    } else if (t > it.second) {\n                        -1\n                    } else {\n                        0\n                    }\n                }\n                val t0 = t - intervals[index].first\n                val dt = intervals[index].second - intervals[index].first\n                val f = t0 / dt\n                val f0 = index.toDouble() / intervals.size\n                val f1 = (index + 1.0) / intervals.size\n\n                return f0 * (1.0 - f) + f1 * f\n            }\n        }\n    }\n\n    fun position(t: Double): Vector2 {\n        return if (contour.empty) {\n            Vector2.INFINITY\n        } else {\n            contour.position(rectify(safe(t)))\n        }\n    }\n\n    fun velocity(t: Double): Vector2 {\n        return if (contour.empty) {\n            Vector2.ZERO\n        } else {\n            val (segment, st) = contour.segment(rectify(safe(t)))\n            contour.segments[segment].direction(st)\n        }\n    }\n\n    fun normal(t: Double): Vector2 {\n        return if (contour.empty) {\n            Vector2.UNIT_Y\n        } else {\n            contour.normal(rectify(safe(t)))\n        }\n    }\n\n    fun pose(t: Double): Matrix44 {\n        return if (contour.empty) {\n            Matrix44.IDENTITY\n        } else {\n            contour.pose(rectify(safe(t)))\n        }\n    }\n\n    fun sub(t0: Double, t1: Double): ShapeContour {\n        if (contour.empty) {\n            return ShapeContour.EMPTY\n        }\n        return if (contour.closed) {\n            contour.sub(rectify(t0.mod(1.0)) + floor(t0), rectify(t1.mod(1.0)) + floor(t1))\n        } else {\n            contour.sub(rectify(t0), rectify(t1))\n        }\n    }\n\n    /**\n     * Split contour at [ascendingTs]\n     * @since orx 0.4.4\n     */\n    fun splitAt(ascendingTs: List<Double>, weldEpsilon: Double = 1E-6): List<ShapeContour> {\n        return contour.splitAt(ascendingTs.map { rectify(it) }, weldEpsilon)\n    }\n}\n\n/** create a rectified contour\n * @param distanceTolerance distance tolerance to use, 0.5 is the default distance tolerance\n * @param lengthScale used to compute the size of the LUT, default value is 1.0\n **/\nfun ShapeContour.rectified(distanceTolerance: Double = 0.5, lengthScale: Double = 1.0): RectifiedContour {\n    return RectifiedContour(this, distanceTolerance, lengthScale)\n}\n\n/**  create a rectified contour\n *   @param distanceTolerance distance tolerance to use, 0.5 is the default distance tolerance\n *   @param lengthScale used to compute the size of the LUT, default value is 1.0\n *\n * */\nfun Segment.rectified(distanceTolerance: Double = 0.5, lengthScale: Double = 1.0): RectifiedContour {\n    return RectifiedContour(this.contour, distanceTolerance, lengthScale)\n}","package org.openrndr.extra.shapes.utilities\n\nimport org.openrndr.shape.Segment\nimport org.openrndr.shape.ShapeContour\n\nfun ShapeContour.splitAt(segmentIndex: Double, segmentT: Double): List<ShapeContour> {\n    val t = (1.0 / segments.size) * (segmentIndex + segmentT)\n    return splitAt(listOf(t))\n}\n\nfun ShapeContour.splitAt(ascendingTs: List<Double>, weldEpsilon: Double = 1E-6): List<ShapeContour> {\n    if (empty || ascendingTs.isEmpty()) {\n        return listOf(this)\n    }\n    @Suppress(\"NAME_SHADOWING\") val ascendingTs = (listOf(0.0) + ascendingTs + listOf(1.0)).weldAscending(weldEpsilon)\n    return ascendingTs.windowed(2, 1).map {\n        sub(it[0], it[1])\n    }\n}\n\nfun Segment.splitAt(ascendingTs: List<Double>, weldEpsilon: Double = 1E-6): List<Segment> {\n    if (ascendingTs.isEmpty()) {\n        return listOf(this)\n    }\n\n    @Suppress(\"NAME_SHADOWING\") val ascendingTs = (listOf(0.0) + ascendingTs + listOf(1.0)).weldAscending(weldEpsilon)\n    return ascendingTs.windowed(2, 1).map {\n        sub(it[0], it[1])\n    }\n}","package org.openrndr.extra.shapes.utilities\n\n/**\n * Weld values if their distance is less than [epsilon]\n */\nfun List<Double>.weldAscending(epsilon: Double = 1E-6): List<Double> {\n    return if (size <= 1) {\n        this\n    } else {\n        val result = mutableListOf(first())\n        var lastPassed = first()\n        for (i in 1 until size) {\n            require(this[i] >= lastPassed) { \"input list is not in ascending order\" }\n            if (this[i] - lastPassed > epsilon) {\n                result.add(this[i])\n                lastPassed = this[i]\n            }\n        }\n        result\n    }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(366);\n"],"names":["root","factory","exports","module","define","amd","this","outerSVG","window","innerWidth","innerHeight","setAttribute","attributes","getNamedItem","removeNamedItem","svg","orchestrator","rectified","letterAnimations","millis","$rectified","$letterAnimations","$seconds","seconds","innerHTML","f","CompositionDrawer","buildComposition","$this$buildComposition","rgb","i","b","buildTransform","shapeIndex","shape","animation","contour","cutStart","cutEnd","toSVG","requestAnimationFrame","$svg","$orchestrator","it","$i","$this$buildTransform","length$factory","value","<this>","sb","first","element","toString","<get-defs>","document","createElementNS","svgns","newDefs","appendChild","setDrawAttributes","toWeb","id","gradient","joinToString","ColorRGBa","mutableListOf","node","tagName","cg","GroupNode","children","length","child","toComposition","getAttribute","path","cs","ShapeNode","op","operands","$cursor","$rx","$ry","$xAxisRot","$largeArcFlag","$sweepFlag","$end","$this$contour","p","sepReg","boolReg","cursor","group","groups","commands","token","toList","<set-?>","timeInMs","index","anim","row","latch$factory","offset","color","stop","x1","y1","x2","y2","grad","GradientBuilder","clipPath","removeLast","delay","duration","startDegrees","endDegrees","pivot","animate","console","log","attribute","values","keyTimes","keySplines","begin","emptyList","text","anchor","position","class_","textElement","textContent","x","y","radius","circle","width","height","rect","pathElement","i0","i1","Vector2","item","svgPath","SVGPath","iterator","rawCommands","numbers","arcOpReg","rawCommand","toDouble","Command","toDoubleArray","numberMatches","relativeControl","compounds","compoundIndices","ce","segments","closed","rx","ry","xAxisRot","largeArcFlag","sweepFlag","end","c","allPoints","point","target","operand","points","reflected","cp0","cp1","ShapeContour","Shape","shapes","url","resultComposition","xhr","XMLHttpRequest","open","overrideMimeType","addEventListener","$xhr","$resultComposition","responseXML","documentElement","name","composition","Composition","send","remove","loadSVG","$outerSVG","getElementById","list","n","count","buffer","separator","prefix","postfix","limit","truncated","transform","single","comparator","destination","<init>","maximumValue","minimumValue","to","low","high","expression","imports","names","version","message","replaceWith","level","warningSince","errorSince","hiddenSince","collection","array","elements","isVarargs","start","endInclusive","step","a","other","bitCount","equals","result","fromIndex","toIndex","rangeStart","rangeEnd","comparison","size","mid","cmp","random","defaultValue","$index","j","set","sum","partialWindows","thisSize","resultCapacity","windowSize","current","next","second","range","that","isPositive","min","e","Animatable_init_$Init$","DefaultClock","property","targetValue","durationInNs","startInNs","easing","Event","PropertyAnimationKey","Linear","SineIn","SineOut","SineInOut","CubicIn","CubicOut","CubicInOut","QuadIn","QuadOut","QuadInOut","QuartIn","QuartOut","QuartInOut","easer","clock","variable","builder","before","added","toSet","maxElem","maxValue","v","$added","groupDurationInNs","uak","UnitAnimationKey","AnimationEvent","durationInMs","predelayInMs","toCancel","delayInMs","delayInNs","timeInNs","updatePropertyAnimations","toRemove","triggers","key","dt","durationMillis","LinearTypeAnimationKey","DoubleAnimationKey","get","t","et","d","td","td2","performance","now","shiftInDegrees","mixAngle","hue","factor","saturation","scale","shift","luminosity","ut","q","str","pos","digitToInt","seen1","r","g","alpha","linearity","serializationConstructorMarker","certainty","left","right","sx","coerceIn","ColorXYZa","srgb","maxArg","max","ColorHSLa","l","delta","s","hue2rgb","ref","Vector4","ColorHSVa","h","mod","hsv","sh","xyz","ColorLABa","z","rgba","lab","fy","fx","fz","bestGuess","ColorLCHABa","middle","leftValid","middleValid","rightValid","laba","chroma","luva","ColorLCHUVa","ColorLUVa","u","lcha","ColorLSHABa","maxC","ColorLSHUVa","div0","up","div1","vp","divr","divp","ur","vr","hex","startsWith","vector","decoder","encoder","coerceAtMost","coerceAtLeast","l1","l2","typeParamsSerializers","hsla","ColorXSLa","map","hsva","ColorXSVa","linear","IntVector2","Vector3","IntVector3","IntVector4","Matrix33","Matrix44","DepthBuffer","imageBinding","arrayTexture","levels","imageBindings","arrayTextures","colorBuffer","colorBuffers","cubemap","cubemaps","volumeTexture","volumeTextures","BatchBuilder","drawer","drawStyle","weight","vertexFormat","BufferMultisample","contentScale","format","type","multisample","session","ObservableHashmap","clip","fill","stroke","lineCap","lineJoin","strokeWeight","smooth","miterLimit","quality","depthTestPass","depthWrite","blendMode","cullTestPass","channelWriteMask","alphaToCoverage","shadeStyle","fontMap","kerning","textSetting","stencil","frontStencil","backStencil","colorMatrix","ChannelMask","StencilStyle","hasDepth","hasStencil","red","green","blue","stencilFailOperation","depthFailOperation","depthPassOperation","stencilTestMask","stencilTestReference","stencilWriteMask","stencilTest","MeshLineDrawer","DrawStyle","RectangleDrawer","VertexBufferDrawer","CircleDrawer","PointDrawer","ImageDrawer","PerformanceLineDrawer","lazy","QualityLineDrawer","QualityPolygonDrawer","FontImageMapDrawer","matrix","toIntOrNull","Filter","shader","watcher","FontMap","ImageBinding","imageAccess","ArrayTextureImageBinding","ColorBufferImageBinding","CubemapImageBinding","VolumeTextureImageBinding","ColorAttachment","isolate","code","endsWith","structDefinitions","uniforms","buffers","vertexTransform","geometryTransform","fragmentTransform","vertexPreamble","geometryPreamble","fragmentPreamble","outputs","varyingOut","varyingIn","varyingBridge","suppressDefaultOutput","vertexCount","dimensions","drawContext","w","pa","ta","pd","pc","tc","pb","tb","bevel","x0","p1","p0","y0","dlx0","dlx1","dly0","dly1","dmr2","nleft","p1ptr","vertexBuffer","character","cx","metrics","fmcs","cy","targetContentScale","sy","rectangle","v0","pad","instance","u0","floatInstance","u1","v1","GlyphRectangle","Pair","ExpansionDrawer","counterCount","RectangleBatch","Entry","rotationInDegrees","corner","rectangles","existingBatch","geometry","entry","positions","PointBatch","CircleBatch","circles","centers","center","radii","contextBlock","normalMatrix","answer","styleBlock","testReference","writeMask","onStencilTestFail","onDepthTestFail","onDepthTestPass","Rectangle","DrawContext","action","renderTarget","bottom","top","near","far","fovY","aspectRatio","zNear","zFar","from","translate","rotateZ","rotate","axis","push","pop","batch","RectangleBatchBuilder","build","batchBuilder","PointBatchBuilder","CircleBatchBuilder","distanceTolerance","closedP","closedC","fringeWidth","openP","openC","listOf","apc","ap","ac","contours","lineSegment","pairs","corners","weights","colors","last","loops","strips","segment","source","layer","layers","texts","primitive","vertexOffset","vertexBuffers","indexBuffer","indexCount","instanceAttributes","instanceCount","SampleCount","effectiveMultisample","RenderTargetBuilder","fq","ortho","uniform","textureIndex","fontUrl","characterSet","file","cb","arrayCubemap","side","depthBuffer","Session","getValue","SessionStatistics","computeShader","bufferTexture","atomicCounterBuffer","shaderStorageBuffer","attributesBuffer","concat","vsGenerator","tscGenerator","tseGenerator","gsGenerator","fsGenerator","style","vertexFormats","instanceFormats","vsCode","tcsCode","tesCode","gsCode","fsCode","ShaderStoragePrimitive","arraySize","ShaderStorageStruct","structName","struct","hashCode","memberCount","idx","largestAlign","align","ints","paddings","paddingIdx","neededPadding","len","sIdx","structMember","endPadding","memberIdx","padding","totalSize","floatTypeFromDimensions","paddingInBytes","VertexElement","write","drawCircles","circleBatch","instanceAttributeFormats","lw","rw","chooseBevel","lx0","ly0","lu","ru","lx1","ly1","rx0","ry0","rx1","ry1","a1","a0","ncap","dx","dy","px","aa","py","dly","ax","ay","Path","sp","dropLast","drop","contourIndex","curveDivs","tessTol","calculateJoins","cverts","capSteps","Expansion","expansion","generateFringe","woff","fringe","fs","localStyle","fringeScale","command","minX","minY","maxY","maxX","quad","vertices","vertexSize","expansions","convex","context","zip","bw","lastChar","cursorX","lc","insertCharacterQuad","glyphMetrics","assertInstanceSize","iw","lastOrNull","strip","getOrNull","stripClosed","elementF","zipWithNext","previous","loopIndex","fw","effectiveFringeWidth","fillExpansions","screenPosition","contourPosition","boundsPosition","boundsSize","trimMargin","trimIndent","trueOrEmpty","elementOffset","putter","contains","fragmentShaderCode","includeShaderConfiguration","hasExistingConfiguration","listener","m","listenFunction","interval","tMin","tMax","unsafeTs","tCount","ts","sort","bounds","k","exponent","p2","noInflections","p3","QuadraticBezier2","signum","error","maxError","split","Vec2","Box","bx","by","Vec3","az","bz","Vec4","aw","Interval","ring","lastIdx","curve","Result","signedArea","compareBy","acc","hi","tLo","tHi","pLo","pHi","copyOfRange","selector","diff","sign","magnitude","copySign","origin","prev","edge","vertex","ra","rb","partition","operation","aPredicate","classify","arcs","bPredicate","DirectedGraph","mutableSetOf","graph","repairGraph","consumed","arc","edges","reversed","cycle","toMutableSet","region","isTop","Arc","unused","search","out","currIn","currOut","shuffled","ary","greedyPairing","union","obj","area","splits","Region2","DoubleAccumulator","t0","t1","cp","cpa","curves","queue","epsilon","mt","bd","ad","det","ab","qa","bc","qc","minDistance","distance","param","br","endpoint","div","mt2","t2","d1","d2","cd","qd","qpt","CubicBezier2","a2","s1","s2","intervals","threshold","approximate","midpoint","nUpper","nLower","Box3","lz","uz","vs","Box2","o","Line2","bSa","pSa","matrices","es","column","hash","addAll","Polar2","theta","rings","flat","oa","ob","init","compare","tmp","paths","indices","ns","expand","num","trim","E","D","discriminant","R","readIdx","writeIdx","b1","c2","solutions","toBits","ls","CurveInterval","lo","FatLine","tMid","av","bv","asb","dir","roots","dLen","intersections","hull","fatLine","la","lb","clipper","subject","expanded","normalized","bs","bp","iterations","collinearCheck","isCollinear","aSize","bSize","exp","queues","minIdx","Edge","indexOf","emptySet","selection","newOut","newIn","curr","seed","branches","state","ws","TarjanState","stack","includeSingletons","subgraph","asSequence","blocked","blocking","depth","adjacent","originStates","states","accept","cost","toMutableList","addToQueue","VertexUnion","dedupe","deduped","srcPos","src","destPos","dest","newState","vertexData","coords","addVertex","GLUtessellatorCallbackAdapter","CachedVertex","GLUvertex","GLUface","GLUhalfEdge","PriorityQ","PQnode","PQhandleElem","leq","PriorityQHeap","eStart","render","eOrig","Marked","trail","AddToTrail","newFace","FreeTrail","tailSize","headSize","IsEven","eTail","eHead","RenderFan","RenderStrip","RenderTriangle","eDst","eSrc","GLUtessellatorImpl","callback","Dict","dict","DictNode","frame","newNode","aNode","aDict","error_code","requireState","which","windingRule","value_offset","aCallback","flushCache","coords_offset","tooLarge","clamped","cacheVertex","data","mesh","printStackTrace","outData","gapL","gapR","o1","o2","temp","z1","z2","eNext","eSym","ePrev","aOnext","bOnext","newVertex","vNext","vNew","vPrev","fNext","fNew","fPrev","eDel","vDel","newOrg","fDel","newLface","newVertex1","newVertex2","eOrg","joiningVertices","joiningLoops","eDelSym","eNew","eNewSym","fZap","GLUmesh","mesh1","mesh2","f2","f1","v2","e2","e1","fHead","vHead","tess","maxVal","minVal","minVert","maxVert","norm","maxLen2","tNorm","tLen2","computedNormal","sUnit","tUnit","Dot","PriorityQSort","hChild","hCurr","hParent","parent","pqNodes","saveNodes","pqHandles","saveHandles","free","keyNew","hMin","Stack","piv","abs","LT","Swap","pqKeys","saveKey","sortMin","heapMin","fOrig","MaximumFan","MaximumStrip","edgeState","check","xc","vc","yc","zc","vn","xp","yp","zp","dot","key1","key2","reg1","reg2","event","reg","newEdge","RegionAbove","org","RegionBelow","dst","ActiveRegion","regNew","eNewUp","regAbove","regPrev","regFirst","regLast","eTopLeft","eFirst","regUp","eLast","firstTime","AddWinding","cleanUp","isect","needed","orgUp","dstUp","orgLo","dstLo","weights1","weights2","arraycopy","regLo","eUp","eLo","tMinUp","orgMin","toLong","eBottomLeft","degenerate","vEvent","eTopRight","tempHalfEdge","eLnext","pq","face","keepOnlyBoundary","Primitive","errnum","on","surfaceNormal","solveLinear","c0r0","c1r0","c2r0","c3r0","c0r1","c1r1","c2r1","c3r1","c0r2","c1r2","c2r2","c3r2","c0r3","c1r3","c2r3","c3r3","Matrix55","Quaternion","baseTransform","translation","cosa","_axis","sina","c0","c1","invDet","mat","c3","n00","n01","n02","n03","n10","n11","n12","n13","n20","n21","n22","n23","n30","n31","n32","n33","Polar","sr","cr","xs","ys","zs","yys","zzs","vec","xys","wzs","xzs","wys","xxs","yzs","wxs","invNorm","yy","zz","xy","zw","xz","yw","xx","yz","xw","Spherical","clamp","polar","polarity","mix","sinPhiRadius","dz","dw","degrees","scaleX","scaleY","scaleZ","eye","view","it2","it3","t3","beforeRight","beforeLeft","afterRight","afterLeft","db","saturate","da","leftAngle","rightAngle","m1","m2","d10","d32","iu","d21","copyOf","normalizationFactor","solveQuadratic","uv","Circle","IntRectangle","sumDifferences","dx1","dy2","dy1","dx2","resettableLazy","Triangle","toVec2","ContourBuilder","toCurve2","totalLength","direction","segmentLength","remaining","spacing","roundToInt","skipLength","skipT","pointsFromSegment","spaceT","skipL","deltaT","spaceL","Tessellator","fillRule","tessellator","positionData","fixed","vt1","vt2","vt3","vt4","vt12","vt23","vt34","vt123","vt234","x4","x3","d3","dl","squaredDistanceTo","da1","da2","sample","vt1234","uAnchor","vAnchor","kappa","isInner","distSq","rDiff","otherRadiusSigned","hyp","adj","tp","tp2","query","z0","LineSegment","anchorPoint","times","tangent","anchorT","targetLength","Path3D","segmentOffset","samples","adaptivePoints","sampleEquidistant","pointCount","sampleEquidistantWithT","segment0","segment1","newSegments","segmentOffset0","segmentOffset1","st","PathProjection3D","nearest","fixedSegments","fixLeft","anchorUV","offsetY","anchorU","anchorV","fitWidth","fitHeight","anchorPosition","xScale","yScale","above","below","leftOf","rightOf","nx","ny","lut","hits","cLength","cLut","partitionCount","summedLength","partitionLength","currentPoint","remainingLength","relativePoint","solveCubic","distance2","searchStarts","SegmentPoint","tStart","tControl","tEnd","bezier","dPoints","d0","dp0","dp1","tolerance","angle","n1","n2","Segment","safeDerivative","splitSigma","iz","iz2","iz3","z3","lsm","plx","ply","rsm","prx","pry","closestDistance","closestIndex","closestValue","closest","SegmentProjection3D","ft","tstart","tend","dpoints","Segment3D","derivative","pz","plz","prz","contentToString","control","contentEquals","contentHashCode","receiver","minElem","minValue","randomValues","sortedDescending","triangle","removeLastOrNull","mapper","winding","cw","ccw","candidates","connectEpsilon","control0","control1","c0x","c0y","c1x","c1y","reverse","through","tx","ty","tdx","tdy","radiiEpsilon","cosAngle","sinAngle","radiiCheck","rxSqr","rySqr","y1Sqr","x1Sqr","sq","coefficient","cx1","cy1","uy","ux","vy","vx","angleExtent","numSegments","angleStart","angleIncrement","coordinates","controlLength","arcToBeziers","bezierPoints","crx","cry","tangentScale","usePoints","segmentCount","segmentIndex","lastSampleIndex","take","ContourPoint","centroid","rotation","omega","x23","x13","x32","x31","minD","maxD","su0","b0","bary","b2","initCapacity","resize","myK","greater","exch","swim","sink","HeapIterator","ArrayBuffer","MPPBuffer","DataView","fromBytes","dv","setInt8","getInt32","getFloat32","getFloat64","getInt8","byteLength","byte","setFloat32","float","setFloat64","double","setInt32","int","ResettableDelegate","initializer","ShaderPhraseBook","ShaderPhrase","lnl","mnl","snl","ColorOKLABa","oklaba","ColorOKLCHa","Style","DocumentStyle","CompositionNode","predicate","deque","image","filter","$filter","Pixels","CompositionDimensions","Styleable","AspectRatio","PropertyDelegate","Rational","RGB","Value","findShapes","$id","find","findImages","findGroups","$translate","$scale","vb","vbCorner","vbDims","eCorner","eDims","meetOrSlice","Matrix","padStart","attributeKey","phrase","symbols","lines","funcName","symbol","fullTokens","packageClassTokens","registryPhrase","preprocessShader","bookId","glsl","functionRex","firstOrNull","BezierPatchBase","BezierPatch3DBase","structure","preprocess","safe","lengthScale","ascendingTs","lastPassed","weldAscending","weldEpsilon","c0c","c1c","c2c","c3c","c0l","c1l","c2l","c3l","coeffs3","csu","csv","f0","coeffs2","cps","BezierPatch","sub0","BezierPatch3D","bezierPatches","bezierPatch","subdivisions","fi","fr","$t","binarySearch","splitAt","RectifiedContour","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}